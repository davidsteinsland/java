<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="no" lang="no">
<head>
 <title lang="no">Delkapittel 5.4 &nbsp;&#150;&nbsp; Huffmantrær &nbsp; &#8211; &nbsp;&nbsp; </title>
 <link rel="stylesheet" media="screen" type="text/css" href="../../appolonius.css" title="Standard" />
 <link rel="stylesheet" media="print" type="text/css" href="../../appoloniusprint.css" title="Standard" />
 <link rel="alternate stylesheet" media="screen" type="text/css" href="../../appolonius2.css" title="Alternativ" />
 <link rel="alternate stylesheet" media="print" type="text/css" href="../../appoloniusprint2.css" title="Alternativ" />
 <link rel="shortcut icon" href="../../blomst.ico" type="image/x-icon" />
 <meta http-equiv = "Content-Type" content = "text/html;charset=iso-8859-1" />
 <script type="text/javascript" src="../../appolonius.js"></script>
</head>

<body>

<div class="heading">
  <b>Algoritmer og datastrukturer<br />
  Kapittel 5 - Delkapittel 5.4</b>
</div>

<div class="tekst">

<div class="overskrift">
 5.4 &nbsp;Huffmantrær
</div>


<!-- /////// Avsnitt 5.4.1 ///////////// -->

<div><br/><a name="5.4.1" tabindex="1"></a>
<a tabindex="-1" href="#5.4.2"><img class="icon" src="../../images/kvadratx.gif"
 alt="Til Avsnitt 5.4.2 - Prefikskoder"
 title="Til Avsnitt 5.4.2 - Prefikskoder" width="25" height="25" /></a>
<b>&nbsp; 5.4.1 &nbsp;Datakomprimering</b><br/>

  <table class="vbilde" cellspacing="0">
   <tr><td>
    <img src="images/huffman.jpg" alt="David Huffman" title="David Huffman"
     width="80" height="107" /></td></tr>
   <tr><td><a tabindex="-1" href="http://en.wikipedia.org/wiki/David_A._Huffman">D. Huffman</a></td></tr>
  </table>

 Et Huffmantre er et
 <a tabindex="-1" href="../../kap1/2/kap12.html#def.1.2.11.c">fullt binærtre</a>
 med spesielle egenskaper og
 brukes i forbindelse med komprimering av data. Det er oppkalt etter
 <a tabindex="-1" href="http://en.wikipedia.org/wiki/David_A._Huffman">David Huffman</a>.
 Først litt bakgrunnsstoff: En viktig oppgave i databehandling er å komprimere
 informasjon. Når informasjon skal sendes (f.eks. over internett) eller lagres, er det gunstig
 at den &laquo;komprimeres&raquo;. Det må imidlertid foregå på en slik måte at informasjonens
 opprinnelige form og innhold kan gjenskapes (eng: lossless compression).
 Den omvendte prosessen, dvs. å gjenskape informasjonen, kalles &laquo;dekomprimering&raquo; (eng: lossless decompression).
</div>

<p>
 Anta som et eksempel at vi har en sekvens med 100 bokstaver og at den kun
 inneholder bokstavene fra A til H.
 Vi antar også at disse 100 bokstavene består av 12 A-er, 7 B-er, 3 C-er, 14 D-er,
 28 E-er, 9 F-er, 5 G-er og 22 H-er. Antallet forekomster av en bokstav kalles
 bokstavens <i>frekvens</i>. Denne sekvensen på 100 bokstaver kan ikke være tatt ut fra
 vanlig tekst. Da ville det ha vært mange flere forskjellige bokstaver (og andre tegn).
 Men også i vanlig tekst er det slik at enkelte bokstaver forekommer ofte og andre sjelden eller
 nesten aldri. I norsk tekst er det bokstaven (liten) <i>e</i> som er mest brukt.
 I denne eksempelsekvensen på 100 bokstaver er
 det E som er hyppigst og C som det er færrest av. En tabelloversikt over frekvensen
 til hver bokstav kalles en <i>frekvensfordeling</i>:
</p>

<a name="tabell.5.4.1"></a>
 <table class="sentrert-todimtabell" border="0" cellspacing="0" cellpadding="3">
 <tr class="litenskrift">
 <td>Tegn</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td>
 </tr>
 <tr class="litenskrift">
 <td>Frekvens</td><td>12</td><td>7</td><td>3</td><td>14</td><td>28</td><td>9</td>
 <td>5</td><td>22</td>
 </tr>
 <tr class="litenskrift">
 <td>&nbsp;Binærkode&nbsp;</td><td>01000001</td><td>01000010</td><td>01000011</td><td>01000100</td>
 <td>01000101</td><td>01000110</td><td>01000111</td><td>01001000</td>
 </tr>
 <tr>
 <th colspan="9">Tabell 5.4.1 : En frekvenstabell for 8 tegn</th>
 </tr>
 </table>

<p>
 En vanlig bokstav representeres normalt med en binærkode på 8 biter (en byte). Bokstaven A
 har binærkoden 01000101. Denne bitsekvensen kan også tolkes som tallet 65. Bokstaven B
 er representert ved 01000010 eller tallet 66, osv. Se <i>Tabell</i> 5.4.1.
 For å lagre informasjonen i den gitte sekvensen på 100 bokstaver brukes det en byte
 for hver bokstav, dvs. 100 byter og siden hver byte består av 8 biter, blir det tilsammen
 800 biter. Spørsmålet er nå om det er mulig å lagre denne informasjonen med bruk
 av færre biter enn dette?
</p>

<p>
 Når vi har så få som 8 forskjellige bokstaver kan vi gi hver bokstav en entydig <i>bitkode</i>
 ved hjelp av bare tre binære siffer. De kan kombineres på 8 mulige måter.
 Det er 000, 001, 010, 011, 100, 101, 110 og 111. Da kunne vi bestemme at A
 skal ha bitkoden 000, B bitkoden 001, osv. Dermed vil vi kunne lagre den informasjonen
 som ligger i sekvensen på 100 bokstaver, ved hjelp av bare 300 biter.
 Er 300 biter det beste vi kan oppnå?
</p>


<a name="oppg.5.4.1"></a>
<div>
<a tabindex="-1" href="fasit541.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.1</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>Klikk på navnet <a tabindex="-1" href="http://en.wikipedia.org/wiki/David_A._Huffman">David Huffman</a>
  og les om hans innsats.
 </td></tr>
</table>


<div class="sideskift"></div>

<!-- ////// 5.4.2 /////////////////////// -->

<p><a name="5.4.2" tabindex="2"></a>
<a tabindex="-1" href="#5.4.3"><img class="icon" src="../../images/kvadratx.gif"
 alt="Til Avsnitt 5.4.3 - Huffmans metode"
 title="Til Avsnitt 5.4.3 - Huffmans metode" width="25" height="25" /></a>
<b>&nbsp; 5.4.2 &nbsp;Prefikskoder</b><br/>

 En mulighet er å bruke variabel bitkodelengde, dvs. at de forskjellige
 bokstavene ikke har det samme antallet biter i sin bitkode. Vi komprimerer ved at
 hver bokstav i sekvensen blir erstattet med sin bitkode.
 For å få redusert den sammenlagte størrelsen vil det trolig være lurt å la
 bokstaver som forekommer ofte, få kortest bitkode. Vi kan imidlertid få et problem
 når dette deretter skal tolkes eller dekomprimeres. Hvordan skal vi,
 når det er variabel bitkodelengde,
 kunne vite når bitkoden for en bokstav slutter og bitkoden for neste bokstav starter?
 I eksemplet vårt er det E som er hyppigst.
 Vi kunne gi den bitkoden 0. Den nest hyppigste er H og den kunne vi gi bitkoden 1.
 De fire deretter i hyppighet er D, A, F og B, og de kunne få kodene 00, 01, 10
 og 11. Hvis vi nå komprimerer sekvensen ABAB ved å erstatte hver bokstav med
 dens bitkode, får vi 01110111. Men hvordan skal dette kunne dekomprimeres?
 Første biten er 0. Er det en E eller er det første biten i A?
</p>

<p>
 Vi kan løse dette problemet ved å bruke det som kalles <i>prefikskoder</i>
 (engelsk: <a tabindex="-1" href="http://en.wikipedia.org/wiki/Prefix_code">prefix codes</a>).
 Det betyr at bitkoden for en bokstav <b>ikke</b> kan
 være første delen av bitkoden for en annen bokstav. Med andre ord blir det ikke
 tillatt å la E får bitkoden 0 og A bitkoden 01 fordi bitkoden for E da er første
 del av bitkoden for A.
</p>

<p>
 Vi kan finne prefikskoder for en samling bokstaver ved hjelp av
 et <i>fullt binærtre</i> med nøyaktig like mange bladnoder som det
 er forskjellige bokstaver. Husk definisjonen: Et binærtre er fullt hvis hver node
 enten har to eller ingen barn. Tegnene knyttes til bladnodene. Vi finner bitkoden
 til en bokstav ved å gå veien fra rotnoden ned til bladnoden, dvs. en 0-bit når
 vi går til venstre og en 1-bit når vi går til høyre. Vi kaller et slikt tre
 et <i>prefikskodetre</i>. Nedenfor er det satt opp et mulig prefikskodetre
 for de 8 bokstavene i vårt eksempel:
</p>

<a name="figur.5.4.2.a"></a>
 <table class="mbilde">
   <tr><td><img src="images/542a.png" alt="Et Huffmantre" title="Et Huffmantre"
       width="322" height="248"/></td>
   </tr>
   <tr>
    <td>Figur 5.4.2 a) &nbsp;
    Et fullt tre - 8 bladnoder med en bokstav til hver.</td>
   </tr>
  </table>

<p>
 Ved hjelp av treet i <i>Figur</i> 5.4.2 <i>a)</i> finner vi fort bitkoder for
 de 8 bokstavene. F.eks. går vi fra rotnoden og ned til noden med A
 ved venstre, venstre og venstre. Dermed blir bitkoden til A lik 000.
 <i>Bitkodelengden</i> er antall biter i bitkoden. Vi setter opp dette i en tabell:
</p>

 <a name="tabell.5.4.2.b"></a>
 <table class="sentrert-todimtabell" border="0" cellspacing="0" cellpadding="3">
 <tr class="litenskrift">
 <td>Tegn</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td>
 </tr>
 <tr class="litenskrift">
 <td>Bitkode</td><td>&nbsp;000&nbsp;</td><td>&nbsp;101&nbsp;</td><td>1000</td><td>&nbsp;110&nbsp;</td><td>&nbsp;&nbsp;01&nbsp;&nbsp;</td><td>&nbsp;001&nbsp;</td>
 <td>1001</td><td>&nbsp;111&nbsp;</td>
 </tr>
 <tr class="litenskrift">
 <td>&nbsp;Bitkodelengde&nbsp;</td><td>3</td><td>3</td><td>4</td><td>3</td>
 <td>2</td><td>3</td><td>4</td><td>3</td>
 </tr>
 <tr class="litenskrift">
 <th colspan="9">Tabell 5.4.2 b) : Kodetabell basert på
    binærtreet fra Figur 5.4.2 a)</th>
 </tr>
 </table>

<p>
 Bitkodene i <i>Tabell</i> 5.4.2 <i>b)</i> blir prefikskoder. La X og Y
 være to bokstaver. Hvis bitkoden for Y utgjorde første del av bitkoden for X,
 måtte vi passere Y-noden på veien fra rotnoden ned til X-noden.
 Men det er umulig siden begge hører til bladnoder.
 En sekvens av 0- og 1-biter kan derfor &laquo;dekomprimeres&raquo; på en entydig
 måte ved hjelp av et prefikskodetre. Gitt sekvensen:
</p>

<pre>   10011010001101100111010101</pre>

<p>
 Dekomprimeringen starter i treets rotnode. Derfra til venstre ved 0-bit
 og til høyre ved 1-bit.
 Før eller senere kommer vi til en bladnode. Tegnet i bladnoden noteres. Så vi går opp til
 rotnoden og forsetter. Prefikskodetreet i
 <a tabindex="-1" href="#figur.5.4.2.a"><i>Figur</i> 5.4.2 <i>a)</i></a> gir oss
 resultatet: <code> GBADDEDBE</code>
</p>

<p>
 La <i><i>T</i></i> betegne et prefikskodetre og <i>B</i>&thinsp;(<i>T</i>&thinsp;)
 bitsummen &minus; dvs. antallet biter vi ender opp med når komprimeringen
 skjer ved hjelp av bitkodene som treet gir. <i>B</i>&thinsp;(<i>T</i>&thinsp;) er summen
 av produktet av frekvensen og bitkodelengden for hver bokstav. I vårt eksempel
 med 8 bokstaver og frekvenser som gitt i <a tabindex="-1" href="#tabell.5.4.1"><i>Tabell</i> 5.4.1</a>,
 og der <i>T</i> er treet fra <a tabindex="-1" href="#figur.5.4.2.a"><i>Figur</i> 5.4.2 <i>a)</i></a>,
 blir <i>B</i>&thinsp;(<i>T</i>&thinsp;) slik:
</p>

<pre>   B(T) = 12&middot;3 + 7&middot;3 + 3&middot;4 + 14&middot;3 + 28&middot;2 + 9&middot;3 +5&middot;4 + 22&middot;3  =  280</pre>

<p>
 Resultatet blir at vår sekvens på 100 bokstaver kan komprimeres ned til
 280 biter, dvs. <i>B</i>&thinsp;(<i>T</i>&thinsp;) = 280. Nå er det ikke oppgitt hvordan denne bokstavsekvensen
 ser ut. Men det har heller ingen betydning. Ved prefikskoding er det frekvensen til bokstavene
 som teller.
</p>

<p>
 På slutten av <a tabindex="-1" href="#5.4.1"><i>Avsnitt</i> 5.4.1</a>
 så vi på muligheten av å la hver
 bokstav få en bitkode med lengde 3, og det ble satt opp forslag til
 bitkode for hver bokstav. Da ville sekvensen bli komprimert
 ned til 300 biter. Dette er også prefikskoding. Flg.
 prefikskodetre gir nettopp de bitkodene:
</p>


 <a name="figur.5.4.2.c"></a>
 <table class="mbilde">
   <tr><td><img src="images/542c.png" alt="Et perfekt tre" title="Et perfekt tre"
     width="321" height="199" /></td>
   </tr>
   <tr>
    <td>Figur 5.4.2 c) &nbsp;
    Prefikskodetre - alle får bitkodelengde 3</td>
   </tr>
  </table>

<p>
 <i>B</i>&thinsp;(<i>T</i>&thinsp;)-verdien til treet i <i>Figur</i> 5.4.2 <i>c)</i> er 300.
 Det er dårligere enn <a tabindex="-1" href="#figur.5.4.2.a"><i>Figur</i> 5.4.2 <i>a)</i></a>
 der <i>B</i>&thinsp;(<i>T</i>&thinsp;) = 280. Som
 sagt er det lurt at hyppige bokstaver får en kortere bitkode enn de sjeldne.
 Det er årsaken til at treet i <i>Figur</i> 5.4.2 <i>a)</i> gir den beste prefikskoden
 av de to. Bokstaven <i>E</i> har størst frekvens og i <i>Figur</i> 5.4.2 <i>a)</i> har
 den kortere bitkode enn den har i <i>Figur</i> 5.4.2 <i>c)</i>.
 Spørsmål: Finnes det et <i>optimalt</i> prefikskodetre <i>T</i>, dvs.
 et prefikskodetre som gir minst mulig verdi for <i>B</i>&thinsp;(<i>T</i>&thinsp;)?
 I neste avsnitt skal vi se på en algoritme som gir et optimalt prefikskodetre.
</p>

<a name="oppg.5.4.2"></a>
<div>
<a tabindex="-1" href="fasit542.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.2</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>Tegn prefikskodetreet <i>T</i> som hører til flg. bitkoder: <i>A</i> = 100,
 <i>B</i> = 11110, <i>C</i> = 111110, <i>D</i> = 101, <i>E</i> = 0, <i>F</i> = 1110,
 <i>G</i> = 111111 og <i>H</i> = 110. Det hyppigste tegnet <i>E</i> har fått kortest
 mulig kode. Hva blir bitsummen <i>B</i>&thinsp;(<i>T</i>&thinsp;)?
 Gir det god komprimering?
 </td></tr>
 <tr><td>2.</td>
 <td>Bokstavene i Morse-alfabetet består av prikker og streker. Hvis prikk og strek erstattes
 med 0 og 1, blir dette et system med variabel bitkodelengde. Finn Morse-koden til bokstavene
 fra A til H. Er det i dette systemet mulig å finne f.eks. hva 01110111 betyr?
 </td></tr>
</table>


<div class="sideskift"></div>


<!-- ////// 5.4.3 /////////////////////// -->

<p><a name="5.4.3" tabindex="3"></a>
<a tabindex="-1" href="#5.4.4"><img class="icon" src="../../images/kvadratx.gif"
 alt="Til Avsnitt 5.4.4 - Huffmanskogen og kanoniske trær"
 title="Til Avsnitt 5.4.4 - Huffmanskogen og kanoniske trær" width="25" height="25" /></a>
<b>&nbsp; 5.4.3 &nbsp;Huffmans metode</b><br/>

 Hvis vi regner ut bitsummen <i>B</i>&thinsp;(<i>T</i>&thinsp;) for alle prefikskodetrær,
 må det naturligvis være minst ett av dem som gir minst mulig bitsum.
 Et prefikskodetre <i>T</i> med minimal verdi på <i>B</i>&thinsp;(<i>T</i>&thinsp;)
 kalles et <i>optimalt prefikskodetre</i>.
 <i>Huffmans metode</i> er navnet på den algoritmen som konstruerer et optimalt
 prefikskodetre. Resultatet kalles et <i>Huffmantre</i>.
</p>

<p>
 Det er frekvensfordelingen som er utgangspunktet for algoritmen. Vi bruker det
 samme eksemplet som sist. Se <i>Tabell</i> 5.4.3 <i>a)</i> under:
</p>

 <table class="sentrert-todimtabell" border="0" cellspacing="0" cellpadding="3">
 <tr class="litenskrift">
 <td>Tegn</td><td>&nbsp;&nbsp;A&nbsp;&nbsp;</td><td>&nbsp;&nbsp;B&nbsp;&nbsp;</td>
 <td>&nbsp;&nbsp;C&nbsp;&nbsp;</td><td>&nbsp;&nbsp;D&nbsp;&nbsp;</td>
 <td>&nbsp;&nbsp;E&nbsp;&nbsp;</td><td>&nbsp;&nbsp;F&nbsp;&nbsp;</td>
 <td>&nbsp;&nbsp;G&nbsp;&nbsp;</td><td>&nbsp;&nbsp;H&nbsp;&nbsp;</td>
 </tr>
 <tr class="litenskrift">
 <td>&nbsp;Frekvens&nbsp;</td><td>12</td><td>7</td><td>3</td><td>14</td>
 <td>28</td><td>9</td><td>5</td><td>22</td>
 </tr>
 <tr>
 <th colspan="9">Tabell 5.4.3 a) : Bokstaver og frekvenser</th>
 </tr>
 </table>

<p>
 Huffmantreet består av noder. Hver node skal inneholde en bokstav (generelt et tegn),
 en frekvens (antall forekomster av tegnet) og
 to pekere - til venstre og høyre barn. Med Java-kode kan vi sette det opp slik:
</p>

 <a name="kode.5.4.3.a"></a>
 <pre>  <span class="keyword">class</span> Node
  {
    <span class="keyword">private</span> <span class="keyword">char</span> tegn;        <span class="comment">// et tegn</span>
    <span class="keyword">private</span> <span class="keyword">int</span> frekvens;     <span class="comment">// tegnets frekvens</span>
    <span class="keyword">private</span> Node venstre;     <span class="comment">// peker til venstre barn</span>
    <span class="keyword">private</span> Node høyre;       <span class="comment">// peker til høyre barn</span>
  }
            <b><span class="code"><i>Programkode</i> 5.4.3 <i>a)</i></span></b></pre>

<p>
 Vi starter med å lage én node for hver bokstav og nodene legger vi fortløpende inn i
 en kø som holdes ordnet. Køen ordnes etter <i>frekvens</i>, dvs. at noden med minst frekvens
 kommer først og dermed den med størst frekvens sist. Når dette senere skal
 implementeres er det naturlig å bruke en prioritetskø der frekvensen brukes som prioritet.
 På tegningen nedenfor har vi satt <i>frekvensen</i> inne i noden og <i>bokstaven</i> rett under:
</p>

 <a name="figur.5.4.3.a"></a>
 <table class="mbilde">
   <tr><td><img src="images/543a.png" alt="Noder i en kø" title="Noder i en kø"
    width="321" height="64" /></td>
   </tr>
   <tr>
    <td>Figur 5.4.3 a) : &laquo;Bokstavene&raquo; er lagt i
    en ordnet kø
    </td>
   </tr>
  </table>

<p>
 Vi tar så ut noden med minst frekvens  og så den med nest minst frekvens,
 dvs. først den med frekvens 3 og så den med frekvens 5. Vi lager en ny node der
 frekvensen blir summen (dvs. 3 + 5 = 8) av frekvensene i de to nodene. Den nye noden trenger
 ikke ha noen bokstav (tegn). Den første vi tok ut blir venstre barn og den andre høyre
 barn. Deretter legger vi den nye noden inn på rett plass i den ordnede køen. (Egentlig
 legger vi inn det treet som har noden som rotnode). Resultatet blir slik:
</p>

 <a name="figur.5.4.3.b"></a>
 <table class="mbilde">
   <tr><td><img src="images/543b.png" alt="Noder i en kø" title="Noder i en kø"
    width="281" height="111" /></td>
   </tr>
   <tr><td>
    Figur 5.4.3 b) : C og G er barn til en ny node
    </td>
   </tr>
  </table>

<div class="sideskift"></div>

<p>
 Vi gjentar dette. De to nodene (eller de to trærne) med minst frekvens er den
 med frekvens 7 og den med
 frekvens 8. Disse tar vi ut. Vi lager en ny node med frekvens 7 + 8 = 15. Den første
 vi tok ut blir venstre barn og den andre høyre barn. Den nye noden (eller treet)
 legges inn i køen. På denne måten fortsetter vi til vi står igjen med én node som blir
 treets rotnode.
</p>

 <a name="figur.5.4.3.c"></a>
 <table class="mbilde">
   <tr><td><img src="images/543c.png" alt="Huffmans algoritme" title="Huffmans algoritme"
    width="542" height="164" /></td>
   </tr>
   <tr>
    <td>Figur 5.4.3 c) : Til venstre blir 7 + 8 = 15 ny node. Til høyre blir 9 + 12 = 21 ny node.
    </td>
   </tr>
  </table>

<br/>

 <a name="figur.5.4.3.d"></a>
 <table class="mbilde">
   <tr><td><img src="images/543d.png" alt="Huffmans algoritme" title="Huffmans algoritme"
   width="555" height="222" /></td>
   </tr>
   <tr>
    <td>Figur 5.4.3 d) : Til venstre blir 14 + 15 = 29 og til høyre blir 21 + 22 = 43 nye noder.
    </td>
   </tr>
  </table>

<br/>

 <a name="figur.5.4.3.e"></a>
 <table class="mbilde">
   <tr><td><img src="images/543e.png" alt="Huffmans algoritme" title="Huffmans algoritme"
   width="547" height="329" /></td>
   </tr>
   <tr>
    <td>Figur 5.4.3 e) : Til venstre blir 28 + 29 = 57 ny node. Til slutt blir 43 + 57 = 100 roten i treet.
    </td>
   </tr>
  </table>


<p>
 I <i>Figur</i> 5.4.3 <i>c)</i>, <i>d)</i> og <i>e)</i>  er &laquo;rundene&raquo; i Huffmans algoritme satt opp
 og nederst til høyre i <i>Figur</i> 5.4.3 <i>e)</i> står Huffmantreet.
 Bitkoden til A får vi ved å starte i rotnoden og så venstre, venstre og høyre, dvs.
 001. B får bitkoden 1110, osv. Vi setter alle bitkodene inn i en tabell:
</p>

  <a name="tabell.5.4.3.b"></a>
  <table class="sentrert-todimtabell" border="0" cellspacing="0" cellpadding="3">
  <tr class="litenskrift">
  <td>Tegn</td><td>&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;</td><td>B</td>
  <td>C</td><td>&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;</td>
  <td>&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;</td><td>G</td><td>&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr class="litenskrift">
  <td>Bitkode</td><td>001</td><td>1110</td><td>11110</td><td>110</td><td>10</td><td>000</td>
  <td>11111</td><td>01</td>
  </tr>
  <tr class="litenskrift">
  <td>&nbsp;Bitkodelengde&nbsp;</td><td>3</td><td>4</td><td>5</td><td>3</td>
  <td>2</td><td>3</td><td>5</td><td>2</td>
  </tr>
  <tr class="litenskrift">
  <th colspan="9">Tabell 5.4.3 b) :
   Bitkodetabell basert på treet til høyre i Figur 5.4.3 e)</th>
  </tr>
  </table>

<p>
 Hvor godt vil disse bitkodene komprimere bokstavsekvensen vår? Vi regner ut <i>B</i>&thinsp;(<i>T</i>&thinsp;):
</p>

 <pre>   B(T) = 12&middot;3 + 7&middot;4 + 3&middot;5 + 14&middot;3 + 28&middot;2 + 9&middot;3 +5&middot;5 + 22&middot;2  =  273</pre>

<p>
 Dette gav bedre komprimering enn sist - fra 280 til 273 biter.
 Det kan bevises matematisk (se <a tabindex="-1" href="#5.4.x"><i>Avsnitt</i> 5.4.x</a>) at
 Huffmans algoritme gir et optimalt prefikskodetre. Dvs.
 at det ikke finnes noen andre prefikskodetrær som gir en bedre komprimering, dvs. mindre verdi
 på bitsummen <i>B</i>&thinsp;(<i>T</i>). Men det
 finnes mange andre som gir samme komprimering. Se <a tabindex="-1" href="#oppg.5.4.3"><i>Oppgave</i> 6</a>.
</p>

 <p>
  Oppsummert går Huffmans algoritme slik:
 </p>

<ol>
<li>Gitt at vi kjenner frekvensen (antall forekomster) til hvert av de forskjellige
 tegnene i en &laquo;melding&raquo;. Disse tegnene omtales også som meldingens &laquo;alfabet&raquo;.</li>
<li>Lag en node for hvert av tegnene med tegnets frekvens som nodens frekvens og
 tegnet som nodens tegn.
 Se <a tabindex="-1" href="#figur.5.4.3.a"><i>Figur</i> 5.4.3 <i>a)</i></a>&thinsp;.</li>
<li>Velg først noden som har minst og så den som har nest minst frekvens. Lag en ny
 node der den første blir venstre barn og den andre høyre barn. Frekvensen i den nye noden
 settes til summen av frekvensene til de to som ble valgt ut. Tegnet i den nye noden
 har ikke interesse og kan være hva som helst.</li>
<li>Den nye noden legges sammen med de andre. Det betyr at antallet i samlingen av noder har
 blitt én mindre enn før (to tas ut, en legges inn).
 Se <a tabindex="-1" href="#figur.5.4.3.b"><i>Figur</i> 5.4.3 <i>b)</i></a>&thinsp;.</li>
<li>Gjenta punkt 3. og 4. Se <a tabindex="-1" href="#figur.5.4.3.c"><i>Figur</i> 5.4.3 <i>c)</i></a>
 og <a tabindex="-1" href="#figur.5.4.3.d"><i>Figur</i> 5.4.3 <i>d)</i></a>&thinsp;.</li>
<li>Når det er to noder igjen, vil den nye noden vi lager bli rotnode i Huffmantreet.
Frekvensen i noden blir lik antallet tegn i &laquo;meldingen&raquo;. Se
 <a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>&thinsp;.</li>
<li>Vi finner bitkoden for et tegn ved å starte i rotnoden og gå ned til tegnets node.
 En 0-bit til venstre og en 1-bit til høyre.</li>
</ol>

<p>
 Huffmans algoritme er ikke entydig. Hvis to eller flere
 noder har samme frekvens, kan ikke den minste velges på en entydig måte.
 Det betyr at vi kan få forskjellige Huffmantrær og hvert av dem
 gir et sett med bitkoder. Men alle disse er likeverdige i den forstand at
 de er optimale, dvs. at bitsummen <i>B</i>&thinsp;(<i>T</i>) blir den samme.
 Se <a tabindex="-1" href="#oppg.5.4.3"><i>Oppgave</i> 5</a>.
</p>

<p>
 I et Huffmantre kommer nodefrekvensene i
 <b>avtagende</b> rekkefølge i
 <a tabindex="-1" href="../1/kap51.html#5.1.8"><i>speilvendt nivåorden</i></a>, dvs. i
 nivåvis orden fra roten og nedover og for hvert nivå fra høyre mot venstre.
 Se på Huffmantreet til høyre i
 <a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>&thinsp;. Der kommer de
 slik i speilvendt nivåorden: 100, 57, 43, 29, 28, 22, 21, 15, 14, 12, 9, 8, 7, 5, 3.
 Denne egenskapen karakteriserer et Huffmantre: Et prefikskodetre
 er et Huffmantre hvis og bare hvis 1) nodefrekvensen til hver foreldernode er summen av barnas frekvenser
 og 2) frekvensene kommer i avtagende rekkefølge i speilvendt nivåorden. Dette brukes
 bl.a. i den &laquo;adaptive&raquo; Huffman-teknikken. Hvis en ikke kjenner frekvensfordelingen
 i &laquo;meldingen&raquo; på forhånd, kan Huffmantreet bygges og endres og
 komprimeringen kan gjennomføres fortløpende  mens &laquo;meldingen&raquo; leses. Det betyr at
 hvis frekvensen til et tegn øker, behøver ikke Huffmans algoritme utføres på nytt for å
 finne Huffmantreet. Det holder å endre inne i treet.
 Se <a tabindex="-1" href="#oppg.5.4.3"><i>Oppgave</i> 13</a> og
 <a tabindex="-1" href="#5.4.12"><i>Avsnitt</i> 5.4.12</a>.
</p>


<a name="oppg.5.4.3"></a>
<div>
<a tabindex="-1" href="fasit543.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.3</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>Bruk Huffmans algoritme, finn og tegn Huffmantreet der bokstavene <i>A</i>,
 <i>B</i>, <i>C</i> og <i>D</i> har frekvensene 1, 2, 4 og
 13. Hva blir bitkodene? Komprimer teksten ABBAD. Dekomprimer 1000011000001.
 Hva blir bitsummen <i>B</i>&thinsp;(<i>T</i>)?
 </td></tr>
 <tr><td>2.</td>
 <td>Som i Oppgave 1 med frekvenser 14, 7, 3, 16, 20 og 8 for bokstavene fra
 <i>A</i> til <i>F</i>. Komprimer teksten ABBAD. Dekomprimer 1000011000001.
 Hva blir bitsummen <i>B</i>&thinsp;(<i>T</i>)?
 </td></tr>
 <tr><td>3.</td>
 <td>Som i Oppgave 1 med frekvenser 30, 20, 3, 18, 42, 25 og 10 for bokstavene fra
 <i>A</i> til <i>G</i>. Komprimer teksten ABBAD. Dekomprimer 10000110000011.
 Hva blir bitsummen <i>B</i>&thinsp;(<i>T</i>)?
 </td></tr>
 <tr><td>4.</td>
 <td>Som i Oppgave 1 med frekvenser 17, 6, 3, 21, 25, 10, 5 og 13 for bokstavene fra
 <i>A</i> til <i>H</i>. Komprimer teksten ABBAD. Dekomprimer 10000110000010.
 Hva blir bitsummen <i>B</i>&thinsp;(<i>T</i>)?
 </td></tr>
 <tr><td>5.</td>
 <td>Lag et Huffmantre for fordelingen 1, 1, 2 og 4 for <i>A</i>,
 <i>B</i>, <i>C</i> og <i>D</i>. Da vil det hver gang
 de to nodene med minst frekvens skal velges, være to like å velge mellom. Dermed vil treet
 avhenge av hvilken av dem som tas ut først. Hvor mange forskjellige
 trær vil det bli?
 </td></tr>
 <tr><td>6.</td>
 <td>Lag et Huffmantre for fordelingen 1, 1, 1, 2 og 3 for <i>A</i>,
 <i>B</i>, <i>C</i>, <i>D</i> og <i>E</i>. Her vil de ulike valgene av minst blant flere
 like frekvenser føre til Huffmantrær med ulik form. Dvs. at samme bokstav kan få ulike
 bitkodelengder. Vis at det kan skje.
 </td></tr>
 <tr><td>7.</td>
 <td>Huffmans algoritme gir alltid et optimalt prefikskodetre. Det finnes imidlertid
 mange optimale prefikskodetrær for samme frekvensfordeling. Ta utgangspunkt i
 Huffmantreet til høyre i
 <a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>&thinsp;.
 Sett opp det speilvendte treet, dvs. det treet vi får ved å la de to barna i hver indre node
 node bytte plass. Hvilke bitkoder gir dette treet? Er det optimalt, dvs. har det
 samme bitsum som det opprinnelige treet?
 </td></tr>
 <tr><td>8.</td>
 <td>Hvis Huffmans algoritme omdefineres slik at den noden som tas ut først (har minst frekvens)
 blir høyre barn og den som så tas ut (nest minst frekvens) blir venster barn, kan vi si at
 vi også nå får et Huffmantre. Hvordan vil treet bli hvis vi bruker
 den samme frekvensfordelingen som i starten på
 <a tabindex="-1" href="#5.4.3"><i>Avsnitt</i> 5.4.3</a>. Sammenlign det treet med
 det som diskuteres i <i>Oppgave</i> 7.
 </td></tr>
 <tr><td>9.</td>
 <td>Ta utgangspunkt i treet til høyre i
 <a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>&thinsp;.
 Bytt om noder slik at det blir et tre der nivåene er fylt opp fra venstre, men fortsatt
 med nøyaktig like mange noder på hvert nivå som før. Lag det også slik at bladnoder på
 samme nivå kommer i stigende rekkefølge med hensyn på nodenes tegn. Det gir
 også et optimalt prefikskodetre og kalles et kanonisk tre.
 </td></tr>
 <tr><td>10.</td>
 <td>Finn en frekvensfordeling for de fem bokstavene <i>A</i>, <i>B</i>, <i>C</i>, <i>D</i> og
 <i>E</i> slik at to bokstaver i det tilhørende Huffmantreet får bitkodelengde 4. Prøv å få det til slik at
 summen av frekvensene blir minst mulig.
 Gjør det samme med de seks bokstavene fra <i>A</i> til <i>F</i> og da slik at to bokstaver får bitkodelengde 5.
 Anta at vi har <i>n</i> bokstaver. Finnes det en frekvensfordeling for de <i>n</i> bokstavene slik at
 to bokstaver får bitkodelengde lik <i>n</i> &minus; 1?
 </td></tr>
 <tr><td>11.</td>
 <td>Hvor mange forskjellige tegn må en &laquo;melding&raquo; inneholde og hvor stor må
 &laquo;meldingen&raquo; minst være for at et Huffmantre for
 frekvensfordelingen til &laquo;meldingen&raquo; får et tegn med bitkodelengde på 32?
 </td></tr>
 <tr><td>12.</td>
 <td>Gitt bitkodene <i>A</i> = 11, <i>B</i> = 01, <i>C</i> = 1000, <i>D</i> = 101, <i>E</i> = 00
  og <i>F</i> = 1001. Tegn det tilhørende prefikskodetreet.
  en frekvensfordeling som vil gi nettopp det treet.
 </td></tr>
 <tr><td>13.</td>
 <td>
  Et prefikskodetre er et Huffmantre hvis 1) nodefrekvensen til hver foreldernode er summen
  av barnas frekvenser og 2) frekvensene kommer i avtagende rekkefølge i speilvendt nivåorden
  Hvis frekvensen for et eller flere tegn endrer seg, er det ikke nødvendig å gjennomføre
  Huffmans algoritme på nytt. Det holder å gå inn i treet og gjøre endringene der slik
  1) og 2) blir oppfylt. Ta utgangspunkt i treet i <i>Oppgave</i> 1
  og øk frekvensen til <i>A</i> med 2 (fra 1 til 3). Gjør så de nødvendige endringene i treet.
 </td></tr>
</table>

<div class="sideskift"></div>

<!-- ////// 5.4.4 /////////////////////// -->

<div><a name="5.4.4" tabindex="4"></a>
<a tabindex="-1" href="#5.4.5"><img class="icon" src="../../images/kvadrat.gif"
 alt="Til Avsnitt 5.4.5 - Implementasjon"
 title="Til Avsnitt 5.4.5 - Implementasjon" width="25" height="25" /></a>
<b>&nbsp; 5.4.4 &nbsp;Huffmanskogen og kanoniske trær</b><br/>

En melding komprimeres ved at hvert tegn i meldingen erstattes med tegnets bitkode.
Et problem med dette er at Huffmantreet (eller bitkodene) da må være kjent når den
komprimerte meldingen skal dekomprimeres. En mulighet er å la første del av den
komprimerte meldingen inneholde slik informasjon. Spørsmålet blir da: Hvor mye

 <a name="figur.5.4.4.a"></a>
 <table class="vbilde">
   <tr><td><img src="images/544a.png" alt="Det kanoniske treet" title="Det kanoniske treet"
   width="311" height="301" /></td>
   </tr>
   <tr>
    <td>Figur 5.4.4 a): Venstreorientert kanonisk tre
    </td>
   </tr>
  </table>

informasjon trengs for å gjenskape treet eller bitkodene? Vi kunne bruke
frekvensfordelingen, men den bruker mye plass. Et annet problem med den er at hvis
algoritmen implementeres ved hjelp av en prioritetskø, så vil ulike typer
køer kunne behande like frekvenser ulikt. Det vil kunne gi forskjellige
Huffmantrær.
</div>

<p>
Det er bedre å bruke bitkodene fra et annet optimalt prefikskodetre enn
Huffmantreet. Vi tar utgangspunkt i Huffmantreet og lager et tre
med de samme bladnodene på hvert nivå, men slik at nivåene er
fylt opp fra venstre. I tillegg lar vi tegnene på hvert nivå være sortert
alfabetisk. Ta treet til høyre i
<a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>&thinsp;
som utgangspunkt. Da vil denne teknikken gi oss
treet i <i>Figur</i> 5.4.4 <i>a)</i> til venstre.
</p>

<p>
 Treet i <i>Figur</i> 5.4.4 <i>a)</i> kalles det <i>kanoniske</i> treet. Det er
 et optimalt prefikskodetre siden hvert tegn
 (eller bladnode) har samme avstand til roten som i det opprinnelige Huffmantreet.
</p>

<p class="innrykk40">
<b>Huffmanskogen</b> Alle prefikskodetrær som har de samme tegnene
og for hvert tegn samme avstand til roten som i et Huffmantre <i>T</i>, utgjør <i>Huffmanskogen</i> til <i>T</i>.
</p>

<p class="innrykk40">
<b>Kanonisk tre</b> Det treet <i>K</i> i Huffmanskogen til et Huffmantre <i>T</i> som
 har alle nivåene fylt opp med noder fra venstre og med tegn på samme nivå sortert alfabetisk,
 kalles det (venstreorienterte) <i>kanoniske</i> treet. Hvis <i>X</i> og <i>Y</i> er to tegn
 i <i>K</i>, vil <i>X</i> alltid ligge til venstre for <i>Y</i> hvis <i>X</i> har større avstand
 fra roten enn <i>Y</i> eller hvis de har samme avstand og <i>X</i> kommer foran <i>Y</i>
 alfabetisk.
</p>

<p>
 Generelt vil <i>Huffmanskogen</i> bestå av mange forskjellige prefikskodetrær.
 Vi kan lage dem ved å bytte om på noder på samme nivå. Alle slike trær er optimale og
 bitkodene til hvilket som helst av dem kunne brukes til komprimeringen. Men
 det (venstreorienterte) <i>kanoniske</i> treet har den fordelen at det kan gjenskapes kun ved
 hjelp av lengdene til bitkodene. Bitkodene og bitkodelengdene som treet i
 <a tabindex="-1" href="#figur.5.4.4.a">Figur 5.4.4 a)</a> gir, er:
</p>

  <a name="tabell.5.4.4.a"></a>
  <table class="sentrert-todimtabell" border="0" cellspacing="0" cellpadding="3">
  <tr class="litenskrift">
  <td>Tegn</td><td>&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;</td><td>B</td>
  <td>C</td><td>&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;</td>
  <td>&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;</td><td>G</td><td>&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr class="litenskrift">
  <td>Bitkode</td><td>001</td><td>0001</td><td>00000</td><td>010</td><td>10</td><td>011</td>
  <td>00001</td><td>11</td>
  </tr>
  <tr class="litenskrift">
  <td>&nbsp;Bitkodelengde&nbsp;</td><td>3</td><td>4</td><td>5</td><td>3</td>
  <td>2</td><td>3</td><td>5</td><td>2</td>
  </tr>
  <tr class="litenskrift">
  <th colspan="9">Tabell 5.4.4 a) :
   Bitkodetabell basert på treet i <a tabindex="-1" href="#figur.5.4.4.a"><i>Figur</i> 5.4.4 <i>a)</i></a></th>
  </tr>
  </table>

<p>
 Obs. Det er også mulig å bruke det (høyreorienterte) kanoniske treet, dvs. det treet i Huffmanskogen
 som har alle nivåene fylt opp med noder fra høyre og der tegnene (eller blanodene) på samme nivå
 er sortert alfabetisk. Se <a tabindex="-1" href="#oppg.5.4.4"><i>Oppgave</i> 6</a>.
</p>

<p>
 Påstanden er at det kanoniske treet kan gjenskapes kun ved hjelp av lengdene på bitkodene.
 Hvordan gjør vi det? Ta som eksempel at vi har flg. tegn og bitkodelengder:
</p>

  <a name="tabell.5.4.4.b"></a>
  <table class="sentrert-todimtabell" border="0" cellspacing="0" cellpadding="3">
  <tr class="litenskrift">
  <td>Tegn</td><td>&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;</td>
  <td>&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;</td>
  <td>&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;G&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr class="litenskrift">
  <td>&nbsp;Bitkodelengde&nbsp;</td><td>3</td><td>3</td><td>4</td><td>3</td>
  <td>2</td><td>3</td><td>4</td><td>3</td>
  </tr>
  <tr class="litenskrift">
  <th colspan="9">Tabell 5.4.4 b) : Tegn og bitkodelengder</th>
  </tr>
  </table>

<p>
 Flg. regel gir antallet noder på hvert nivå. Verdiene i <i>Tabell</i> 5.4.4 <i>b)</i> brukes som eksempel:
</p>

<ol>
 <li>La <i>n</i> være størst bitkodelengde. Nivå <i>n</i> blir da nederste nivå.
  I vårt eksempel: <i>n</i> = 4.</li>
 <li>Nederste nivå skal ha noder, i alfabetisk rekkefølge,
  for de tegnene som har lengde <i>n</i>. Antallet slike er alltid et partall.
  I vårt eksempel er det <i>C</i> og <i>G</i>.</li>
 <li>La <i>k</i> &lt; <i>n</i>. På nivå <i>k</i> får vi først foreldrene til de på nivå <i>k</i> + 1.
  Antallet blir halvparten av antallet noder på nivå <i>k</i> + 1. I tillegg kommer
  en node for hvert tegn som har lengde lik <i>k</i>. Antallet vil alltid
  bli et partall. Vårt eksempel: Antall noder på nivå 3 (<i>k</i> = 3) blir 2/1 + 5 = 6
  (2 noder på nivå 4 og 5 tegn med bitkodelengde lik 3).
 </li>
</ol>

<p>
 Vårt eksempel: 1), 2) og 3) gir henholdsvis 2, 6, 4, 2 og 1 noder på
 nivåene 4, 3, 2, 1 og 0. Hvert nivå vil bestå
 av foreldernoder og/eller bladnoder, skal være fylt opp fra venstre og være sortert med hensyn på
 tegnene (bladnodene). Det gir oss flg. kanoniske tre:
</p>

<a name="figur.5.4.4.b"></a>
<table class="mbilde" cellspacing="0" cellpadding="0" border="0">
<tr>
 <td><img src="images/544b.png"  alt="Et kanonisk tre" title="Et kanonisk tre"
   width="318" height="244" /></td>
</tr>
<tr>
 <td>Figur 5.4.4. b) : Kanonisk tre fra Tabell 5.4.4 b)</td>
</tr>
</table>

<p>
 La tabellen <code>lengder</code> inneholde tegnenes bitkodelengder og la <i>n</i>
 være største lengde. Tabellen <code>antall</code> dimensjoneres til <i>n</i> + 1.
 Først går vi gjennom <code>lengder</code> og teller opp hvor mange det er av hver lengde.
 Resultatet havner i tabellen <code>antall</code>. Da vil spesielt <code>antall[n]</code>
 inneholde antallet bladnoder på nederste nivå. Deretter bruker vi fortløpende regel 2
 (i en for-løkke) til å finne det totale antallet noder på de øvrige nivåene:
</p>

<a name="kode.5.4.4.a"></a>
<pre>  <span class="keyword">int</span>[] lengder = {3,3,4,3,2,3,4,3};       <span class="comment">// bitkodelengdene</span>
  <span class="keyword">int</span> n = 4;                               <span class="comment">// største lengde</span>
  <span class="keyword">int</span>[] antall = <span class="keyword">new</span> <span class="keyword">int</span>[n + 1];           <span class="comment">// en tabell for nivåantallet</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> lengde : lengder) antall[lengde]++;  <span class="comment">// antall = {0,0,2,5,2}</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> k = n - 1; k &gt;= 0; k--) antall[k] += antall[k + 1]/2;

  Tabell.skrivln(antall);  <span class="comment">// utskrift: 1 2 4 6 2</span>

              <b><span class="code"><i>Programkode</i> 5.4.4 <i>a)</i></span></b></pre>

<p>
 <i>Programkode</i> 5.4.4 <i>a)</i> gir oss antallet noder som det kanoniske treet skal ha
 på hvert nivå. Da kan treet konstrueres og vi kan finne bitkodene til tegnene. Men det
 er mulig å bruke en teknikk tilsvarende den i <i>Programkode</i> 5.4.4 <i>a)</i> til
 finne bitkodene direkte uten å måtte gå veien om treet. Det tar vi opp i
 <a tabindex="-1" href="#5.4.7"><i>Avsnitt</i> 5.4.7</a>.
</p>

<a name="setning.5.4.4.a"></a>
<p>
 <b>Komprimering</b>: Vi utvider nå Huffmans algoritme for å komprimere
 en &laquo;melding&raquo; til å bestå av følgende skritt:
</p>

<ol>
 <li>Finn tegnene og frekvensfordelingen i &laquo;meldingen&raquo; som skal komprimeres.</li>
 <li>Finn Huffmantreet og så det tilhørende (venstreorienterte) kanoniske treet.</li>
 <li>Sett opp bitkodene som det kanoniske treet gir.</li>
 <li>Den komprimerte meldingen skal bestå av <i>a)</i> informasjon om tegnene og lengdene på
     bitkodene
     og <i>b)</i> av at hvert tegn i &laquo;meldingen&raquo; er erstattet med sin bitkode.</li>
</ol>

<p>
 <b>Dekomprimering</b>: Den komprimerte meldingen behandles i motsatt rekkefølge:
</p>

<ol>
 <li>Hent tegnene og bitkodelengdene.</li>
 <li>Sett opp det (venstreorienterte) kanoniske treet.</li>
 <li>Bitene bestemmer veien fra rotnoden og ned til et tegn (en bladnode).</li>
</ol>


<a name="oppg.5.4.4"></a>
<div>
<a tabindex="-1" href="fasit544.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.4</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>Anta at Huffmans algoritme på grunnlag av en bestemt frekvensfordeling for
 <i>A</i>, <i>B</i>, <i>C</i> og <i>D</i> gav bitkodelengder på henholdsvis 3, 3, 2 og 1.
  Tegn det tilhørende (venstreorienterte) kanoniske treet.
 </td></tr>
 <tr><td>2.</td>
 <td>Som i <i>Oppgave</i> 1, men med <i>A</i>, <i>B</i>, <i>C</i>, <i>D</i> og <i>E</i>
  og lengder på henholdsvis 3, 3, 2, 2 og 2.
 </td></tr>
 <tr><td>3.</td>
 <td>Som i <i>Oppgave</i> 1, men med <i>A</i> &minus; <i>F</i>
  og lengder på henholdsvis 2, 4, 4, 2, 2 og 3.
 </td></tr>
 <tr><td>4.</td>
 <td>Som i <i>Oppgave</i> 1, men med <i>A</i> &minus; <i>G</i>
  og lengder på henholdsvis 2, 3, 4, 3, 2, 3 og 4.
 </td></tr>
 <tr><td>5.</td>
 <td>Som i <i>Oppgave</i> 1, men med <i>A</i> &minus; <i>H</i>
  og lengder på henholdsvis 3, 4, 5, 2, 2, 3, 5 og 3.
 </td></tr>
 <tr><td>6.</td>
 <td>Finn det høyreorienterte kanoniske treet til Huffmantreet til høyre i
 <a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>&thinsp;.
  Dvs. finn treet som har de samme bladnodene som Huffmantreet på hvert nivå og slik at nivåene er
  fylt opp fra <b>høyre</b>. I tillegg skal tegnene (bladnodene) på hvert nivå være sortert
  alfabetisk.
 </td></tr>
 <tr><td>7.</td>
 <td>Finn det høyreorienterte kanoniske treet til treet i
 <a tabindex="-1" href="#figur.5.4.4.b"><i>Figur</i> 5.4.4 <i>b)</i></a>&thinsp;.
 </td></tr>
 <tr><td>8.</td>
 <td>Lag et program der du kjører koden i
  <a tabindex="-1" href="#kode.5.4.4.a"><i>Programkode</i> 5.4.4 <i>a)</i></a>&thinsp;.
  Bytt så ut <code>int n = 4;</code> med en setning der verdien til <i>n</i> finnes
  ved at tabellen <code>lengder</code> gjennomsøkes. Bruk f.eks. maks-metoden som du bør
  ha i samleklassen <i>Tabell</i>.
 </td></tr>
 <tr><td>9.</td>
 <td>Bytt ut vediene i tabellen <code>lengder</code> med 3, 4, 5, 3, 2, 3, 5, 2 i <i>Oppgave</i> 8.
  Det svarer til treet i
  <a tabindex="-1" href="#figur.5.4.4.a"><i>Figur</i> 5.4.4 <i>a)</i></a>&thinsp;.
 </td></tr>
 <tr><td>10.</td>
 <td>Bruk programmet fra <i>Oppgave</i> 8 til å finne antallet noder på hvert nivå for de
  kanoniske trærne i <i>Oppgave</i> 1 - 5.
 </td></tr>
</table>


<div class="sideskift"></div>

<!-- ////// 5.4.5 /////////////////////// -->

<p><a name="5.4.5" tabindex="5"></a>
<a tabindex="-1" href="#5.4.6"><img class="icon" src="../../images/kvadratx.gif"
 alt="Til Avsnitt 5.4.6 - Bitkoder"
 title="Til Avsnitt 5.4.6 - Bitkoder" width="25" height="25" /></a>
<b>&nbsp; 5.4.5 &nbsp;Implementasjon</b><br/>

 <a tabindex="-1" href="#kode.5.4.3.a"><i>Programkode</i> 5.4.3 <i>a)</i></a>
 inneholder et nodeklasseforslag. Det er kun bladnoder som har tegn.
 Derfor oppretter vi isteden en basisklasse <code>Node</code> med frekvens og pekere
 og en subklasse <code>BladNode</code> med tegn. Se også <a tabindex="-1" href="#oppg.5.4.5"><i>Oppgave</i> 3</a>.
 En <code>FrekvensKomparator</code> skal sammenligne noder
 og ordne dem etter frekvens (minst først).
 De blir alle private klasser i <code>class Huffman</code>. Legg
 den under en ny mappe (package) med navn <b>bitio</b> - en samlemappe for bitbehandling.
 </p>

 <a name="kode.5.4.5.a"></a>
 <pre>  <span class="keyword">import</span> java.util.*;
  <span class="keyword">import</span> java.io.*;
  <span class="keyword">import</span> java.net.URL;
  <span class="keyword">import</span> hjelpeklasser.*;

  <span class="keyword">public</span> <span class="keyword">class</span> Huffman                          <span class="comment">// klasse for komprimering</span>
  {
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Node                   <span class="comment">// en basisklasse</span>
    {
      <span class="keyword">private</span> <span class="keyword">int</span> frekvens;                     <span class="comment">// nodens frekvens</span>
      <span class="keyword">private</span> Node venstre;                     <span class="comment">// pekere til venstre barn</span>
      <span class="keyword">private</span> Node høyre;                       <span class="comment">// pekere til høyre barn</span>

      <span class="keyword">private</span> Node() {}                         <span class="comment">// standardkonstruktør</span>

      <span class="keyword">private</span> Node(<span class="keyword">int</span> frekvens, Node v, Node h)   <span class="comment">// konstruktør</span>
      {
        <span class="keyword">this</span>.frekvens = frekvens;
        venstre = v; høyre = h;
      }

    }  <span class="comment">// slutt på class Node</span>

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> BladNode <span class="keyword">extends</span> Node  <span class="comment">// en subklasse</span>
    {
      <span class="keyword">private</span> <span class="keyword">char</span> tegn;                        <span class="comment">// bladnodens tegn</span>

      <span class="keyword">private</span> BladNode(<span class="keyword">char</span> tegn, <span class="keyword">int</span> frekvens)     <span class="comment">// konstruktør</span>
      {
        <span class="keyword">super</span>(frekvens, <span class="keyword">null</span>, <span class="keyword">null</span>);  <span class="comment">// kaller basisklassens konstruktør</span>
        <span class="keyword">this</span>.tegn = tegn;
      }

    }  <span class="comment">// slutt på class BladNode</span>

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> FrekvensKomparator <span class="keyword">implements</span> Comparator&lt;Node&gt;
    {
      <span class="keyword">public</span> <span class="keyword">int</span> compare(Node p, Node q)  <span class="comment">// minst frekvens kommer først</span>
      {
        <span class="keyword">return</span> p.frekvens - q.frekvens;   <span class="comment">// se Oppgave 4</span>
      }
    }

  }  <span class="comment">// slutt på class Huffman</span>

              <b><span class="code"><i>Programkode</i> 5.4.5 <i>a)</i></span></b></pre>

 <p>
 Vi skal her, for enkelhets skyld, kun komprimere &laquo;meldinger&raquo; som inneholder de vanlige
 tegnene, dvs. de fra 0 til 255. En heltallstabell dimensjonert
 til 256 kan derfor inneholde enhver frekvensfordeling. F.eks. får vi frekvensfordelingen
 i <a tabindex="-1" href="#5.4.3"><code><i>Avsnitt</i> 5.4.3</code></a> slik:
</p>

 <pre>  <span class="keyword">int</span>[] frekvens = <span class="keyword">new</span> <span class="keyword">int</span>[256];

  frekvens[<span class="character">'A'</span>] = 12;   frekvens[<span class="character">'E'</span>] = 28;
  frekvens[<span class="character">'B'</span>] =  7;   frekvens[<span class="character">'F'</span>] =  9;
  frekvens[<span class="character">'C'</span>] =  3;   frekvens[<span class="character">'G'</span>] =  5;
  frekvens[<span class="character">'D'</span>] = 14;   frekvens[<span class="character">'H'</span>] = 22;</pre>

<p>
 Flg. metode bygger et tre (ved hjelp av frekvenser)
 slik som beskrevet i <a tabindex="-1" href="#5.4.3"><code><i>Avsnitt</i> 5.4.3</code></a>.
 Det lages en bladnode for hvert tegn i frekvenstabellen (med frekvens > 0)
 og de legges i en ordnet kø (en prioritetskø). De to med minst frekvens (styrt av en komparator) tas ut,
 en ny node med dem som barn og frekvens lik summen av frekvensene, legges i køen, osv.
 Treets rotnode returneres.
 Huffmans algoritme krever at vi har minst to tegn, dvs. minst to av frekvensene
 må være større enn 0. Metoden hører hjemme i
 <a tabindex="-1" href="#kode.5.4.5.a"><code>class Huffman</code></a>:
 </p>


 <a name="kode.5.4.5.b"></a>
 <pre>  <span class="keyword">private</span> <span class="keyword">static</span> Node byggHuffmanTre(<span class="keyword">int</span>[] frekvens)
  {
    Comparator&lt;Node&gt; c = <span class="keyword">new</span> FrekvensKomparator();  <span class="comment">// en komparator</span>
    PrioritetsKø&lt;Node&gt; kø = <span class="keyword">new</span> HeapPrioritetsKø&lt;Node&gt;(c);

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; frekvens.<span class="variable">length</span>; i++)
      <span class="keyword">if</span> (frekvens[i] &gt; 0)          <span class="comment">// dette tegnet skal være med</span>
        kø.leggInn(<span class="keyword">new</span> BladNode((<span class="keyword">char</span>)i, frekvens[i]));

    <span class="keyword">if</span> (kø.antall() &lt; 2)            <span class="comment">// må ha minst to noder</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="character">"Det er for få tegn!"</span>);

    <span class="keyword">while</span> (kø.antall() &gt; 1)
    {
      Node v = kø.taUt();                  <span class="comment">// blir venstre barn</span>
      Node h = kø.taUt();                  <span class="comment">// blir høyre barn</span>
      <span class="keyword">int</span> sum = v.frekvens + h.frekvens;   <span class="comment">// summen av frekvensene</span>

      kø.leggInn(<span class="keyword">new</span> Node(sum, v, h));     <span class="comment">// legger noden inn i køen</span>
    }

    <span class="keyword">return</span> kø.taUt();                      <span class="comment">// roten i treet</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.5 <i>b)</i></span></b></pre>

<br />

<a name="oppg.5.4.5"></a>
<div>
<a tabindex="-1" href="fasit545.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.5</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>Legg klassen Huffman <a tabindex="-1" href="#kode.5.4.5.a"><i>Programkode</i> 5.4.5 <i>a)</i></a>
 under en ny mappe (package) med navn <i>bitio</i>. Legg deretter metoden <i>byggHuffmanTre</i> inn i klassen.
 </td></tr>
 <tr><td>2.</td>
 <td>Bruk isteden en <a tabindex="-1" href="http://java.sun.com/javase/6/docs/api/java/util/PriorityQueue.html"><i>PriorityQueue</i></a>
 fra java.util i <i>byggHuffmanTre</i>. Hva må endres?
 </td></tr>
 <tr><td>3.</td>
 <td>De indre nodene har ikke tegn, mens bladnodene ikke har barn. Nå arver likevel bladnodene to pekere. Vi kunne
 redusere plassbruken ved å ha en basisklasse (node) med frekvens og to subklasser (bladnode og indre node)
 med hhv tegn og to pekere. Gjør dette og gjør så de endringene som trengs der disse klassene brukes.
 </td></tr>
 <tr><td>4.</td>
 <td>
  Frekvenser kan være store. Kan det skape problemer i <code>compare</code> i <code>FrekvensKomparator</code>?
 </td></tr>
</table>


<div class="sideskift"></div>


<!-- ////// 5.4.6 /////////////////////// -->

<p><a name="5.4.6" tabindex="6"></a>
<a tabindex="-1" href="#5.4.7"><img class="icon" src="../../images/kvadratx.gif"
 alt="Til Avsnitt 5.4.7 - Det kanoniske treet og &laquo;ekte&raquo; bitkoder"
 title="Til Avsnitt 5.4.7 - Det kanoniske treet og &laquo;ekte&raquo; bitkoder" width="25" height="25" /></a>
<b>&nbsp; 5.4.6 &nbsp;Bitkoder</b><br/>

 Med frekvenser som i
 &thinsp;<a tabindex="-1" href="#5.4.3"><i>Avsnitt</i> 5.4.3</a>, vil metoden i
 <a tabindex="-1" href="#kode.5.4.5.b"><i>Programkode</i> 5.4.5 <i>b)</i></a>
 bygge opp treet til høyre i
 <a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>.
 Bitkodene til tegnene finner vi ved traversere treet. I flg. metode
 inngår en kodestreng og en kodetabell
 som parametere. Kodestrengen <i>kode</i> utvides med '0'
 til venstre og med '1' til høyre. I en bladnode
 legges <i>kode</i> i kodetabellen:
 </p>

<a name="kode.5.4.6.a"></a>
 <pre>  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> finnBitkoder(Node p, String kode, String[] koder)
  {
    <span class="keyword">if</span> (p <span class="keyword">instanceof</span> BladNode) koder[((BladNode)p).tegn] = kode;
    <span class="keyword">else</span>
    {
      finnBitkoder(p.venstre, kode + <span class="character">'0'</span>, koder);  <span class="comment">// 0 til venstre</span>
      finnBitkoder(p.høyre, kode + <span class="character">'1'</span>, koder);    <span class="comment">// 1 til høyre</span>
    }
  }
              <b><span class="code"><i>Programkode</i> 5.4.6 <i>a)</i></span></b></pre>

 <p>
  Flg. offentlig metode (legges i
  <a tabindex="-1" href="#kode.5.4.5.a"><code>class Huffman</code></a>)
  gir bitkoder som strenger, f.eks. "0101":
 </p>

<a name="kode.5.4.6.b"></a>
 <pre>  <span class="keyword">public</span> <span class="keyword">static</span> String[] stringBitkoder(<span class="keyword">int</span>[] frekvens)
  {
    Node rot = byggHuffmanTre(frekvens);               <span class="comment">// bygger treet</span>

    String[] bitkoder = <span class="keyword">new</span> String[frekvens.<span class="variable">length</span>];   <span class="comment">// en kodetabell</span>
    finnBitkoder(rot,<span class="character">""</span>,bitkoder);                     <span class="comment">// lager bitkodene</span>

    <span class="keyword">return</span> bitkoder;    <span class="comment">// returnerer tabellen</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.6 <i>b)</i></span></b></pre>

<p>
<a name="eksempel.5.4.6.1"></a>
<b>Eksempel 1:</b>
 Hvis metodene er lagt inn i <a tabindex="-1" href="#kode.5.4.5.a"><code>class Huffman</code></a>, vil flg.
 program kunne kjøres:
</p>

<a name="kode.5.4.6.c"></a>
 <pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)
  {
    <span class="keyword">int</span>[] frekvens = <span class="keyword">new</span> <span class="keyword">int</span>[256];

    frekvens[<span class="character">'A'</span>] = 12;   frekvens[<span class="character">'E'</span>] = 28;
    frekvens[<span class="character">'B'</span>] =  7;   frekvens[<span class="character">'F'</span>] =  9;
    frekvens[<span class="character">'C'</span>] =  3;   frekvens[<span class="character">'G'</span>] =  5;
    frekvens[<span class="character">'D'</span>] = 14;   frekvens[<span class="character">'H'</span>] = 22;

    String[] bitkode = Huffman.stringBitkoder(frekvens);

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; frekvens.<span class="variable">length</span>; i++)
      <span class="keyword">if</span> (frekvens[i] &gt; 0)
        System.out.print((<span class="keyword">char</span>)i + <span class="character">" = "</span> + bitkode[i] + <span class="character">" "</span>);

    <span class="comment">// A = 001 B = 1110 C = 11110 D = 110 E = 10 F = 000 G = 11111 H = 01</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.6 <i>c)</i></span></b></pre>

<p>
 Vi kan velge andre tegn, flere tegn og andre frekvenser i <i>Programkode</i> 5.4.6 <i>c)</i>.
 Men hvis vi har en tekst der frekvensfordelingen ikke er kjent, må vi først finne den.
</p>

<p>
 Teksten som skal komprimeres kan f.eks. ligge i en tegnstreng.
 Flg. metode finner  frekvensfordelingen. Metoden hører hjemme i
 <a tabindex="-1" href="#kode.5.4.5.a"><code>class Huffman</code></a>:
</p>

<a name="kode.5.4.6.d"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] stringFrekvens(String tekst)
  {
    <span class="keyword">int</span>[] frekvens = <span class="keyword">new</span> <span class="keyword">int</span>[256];

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; tekst.length(); i++)
      frekvens[tekst.charAt(i)]++;

    <span class="keyword">return</span> frekvens;
  }
              <b><span class="code"><i>Programkode</i> 5.4.6 <i>d)</i></span></b></pre>

<p>
<a name="eksempel.5.4.6.2"></a>
<b>Eksempel 2:</b> Gitt &laquo;Tarzan-skriket&raquo; "aaaaiiiooaaaaaaiiiiiooooaaaaaaaaiiiiiiiooooooh".
Hvor mange biter trengs for å lagre dette ved hjelp av Huffman-teknikken? &laquo;Skriket&raquo;
inneholder kun bokstavene <i>a</i>, <i>i</i>, <i>o</i> og <i>h</i>. Det gir flg.
frekvensfordeling, bitkoder og bitkodelengder:
</p>

<a name="kode.5.4.6.e"></a>
<pre>  String tekst = <span class="character">"aaaaiiiooaaaaaaiiiiiooooaaaaaaaaiiiiiiiooooooh"</span>;

  <span class="keyword">int</span>[] frekvens = Huffman.stringFrekvens(tekst);        <span class="comment">// frekvensene</span>

  String[] bitkoder = Huffman.stringBitkoder(frekvens);  <span class="comment">// bitkodene</span>

  <span class="keyword">int</span> antallBiter = 0;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; frekvens.<span class="variable">length</span>; i++)
    <span class="keyword">if</span> (frekvens[i] &gt; 0)
    {
      antallBiter += frekvens[i] * bitkoder[i].length();
      System.out.print((<span class="keyword">char</span>)i + <span class="character">" = "</span> + bitkoder[i] + <span class="character">"  "</span>);
    }

  System.out.println(<span class="character">"\nKan lagres med "</span> + antallBiter + <span class="character">" biter!"</span>);

  <span class="comment">// Utskrift:</span>
  <span class="comment">// a = 0  h = 100  i = 11  o = 101</span>
  <span class="comment">// Kan lagres med 87 biter!</span>

              <b><span class="code"><i>Programkode</i> 5.4.6 <i>e)</i></span></b></pre>



<p>
 Hvis det er en &laquo;stream&raquo; (f.eks. en tekstfil) som skal komprimeres,
 vil det normalt være
 mange forskjellige tegn. Det er store og små bokstaver, siffer,
 mellomrom, komma, punktum, osv. Der vil det også kunne være
 &laquo;usynlige&raquo; tegn, dvs. kontrolltegn. F.eks. tabulatortegn,
 tegn for linjeskift og sideskift. De første 32 tegnene (0 - 31) i
 <a tabindex="-1" href="http://no.wikipedia.org/wiki/ASCII">ascii-tabellen</a>
 er av den typen. Hvert slikt tegn har fått et navn på to eller tre bokstaver.
 F.eks. står HT for (horisontal) tabulator, LF og CR for linjeskift
 (eng: line feed, carriage return) og FF for sideskift (eng: form feed).
 Dette er satt opp i flg. tabell. Legg den
 i <a tabindex="-1" href="#kode.5.4.5.a"><code>class Huffman</code></a>:
</p>

<a name="kode.5.4.6.f"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> String[] ascii =
  {<span class="character">"NUL"</span>,<span class="character">"SOH"</span>,<span class="character">"STX"</span>,<span class="character">"ETX"</span>,<span class="character">"EOT"</span>,<span class="character">"ENQ"</span>,<span class="character">"ACK"</span>,<span class="character">"BEL"</span>,<span class="character">"BS"</span>,<span class="character">"HT"</span>,<span class="character">"LF"</span>,
   <span class="character">"VT"</span>,<span class="character">"FF"</span>,<span class="character">"CR"</span>,<span class="character">"SO"</span>,<span class="character">"SI"</span>,<span class="character">"DLE"</span>,<span class="character">"DC1"</span>,<span class="character">"DC2"</span>,<span class="character">"DC3"</span>,<span class="character">"DC4"</span>,<span class="character">"NAK"</span>,
   <span class="character">"SYN"</span>,<span class="character">"ETB"</span>,<span class="character">"CAN"</span>,<span class="character">"EM"</span>,<span class="character">"SUB"</span>,<span class="character">"ESC"</span>,<span class="character">"FS"</span>,<span class="character">"GS"</span>,<span class="character">"RS"</span>,<span class="character">"US"</span>};

              <b><span class="code"><i>Programkode</i> 5.4.6 <i>f)</i></span></b></pre>

<p>
 Følgende metode (som hører hjemme i
 <a tabindex="-1" href="#kode.5.4.5.a"><code>class Huffman</code></a>)
 finner frekvensfordelingen i det som en &laquo;stream&raquo;
 inneholder:
</p>

<a name="kode.5.4.6.g"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] streamFrekvens(InputStream inn) <span class="keyword">throws</span> IOException
  {
    <span class="keyword">int</span>[] frekvens = <span class="keyword">new</span> <span class="keyword">int</span>[256];

    <span class="keyword">int</span> tegn = 0;
    <span class="keyword">while</span> ((tegn = inn.read()) != -1) frekvens[tegn]++;
    inn.close();

    <span class="keyword">return</span> frekvens;
  }
              <b><span class="code"><i>Programkode</i> 5.4.6 <i>g)</i></span></b></pre>


<p>
 <a name="eksempel.5.4.6.3"></a>
 <b>Eksempel 3:</b> En fil kan oppgis ved en url (uniform resource locator).
 For en lokal fil (på egen maskin) har den en spesiell form. Anta at filen
 <code><span class="error"><b>c:\algdat\hjelpeklasser\Tabell.java</b></span></code> finnes. Da har den
 <code><span class="error"><b>file:///c:/algdat/hjelpeklasser/Tabell.java</b></span></code>
 som url. Legg merke til at den starter med <code><span class="error"><b>file:///</b></span></code>
 og bruker vanlige skråstreker (/) alle steder.
 I flg. eksempel inngår et av delkapitlene fra det nettbaserte kompendiet og da brukes vanlig url:
</p>

<a name="kode.5.4.6.h"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> IOException
  {
    String url = <span class="character">"http://www.iu.hio.no/~ulfu/appolonius/kap1/3/kap13.html"</span>;
    InputStream inn =
      <span class="keyword">new</span> BufferedInputStream((<span class="keyword">new</span> URL(url)).openStream());

    <span class="keyword">int</span>[] frekvens = Huffman.streamFrekvens(inn);
    String[] bitkoder = Huffman.stringBitkoder(frekvens);

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; bitkoder.<span class="variable">length</span>; i++)
      <span class="keyword">if</span> (bitkoder[i] != <span class="keyword">null</span>)
      {
        String ut = (i &lt; 32) ? Huffman.ascii[i] : <span class="character">""</span> + (<span class="keyword">char</span>)i;
        System.out.printf(<span class="character">"%-3s =  %s %d\n"</span>,ut,bitkoder[i],frekvens[i]);
      }
        <span class="comment">// Utskrift: De 10 første linjene:</span>
        <span class="comment">// LF  =  110101 6288</span>
        <span class="comment">// CR  =  110100 6288</span>
        <span class="comment">//     =  101 44127</span>
        <span class="comment">// !   =  1101101100001 47</span>
        <span class="comment">// "   =  100110 5812</span>
        <span class="comment">// #   =  1000101001 333</span>
        <span class="comment">// %   =  110110110000000 6</span>
        <span class="comment">// &amp;   =  10001011 1351</span>
        <span class="comment">// '   =  0100100011100 28</span>
        <span class="comment">// (   =  01001100 1005</span>

  }  <span class="comment">// slutt på main</span>

              <b><span class="code"><i>Programkode</i> 5.4.6 <i>h)</i></span></b></pre>

<p>
 Utskriften over viser viser at filen inneholder hvert av tegnene LF og CR 6288 ganger.
 Når vi skriver et tekstdokument i et Windows-system og trykker <i>Enter</i>
 for å skifte linje, avsettes de to tegnene CR og LF. Med andre ord er det 6288 linjer
 på filen som inneholder
 <a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a> fra
 kompendiet. Men det er tegnet <i>mellomrom</i> (eng: space) som brukes overlegent
 flest ganger, dvs. 44127 ganger. Dette tegnet bruker som alle de andre tegnene, åtte biter.
 Men med denne komprimeringsteknikken vil det bli erstattet med 101, dvs. kun tre biter.
</p>

<p>
 <a name="eksempel.5.4.6.2"></a>
 <b>Eksempel 4:</b> I <a tabindex="-1" href="#kode.5.4.6.d"><i>Programkode</i> 5.4.6 <i>d)</i></a>
 ble det laget en metode som fant frekvensfordelingen i en tegnstreng og
 i <a tabindex="-1" href="#kode.5.4.6.g"><i>Programkode</i> 5.4.6 <i>g)</i></a> en som
 fant den for en <i>InputStream</i>. Egentlig kunne vi ha nøyd oss med den siste siden
 den også kan (implisitt) brukes for en tegnstreng:
</p>

<a name="kode.5.4.6.i"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> IOException
  {
    String s = <span class="character">"ABBCCCDDDDDEEEEEEEEFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGG"</span>;
    InputStream inn = <span class="keyword">new</span> ByteArrayInputStream(s.getBytes());

    String[] bitkoder =
      Huffman.stringBitkoder(Huffman.streamFrekvens(inn));

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; bitkoder.<span class="variable">length</span>; i++)
    <span class="keyword">if</span> (bitkoder[i] != <span class="keyword">null</span>)
        System.out.print((<span class="keyword">char</span>)i + <span class="character">" = "</span> + bitkoder[i] + <span class="character">"  "</span>);

    <span class="comment">// A = 111110 B = 111111 C = 11110 D = 1110 E = 110 F = 10 G = 0</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.6 <i>i)</i></span></b></pre>

<a name="oppg.5.4.6"></a>
<div>
<a tabindex="-1" href="fasit546.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.6</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>På filen <a tabindex="-1" href="Huffman.html"><code>Huffman</code></a> ligger klassen
 <i>Huffman</i> med alle de metodene m.m. som er laget til nå. Legg den over til deg
 under en mappe (package) med navn <i>bitio</i>. Da må du ha med <code>import bitio.*;</code>
 øverst på de stedene der klassen skal brukes.
 </td></tr>
 <tr><td>2.</td>
 <td>Kjør
  programmet i <a tabindex="-1" href="#eksempel.5.4.6.1"><i>Eksempel</i> 1</a>.
  Gjenta det med andre frekvenser.
 </td></tr>
 <tr><td>3.</td>
 <td>Lag et program som kjører
  koden i <a tabindex="-1" href="#eksempel.5.4.6.2"><i>Eksempel</i> 2</a>.
  Gjenta det med andre tegnstrenger. F.eks. en tekstreng på lengde 100
  med 12 A-er, 7 B-er, osv. slik som i
  <a tabindex="-1" href="#tabell.5.4.1"><i>Tabell</i> 5.4.1</a>.
 </td></tr>
 <tr><td>4.</td>
 <td>Kjør
  programmet i <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a>. Legg inn kode
  slik at antallet forskjellige tegn på filen skrives ut (med en passende tekst) til slutt.
  Hvilke 10 tegn er det som brukes mest? Gjenta dette med pdf-versjonen av <i>Delkapittel</i> 1.3
  (dvs. bytt ut kap13.html med kap13.pdf i url-en). Hvor mange forskjellige tegn inneholder den?
  Hvorfor? Gjenta dette med andre filer. Hvis du velger en lokal fil (på din egen maskin), må du
  passe på at url-en oppgis på rett form. Se den innledende teksten til
  <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a>.
 </td></tr>
 <tr><td>5.</td>
 <td>Komprimeringsgraden i prosent er 100 ganger forholdet mellom reduksjonen
 (differensen mellom original filstørrelse og det den komprimeres til)
 og original filstørrelse. Det betyr f.eks. at hvis komprimeringsgraden er 0%,
 så er de to like. Målet er å få høy komprimeringsgrad. Den kan imidlertid ikke
 bli 100%. I så fall måtte den komprimeres til 0 biter og det er selvfølgelig umulig.
 Gjør om koden
 <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a> slik at den
 finner original filstørrelse. Det er bare å summere alle frekvensene i
 frekvenstabellen. Finn så hvor mange biter dette komprimeres til, dvs. finn
 summen av frekvensen ganget med bitkodelengden for hvert tegn. Se
 <a tabindex="-1" href="#eksempel.5.4.6.2"><i>Eksempel</i> 2</a>. Obs: Dette må
 deles med 8 for å finne antallet byter. Lag det så slik at komprimeringsgraden
 skrives ut.
 </td></tr>
 <tr><td>6.</td>
 <td>
  Prøv koden fra <i>Oppgave</i> 5 på flere tekstfiler. Det heter at med
  Huffman-teknikken blir komprimeringsgraden
  for tekstfiler på 30-40%. Stemmer det for deg? Prøv med filer som kun inneholder
  Java-kode. Blir slike filer komprimert bedre (høyere komprimeringsgrad)
  enn tekstfiler. Prøv også word- og pdf-filer. Hva blir komprimeringsgraden?
 </td></tr>
  <tr><td>7.</td>
  <td>
   I <a tabindex="-1" href="#5.4.3"><i>Avsnitt</i> 5.4.3</a> gav Huffmans algoritme
   bitodene i <a tabindex="-1" href="#tabell.5.4.3.b"><i>Tabell</i> 5.4.3 <i>b)</i></a>.
   Bokstavene <i>C</i> og <i>G</i> fikk de lengste bitkodene, dvs. 5 biter. Hva er
   den lengste bitkoden Huffmans algoritme kan gi hvis &laquo;meldingen&raquo; kun
   inneholder de åtte bokstavene fra <i>A</i> til <i>H</i>&thinsp;?
   Finn en frekvensfordeling som gjør at to bokstaver får denne lengste bitkoden.
   Se <i>Oppgave</i> 10 i <a tabindex="-1" href="#oppg.5.4.3"><i>Avsnitt</i> 5.4.3</a>.
   Test svaret ditt ved å bruke koden i <a tabindex="-1" href="#eksempel.5.4.6.1"><i>Eksempel</i> 1</a>.
 </td></tr>

</table>

<div class="sideskift"></div>

<!-- ////// 5.4.7 /////////////////////// -->

<p><a name="5.4.7" tabindex="7"></a>
<a tabindex="-1" href="#5.4.8"><img class="icon" src="../../images/kvadrat.gif"
 alt="Til Avsnitt 5.4.8 - Komprimering"
 title="Til Avsnitt 5.4.8 - Komprimering" width="25" height="25" /></a>
<b>&nbsp; 5.4.7 &nbsp;Det kanoniske treet og &laquo;ekte&raquo; bitkoder</b><br/>

 I <i>Avsnitt</i> 5.4.4 ble det satt opp <a tabindex="-1" href="#setning.5.4.4.a">fire punkter</a>
 for å utføre en komprimering. Etter Huffmantreet er oppgaven å finne det kanoniske treet.
 Da trengs kun bitkodelengdene. De kan finnes f.eks. ved metoden <i>finnBitkoder</i>
 i <a tabindex="-1" href="#kode.5.4.6.a"><i>Programkode</i> 5.4.6 <i>a)</i></a>.
 Bitkodene blir da tegnstrenger og deres lengder blir bitkodelengder. Men det er bedre å ha
 en direkte metode der lengdene blir verdier i en heltallstabell. Det kan gjøres
 ved en rekursiv traversering. For hvert nivå nedover (forelder til barn) blir
 avstanden til roten én mer enn før. I en bladnode vil &laquo;lengden&raquo;
 til tegnet bli det samme som avstanden til roten. Metoden kalles med lengde lik 0:
</p>

<a name="kode.5.4.7.a"></a>
<pre>  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> finnLengder(Node p, <span class="keyword">int</span> lengde, <span class="keyword">int</span>[] lengder)
  {
    <span class="keyword">if</span> (p.venstre == <span class="keyword">null</span>)                          <span class="comment">// p er en bladnode</span>
    {
      lengder[((BladNode)p).tegn]  = lengde;        <span class="comment">// tegnets lengde</span>
    }
    <span class="keyword">else</span>
    {
      finnLengder(p.venstre, lengde + 1, lengder);  <span class="comment">// lengde øker med 1</span>
      finnLengder(p.høyre, lengde + 1, lengder);    <span class="comment">// lengde øker med 1</span>
    }
  }
              <b><span class="code"><i>Programkode</i> 5.4.7 <i>a)</i></span></b></pre>

<p>
 Det kanoniske treet kan lages ved hjelp av bitkodelengdene &minus; se
 <a tabindex="-1" href="#5.4.4"><i>Avsnitt</i> 5.4.4</a>. Men det er egentlig bitkodene vi er på jakt etter
 og de kan vi faktisk finne uten å konstruere treet først. Vi bruker samme eksempel som i siste del av
 <a tabindex="-1" href="#5.4.4"><i>Avsnitt</i> 5.4.4</a>:
</p>

  <a name="tabell.5.4.7.a"></a>
  <table class="sentrert-todimtabell" border="0" cellspacing="0" cellpadding="3">
  <tr class="litenskrift">
  <td>Tegn</td><td>&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;</td>
  <td>&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;</td>
  <td>&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;G&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;</td>
  </tr>
  <tr class="litenskrift">
  <td>&nbsp;Bitkodelengde&nbsp;</td><td>3</td><td>3</td><td>4</td><td>3</td>
  <td>2</td><td>3</td><td>4</td><td>3</td>
  </tr>
  <tr class="litenskrift">
  <th colspan="9">Tabell 5.4.7 a) : Tegn og bitkodelengder</th>
  </tr>
  </table>

<p>
 Bitkodelengdene i <i>Tabell</i> 5.4.7 <i>a)</i> gir flg. (venstreorienterte) kanoniske tre:
</p>


<a name="figur.5.4.7.a"></a>
<table class="mbilde" cellspacing="0" cellpadding="0" border="0">
<tr>
 <td><img src="images/547a.png"  alt="Et kanonisk tre" title="Et kanonisk tre"
   width="318" height="240" /></td>
</tr>
<tr>
 <td>Figur 5.4.7. a) : Kanonisk tre fra Tabell 5.4.7 a)</td>
</tr>
</table>

<p>
 I hver node i treet <i>Figur</i> 5.4.7 <i>a)</i> står nodens posisjon &minus;
 se <a tabindex="-1" href="../1/kap51.html#5.1.3"><i>Avsnitt</i> 5.1.3</a>.
 Husk sammen-hengen mellom nodeposisjon og bitkode: Bitkoden er lik de binære sifrene
 til posisjonen bortsett fra den første 1-eren. I <i>Figur</i> 5.4.7 <i>a)</i> har f.eks.
 <i>A</i> posisjon 9. Binært er det 1001. Tar vi vekk den første 1-eren får vi 001 og
 det er bitkoden til <i>A</i>.
</p>

<p>
 Bitkodelengdene fra
 <a tabindex="-1" href="#tabell.5.4.7.a"><i>Tabell</i> 5.4.7 <i>a)</i></a> overfører
 vi til flg. heltallstabell:
</p>

<pre>  <span class="keyword">int</span>[] lengder = {3,3,4,3,2,3,4,3};</pre>

<p>
 Vi skal nå punktvis gå gjennom teknikken for å lage bitkoder ved hjelp av tabellen <code>lengder</code>.
</p>

<p>
 1. Vi må først finne den største bitkodelengden. La det være <i>n</i>. I eksemplet vårt er <i>n</i> = 4.
 Her antas at <i>maks</i>-metoden fra
 <a tabindex="-1" href="../../kap1/1/kap11.html"><i>Delkapittel</i> 1.1</a>
 ligger i samleklassen <code>Tabell</code>:
</p>

<pre>  <span class="keyword">int</span> n = lengder[Tabell.maks(lengder)];  <span class="comment">// metoden maks fra klassen Tabell</span></pre>

<p>
 2. Treet i <a tabindex="-1" href="#figur.5.4.7.a"><i>Figur</i> 5.4.7 <i>a)</i></a>
 forteller oss hvor mange bladnoder (eller tegn) det er på hvert nivå. Dette antallet kan vi
 finne ved å gå gjennom tabellen <code>lengder</code> og telle opp siden nivå i treet svarer
 til bitkodelengde:
</p>

<pre>  <span class="keyword">int</span>[] blader = <span class="keyword">new</span> <span class="keyword">int</span>[n + 1];         <span class="comment">// antall bladnoder på hvert nivå</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> lengde : lengder)             <span class="comment">// for alle lengde i lengder</span>
    <span class="keyword">if</span> (lengde &gt; 0) blader[lengde]++;    <span class="comment">// teller opp</span>

  Tabell.skrivln(blader);  <span class="comment">// Utskrift: 0 0 1 5 2</span></pre>

<p>
 3. Posisjonen til første tegn (alfabetisk rekkefølge) blant de med bitkodelengde
 <i>n</i>, er 1 &lt;&lt; <i>n</i> (dvs. 2 opphøyd i <i>n</i>).
 I <a tabindex="-1" href="#figur.5.4.7.a"><i>Figur</i> 5.4.7 <i>a)</i></a> er det <i>C</i>
 og som vi ser er posisjonen 1 &lt;&lt; 4 = 16. Hvis <code>pos[k]</code> er posisjonen
 til den første bladnoden på nivå <i>k</i>, vil <code>pos[k]&thinsp;+&thinsp;&thinsp;blader[k]</code>
 være én mer enn posisjonen til den siste bladnoden på nivå <i>k</i> siden <code>blader[k]</code>
 er antall bladnoder. Spesielt er posisjonen til første bladnode på nivå <i>k</i> &minus; 1
 lik <code>(pos[k]&thinsp;+&thinsp;&thinsp;blader[k])&thinsp;/&thinsp;2</code>.
 I <a tabindex="-1" href="#figur.5.4.7.a"><i>Figur</i> 5.4.7 <i>a)</i></a>
 er 16 posisjonen til den første på nivå 4. Da stemmer det fint at posisjonen
 til første bladnode på nivå 3 er lik (16 + 2)/2 = 9 og at første på nivå 2
 er lik (9 + 5)/2 = 7.
</p>

<pre>  <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[n + 1];              <span class="comment">// en posisjonstabell</span>
  pos[n] = 1 &lt;&lt; n;                         <span class="comment">// betyr 2 opphøyd i n</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt; 0; k--)
    pos[k - 1] = (pos[k] + blader[k])/2;   <span class="comment">// første bladnode på nivå k - 1</span>

  Tabell.skrivln(pos);  <span class="comment">// Utskrift: 2 4 7 9 16</span></pre>

<p>
 4. Vi kjenner nå posisjonen til første
 bladnode (eller tegn) på hvert nivå. På et og samme nivå ligger de andre i alfabetisk
 rekkefølge og deres posisjoner får vi ved å starte med posisjonen til den første og
 forløpende øke den med 1:
</p>

<pre>  <span class="keyword">int</span>[] posisjoner = <span class="keyword">new</span> <span class="keyword">int</span>[lengder.<span class="variable">length</span>];  <span class="comment">// en posisjonstabell</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; posisjoner.<span class="variable">length</span>; i++)
    <span class="keyword">if</span> (lengder[i] &gt; 0) posisjoner[i] = pos[lengder[i]]++;

  <span class="keyword">for</span> (<span class="keyword">int</span> p : posisjoner) <span class="keyword">if</span> (p &gt; 0) System.out.print(p + <span class="character">" "</span>);

  <span class="comment">// Utskrift: 9 10 16 11 7 12 17 13</span></pre>

<p>
 5. Forskjellen mellom bitkoden og posisjonen til en bladnode (et tegn) er at
 posisjonen har en ekstra 1-bit foran. Denne trenger vi egentlig ikke siden
 tabellen <code>lengder</code>  forteller hvor mange biter som er aktuelle.
 Dette tar vi hensyn til i flg metode. Der setter vi alle ideene sammen til en helhet.
 Metoden forventer at ingen bitkodelengde er større enn 31. Hvorfor akkurat
 31 diskuteres senere:
</p>

<a name="kode.5.4.7.b"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] finnBitkoder(<span class="keyword">int</span>[] lengder)
  {
    <span class="keyword">int</span>[] blader = <span class="keyword">new</span> <span class="keyword">int</span>[32];  <span class="comment">// antall tegn av hver lengde</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> lengde : lengder)
      <span class="keyword">if</span> (lengde &lt; 32) blader[lengde]++;    <span class="comment">// teller opp</span>
      <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="character">"Bitkodelengde > 31!"</span>);

    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[32];  <span class="comment">// posisjonen til første bladnode</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> k = 31; k &gt; 0; k--) pos[k - 1] = (pos[k] + blader[k])/2;

    <span class="keyword">int</span>[] bitkoder = <span class="keyword">new</span> <span class="keyword">int</span>[lengder.<span class="variable">length</span>];

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; bitkoder.<span class="variable">length</span>; i++)
      <span class="keyword">if</span> (lengder[i] &gt; 0) bitkoder[i] = pos[lengder[i]]++;

    <span class="keyword">return</span> bitkoder;
  }
              <b><span class="code"><i>Programkode</i> 5.4.7 <i>b)</i></span></b></pre>

<p>
 Hvis metoden <code>finnBitkoder</code> er lagt inn i klassen <code>Huffman</code>,
 vil flg. kodebit kunne kjøres:
</p>

<a name="kode.5.4.7.c"></a>
<pre>  <span class="keyword">int</span>[] lengder = {3,3,4,3,2,3,4,3};

  <span class="keyword">int</span>[] bitkoder = Huffman.finnBitkoder(lengder);

  Tabell.skrivln(bitkoder);  <span class="comment">// Utskrift: 1 2 0 3 3 4 1 5</span>

              <b><span class="code"><i>Programkode</i> 5.4.7 <i>c)</i></span></b></pre>

<p>
 Kodebiten over gir 1 2 0 3 3 4 1 5 som utskrift for bitkodene. Kan det stemme? Husk at en bitkode
 nå er et bestemt antall biter bakerst i et heltall. Hvis vi setter på en ekstre 1-bit
 foran de aktuelle bitene, blir resulatet det samme som posisjonen i treet. Hvis et
 heltall <i>k</i> slutter med f.eks. 0001, setter vi en 1-bit foran ved <i>k</i> | 1 &lt;&lt; 4.
 Tar vi med flg. ekstra utskriftssetning i <i>Programkode</i> 5.4.7 <i>c)</i>,
 vil vi imidlertid få det resultatet som forventes:
</p>

<a name="kode.5.4.7.d"></a>
<pre>  <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; lengder.<span class="variable">length</span>; i++)
    System.out.print((bitkoder[i] | 1 &lt;&lt; lengder[i]) + <span class="character">" "</span>);

  <span class="comment">// Utskrift: 9 10 16 11 7 12 17 13</span></pre>

<a name="oppg.5.4.7"></a>
<div>
<a tabindex="-1" href="fasit547.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.7</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>Legg metoden <i>finnBitkoder</i> i <a tabindex="-1" href="#kode.5.4.7.b"><i>Programkode</i> 5.4.7 <i>b)</i></a>
 inn i klassen <code>Huffman</code>.
 </td></tr>
 <tr><td>2.</td>
 <td>Bitlengdene 3, 4, 5, 3, 2, 3, 5, 2 førte til treet i
  <a tabindex="-1" href="#figur.5.4.4.a"><i>Figur</i> 5.4.4 <i>a)</i></a>. Kjør
  <i>Programkode</i> 5.4.7 <i>c)</i> (ta med den ekstra utskriftssetningen
  satt opp lenger ned) med disse bitlengdene og sjekk at resultatene stemmer med treet.
 </td></tr>
 <tr><td>3.</td>
 <td>Gitt (se <i>Oppgave</i> 5 i <a tabindex="-1" href="#oppg.5.4.4"><i>Avsnitt</i> 5.4.4</a>&thinsp;)
  3, 4, 5, 2, 2, 3, 5, 3. Gjør som i <i>Oppgave</i> 1.
 </td></tr>
 <tr><td>4.</td>
 <td>La 3, 3, 5, 3, 2, 4, 4, 3, 4, 5 være bitkodelngder for bokstavene fra <i>A</i> til <i>J</i>.
 Tegn det tilhørende (venstreorienterte) kanoniske treet og gjør så som i <i>Oppgave</i> 1.
 </td></tr>
 <tr><td>5.</td>
 <td>Lag en metode tilsvarende den i
  <a tabindex="-1" href="#kode.4.5.7.b"><i>Programkode</i> 4.5.7 <i>b)</i></a>, men der vi får
  bitkodene som hører til det høyreorienterte kanoniske treet. Sjekk resultatet ved f.eks. å
  tegne treet for bitkodelengdene 3, 3, 4, 3, 2, 3, 4, 3 og så bruke den metoden i
  <i>Programkode</i> 5.4.7 <i>c)</i>.
 </td></tr>
</table>




<div class="sideskift"></div>

<!-- ////// 5.4.8 /////////////////////// -->

<p><a name="5.4.8" tabindex="8"></a>
<a tabindex="-1" href="#5.4.9"><img class="icon" src="../../images/kvadrat.gif"
 alt="Til Avsnitt 5.4.9 - Enkel dekomprimering"
 title="Til Avsnitt 5.4.9 - Enkel dekomprimering" width="25" height="25" /></a>
<b>&nbsp; 5.4.8 &nbsp;Komprimering</b><br/>

 En &laquo;melding&raquo; komprimeres ved at hvert tegn erstattes med tilhørende bitkode.
 Dette skaper et problem siden bitkodene kan ha forskjellige lengder. F.eks. kan de to første
 tegnene ha bitkodelengder på 5 og 7. Men minste enhet for lagring (eller utskrift)
 er en byte (8 biter). Derfor må bitkodene &laquo;skjøtes sammen&raquo;. Så fort vi har fått
 8 biter lagres de (eller skrives ut) som én enhet (en byte). Klassen
 <a tabindex="-1" href="../../vedlegg/A/BitOutputStream.html"><code>BitOutputStream</code></a>
 har utskriftsmetoder som gjør dette for oss. Kopier klassen over til deg. Legg den under mappen (package)
 <code>bitio</code>.
</p>

<p>
 <a tabindex="-1" href="../../vedlegg/A/A1.html"><i>Vedlegg</i> A1</a>
 inneholder en beskrivelse av metodene i
 <a tabindex="-1" href="../../vedlegg/A/BitOutputStream.html"><code>BitOutputStream</code></a>
 og eksempler på hvordan de brukes. F.eks. skriver en av dem ut et oppgitt antall biter
 fra et heltall:
</p>

<pre>  <span class="keyword">public</span> <span class="keyword">void</span> writeBits(<span class="keyword">int</span> value, <span class="keyword">int</span> numberOfBits)</pre>

<p>
 Flg. enkle metode skal komprimere innholdet i
 <a tabindex="-1" href="http://java.sun.com/javase/6/docs/api/java/io/InputStream.html"><code>InputStream</code></a>
 <code>inn</code> og skrive resultatet til
 <a tabindex="-1" href="http://java.sun.com/javase/6/docs/api/java/io/OutputStream.html"><code>OutputStream</code></a>
 <code>ut</code>.
 Da må følgende punkter utføres: 1) <code>inn</code> leses en gang for å finne
 frekvensfordelingen, 2) Huffmantreet bygges ved hjelp av frekvensfordelingen,
 3) en traversering av treet gir bitkodelengdene,
 4) det kanoniske treet og bitkodene konstrueres ved hjelp av bitkodelengdene og
 5) <code>inn</code> leses en gang til og bitkoden til hvert tegn skrives
 til <code>ut</code>. Legg metoden inn i klassen <code>Huffman</code>:
</p>

<a name="kode.5.4.8.a"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>
  komprimer(InputStream inn, OutputStream ut) <span class="keyword">throws</span> IOException
  {
    <span class="keyword">if</span> (inn.markSupported() == <span class="keyword">false</span>) <span class="keyword">throw</span> <span class="keyword">new</span>
      IllegalStateException(<span class="character">"InputStream kan ikke resettes!"</span>);

    <span class="keyword">int</span>[] frekvens = streamFrekvens(inn);             <span class="comment">// punkt 1</span>

    inn.reset();  <span class="comment">// lesingen kan starte på nytt</span>

    Node rot = byggHuffmanTre(frekvens);              <span class="comment">// punkt 2</span>

    <span class="keyword">int</span>[] lengder = <span class="keyword">new</span> <span class="keyword">int</span>[frekvens.<span class="variable">length</span>];
    finnLengder(rot, 0, lengder);                     <span class="comment">// punkt 3</span>

    <span class="keyword">int</span>[] bitkoder = finnBitkoder(lengder);           <span class="comment">// punkt 4</span>

    BitOutputStream bitUt = <span class="keyword">new</span> BitOutputStream(ut);

    <span class="keyword">int</span> antallBiter = 0, tegn = 0;
    <span class="keyword">while</span> ((tegn = inn.read()) != -1)                 <span class="comment">// punkt 5</span>
    {
      bitUt.writeBits(bitkoder[tegn],lengder[tegn]);
      antallBiter += lengder[tegn];                   <span class="comment">// teller opp</span>
    }
    inn.close(); bitUt.close();                       <span class="comment">// lukker</span>

    <span class="keyword">return</span> antallBiter;
  }
              <b><span class="code"><i>Programkode</i> 5.4.8 <i>a)</i></span></b></pre>

<p>
 Komprimeringsmetoden i <i>Programkode</i> 5.4.8 <i>a)</i> vil virke kun for instanser av
 <a tabindex="-1" href="http://java.sun.com/javase/6/docs/api/java/io/InputStream.html"><code>InputStream</code></a>
 som tillater at &laquo;strømmen&raquo; resettes, dvs. tillater
 at lesingen kan starte på nytt fra begynnelsen. Dette gjelder f.eks. for klassen
 <a tabindex="-1" href="http://java.sun.com/javase/6/docs/api/java/io/ByteArrayInputStream.html"><code>ByteArrayInputStream</code></a>
 der lesingen skjer fra en underliggende byte-tabell. Metoden <code>markSupported()</code> returnerer sann
 for denne klassen.
</p>

<a name="eksempel.5.4.8.1"></a>
<p>
<b>Eksempel 1</b> I flg. eksempel skal vi &laquo;komprimere&raquo; meldingen
<span class="character">"Dette er en test!"</span>.
Den har 8 forskjellige og tilsammen 17 tegn (bokstaver, mellomrom og utropstegn). Bokstaven <i>e</i>
forekommer 5 ganger og vil komme til å få en kort bitkode (10), mens f.eks. bokstaven <i>D</i>
forekommer kun én gang og vil dermed få en &laquo;lang&raquo; bitkode (00000).
Se <a tabindex="-1" href="#oppg.5.4.8"><i>Oppgave</i> 2</a>.
</p>

<a name="kode.5.4.8.b"></a>
<pre>  String melding = <span class="character">"Dette er en test!"</span>;
  InputStream inn = <span class="keyword">new</span> ByteArrayInputStream(melding.getBytes());

  ByteArrayOutputStream ut = <span class="keyword">new</span> ByteArrayOutputStream();

  System.out.println(Huffman.komprimer(inn, ut));  <span class="comment">// Utskrift: 46</span>

              <b><span class="code"><i>Programkode</i> 5.4.8 <i>b)</i></span></b></pre>

<p>
 Utskriften fra <i>Programkode</i> 5.4.8 <i>b)</i> forteller at de 17 tegnene i meldingen har
 blitt komprimert ned til 46 biter. Det betyr i gjennomsnitt 2,7 biter per tegn. Men
 hvordan ser den komprimerte meldingen ut? Resultatet ligger i en byte-tabell inne i enheten
 <code>ut</code>. Vi kan hente ut byte-tabellen og oversette innholdet
 til en string der en 0-bit blir til tegnet '0' og en 1-bit til tegnet '1'. Legg flg. kode
 inn på slutten av <i>Programkode</i> 5.4.8 <i>b)</i>:
</p>

<a name="kode.5.4.8.c"></a>
<pre>  String komprimering = BitOutputStream.toBitString(ut.toByteArray());

  System.out.println(komprimering);

  <span class="comment">// Utskrift: 00000101 11110011 00011011 00010011 11000001 11000100</span>

              <b><span class="code"><i>Programkode</i> 5.4.8 <i>c)</i></span></b></pre>

<p>
 Utskriften i <i>Programkode</i> 5.4.8 <i>c)</i> viser bitene i hver byte i byte-tabellen som
 inneholder den komprimerte meldingen. Tilsammen 6&middot;8 = 48 biter.
 Men utskriften i <i>Programkode</i> 5.4.8 <i>b)</i> sa at det var 46 biter og det er korrekt.
 Men 46 biter er for få til å fylle 6 byter. Klassen
 <a tabindex="-1" href="../../vedlegg/A/BitOutputStream.html"><code>BitOutputStream</code></a>
 er laget slik at når en utskrift gjøres ferdig (<code>flush</code> eller <code>close</code>&thinsp;),
 blir det lagt til så mange ekstra 0-biter på slutten at den siste byten blir fylt opp. Det betyr at de
 to siste 0-bitene i den siste byten i utskriften i <i>Programkode</i> 5.4.8 <i>c)</i>, ikke
 hører til den komprimerte meldingen. Dette betyr at ved en eventuell dekomprimering er det viktig
 å vite hvor de egentlige bitene stopper og dermed hvor ekstrabitene starter.
</p>

<p>
<b>Eksempel 2</b> Anta at filen <span class="character">"test.txt"</span> er tilgjengelig. Vi kan forsøke
å &laquo;komprimere&raquo; den:
</p>

<a name="kode.5.4.8.d"></a>
<pre>  InputStream inn = <span class="keyword">new</span> FileInputStream(<span class="character">"test.txt"</span>);

  ByteArrayOutputStream ut = <span class="keyword">new</span> ByteArrayOutputStream();

  System.out.println(Huffman.komprimer(inn, ut));

              <b><span class="code"><i>Programkode</i> 5.4.8 <i>d)</i></span></b></pre>

<p>
 Kjører vi koden over vil det imidlertid bli kastet et unntak av
 typen <code>IllegalStateException</code> med feilmeldingen
 <span class="error">"InputStream kan ikke resettes!"</span>&thinsp;. Hvis en fil skal leses
 på nytt, må vi først avbryte kontakten med filen (<code>close</code>) og så opprette
 en ny kontakt ved hjelp av en konstruktør. Vi må derfor lage en annen metode for komprimering
 av vanlige filer.
</p>


<p>
 Vi gjør som i <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a> i
 <i>Avsnitt</i> 5.4.6 og lar en fil være representert ved sin url. Dermed kan vi åpne
 filen for lesning ved hjelp av flg. kode:
</p>

<pre>  InputStream inn = <span class="keyword">new</span> BufferedInputStream((<span class="keyword">new</span> URL(url)).openStream());</pre>

<p>
 Under dekomprimering må vi kjenne til bitkodene som ble brukt under komprimeringen.
 De kan gjenskapes eksakt hvis vi kjenner tegnene og deres bitkodelengder. Hvert av de 256 tegnene fra
 0 til 255 kan i prinsippet forekomme. I <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a>
 i <i>Avsnitt</i> 5.4.6 ble filen som inneholder
 <a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a> analysert.
 Den inneholdt 95 forskjellige tegn. Det er vanlig å legge informasjon om hvilke tegn som
 forekommer, på begynnelsen av filen som vi komprimerer til. Det leses først
 under en dekomprimering. Et mål er å bruke så liten plass som mulig til dette.
</p>

<p>
 Vi kan f.eks. først skrive ut hvor mange forskjellige tegn det er og så skrive ut de tegnene det
 handler om. Med f.eks. 95 forskjellige tegn vil det da bli 7 biter (tallet 95) + 95&middot;8 =
 767 biter. Et alternativ er å bruke 256 biter (én bit for hvert mulig tegn) med en
 1-bit hvis tegnet er med og en 0-bit hvis det ikke er med. Den siste teknikken er best hvis det
 er mange tegn, mens den første er best hvis det er få tegn. Grensen går ved 32 forskjellige tegn.
 Med 32 tegn vil det bli 32&middot;8 = 256 biter. Det er også andre måter å gjøre det på.
 Se <a tabindex="-1" href="#oppg.5.4.8"><i>Oppgave</i> 4</a>.
</p>

<p>
 Også tegnenes bitkodelengder må skrives ut.
 I <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a> var 19 største lengde.
 For å skrive ut tall fra 1 til 19 holder det med 5 biter. Med 15 som største bitkodelengde hadde det
 holdt med 4 biter, osv. Flg. hjelpemetode
 som legges i klassen <code>Huffman</code>, finner antallet signifikante binære
 siffer i et heltall:
</p>

<a name="kode.5.4.8.e"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> antBinSiffer(<span class="keyword">int</span> k)  <span class="comment">// antall binære siffer</span>
  {
    <span class="keyword">return</span> k == 0 ? 0 : 32 - Integer.numberOfLeadingZeros(k);
  }
              <b><span class="code"><i>Programkode</i> 5.4.8 <i>e)</i></span></b></pre>

<p>
 Det totale antallet biter etter at alle bitkodene er skrevet ut, behøver ikke bli et helt
 antall byter. Hvis ikke legges det på, før utskriftsfilen lukkes, et ekstra antall
 0-biter (fra 1 til 7 stykker). Hvis de tas med under en dekomprimering,
 kan vi risikere å få en større fil enn vi opprinnelig hadde. En enkel måte å løse det på
 kunne være å skrive ut det totale antallet tegn først på filen. Dermed
 kunne vi stoppe når det antallet tegn var dekomprimert.
</p>

<p>
 En mer interessant måte å løse det på er å bruke en &laquo;vaktpost&raquo;. Til det velger vi
 det tegnet (eller et av de tegnene) som har størst bitkodelengde. Bitkoden for vaktposten
 skrives ut helt til slutt. Dermed kan dekomprimeringen stoppe når vi har funnet
 vaktposttegnet rett antall ganger. Vi finner hva som skal være vaktpost ved å finne størst
 lengde i tabellen <i>lengder</i> (ved hjelp av metoden <i>maks</i> fra klassen <i>Tabell</i>&thinsp;).
</p>

<p>
 Frekvensen til vaktposten kan være fra 1 og oppover. Den må skrives et sted på
 starten av den komprimerte filen og helst med så få biter som mulig.
 Antallet biter kan i prinsippet variere fra 1 til 31.
 Alle tall fra 1 til 31 kan skrives med kun fem biter siden 31 = 11111. Dermed
 bruker vi 5 biter til å oppgi hvor mange biter frekvensen har og så skrives
 frekvensen ut med nøyaktig det antallet biter. Vaktpostfrekvensen vil normalt være
 et lite tall, kanskje 1.
 I <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a> i
 <i>Avsnitt</i> 5.4.6 der filen som inneholder
 <a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a> inngår,
 var 19 størst bitkodelengde (&thinsp;' \&thinsp;' og '&thinsp;Ø&thinsp;'&thinsp;) med
 frekvens 1 for de tilhørende tegnene. Dermed
 blir det 5 + 1 + 19 = 25 ekstra biter for dette vaktpostopplegget.
 Vi kunne brukt et annet tegn som vaktpost, men det er fordelaktig å velge et som
 har størst bitkodelengde.
 Se <a tabindex="-1" href="#oppg.5.4.8"><i>Oppgave</i> 5</a>.
</p>

<p>
 Det normale er å la den komprimerte filen starte med et såkalt filhode
 (eng: file header). Filhodet består av et antall biter komponert slik at det
 bl.a. kan brukes til å identifisere filen som en fil komprimert ved hjelp av
 Huffmans metode. Dermed kan en metode for dekomprimering gi en feilmelding
 (kaste et unntak) hvis filen er av feil type. Filhodet kan
 også brukes i forbindelse med spesialtifeller. I flg. komprimeringsmetode bruker
 vi ikke filhode. Utforming og bruk av et filhode tas opp i
 <a tabindex="-1" href="#oppg.5.4.8"><i>Oppgave</i> 2</a> og i andre oppgaver.
</p>


<a name="kode.5.4.8.f"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>
  komprimer(String fraUrl, String tilFil) <span class="keyword">throws</span> IOException
  {
    InputStream inn = <span class="keyword">new</span> BufferedInputStream
      ((<span class="keyword">new</span> URL(fraUrl)).openStream());          <span class="comment">// åpner inn-filen</span>

    <span class="keyword">int</span>[] frekvens = streamFrekvens(inn);        <span class="comment">// frekvenstabellen</span>
    Node rot = byggHuffmanTre(frekvens);         <span class="comment">// bygger Huffmantreet</span>

    <span class="keyword">int</span>[] lengder = <span class="keyword">new</span> <span class="keyword">int</span>[frekvens.<span class="variable">length</span>];
    finnLengder(rot, 0, lengder);                <span class="comment">// bitkodelengdene</span>

    <span class="keyword">int</span>[] bitkoder = finnBitkoder(lengder);      <span class="comment">// bitkodene</span>

    <span class="keyword">int</span> vaktpost = Tabell.maks(lengder);         <span class="comment">// vaktposttegnet</span>
    <span class="keyword">int</span> k = antBinSiffer(lengder[vaktpost]);     <span class="comment">// antall siffer</span>

    BitOutputStream ut =
      <span class="keyword">new</span> BitOutputStream(tilFil);               <span class="comment">// ut-filen</span>

    ut.writeBits(k, 3);                          <span class="comment">// maks antall siffer</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> lengde : lengder)                   <span class="comment">// tegn og lengder</span>
    {
      <span class="keyword">if</span> (lengde == 0) ut.write0Bit();           <span class="comment">// ikke med hvis 0</span>
      <span class="keyword">else</span>
        ut.writeBits(lengde | 1 &lt;&lt; k, k + 1);    <span class="comment">// 1 + lengde</span>
    }

    <span class="keyword">int</span> s = antBinSiffer(frekvens[vaktpost]);    <span class="comment">// antall siffer</span>
    ut.writeBits(s, 5);                          <span class="comment">// skriver ut</span>
    ut.writeBits(frekvens[vaktpost], s);         <span class="comment">// vaktpostens frekvens</span>

    inn = <span class="keyword">new</span> BufferedInputStream
      ((<span class="keyword">new</span> URL(fraUrl)).openStream());          <span class="comment">// åpner på nytt</span>

    <span class="keyword">int</span> tegn = 0;
    <span class="keyword">while</span> ((tegn = inn.read()) != -1)   <span class="comment">// leser ett og ett tegn</span>
    {
      ut.writeBits(bitkoder[tegn], lengder[tegn]);  <span class="comment">// skriver bitkoden</span>
    }

    ut.writeBits(bitkoder[vaktpost], lengder[vaktpost]);  <span class="comment">// vaktposten</span>

    inn.close();     <span class="comment">// lukker inn-filen</span>
    ut.close();      <span class="comment">// lukker ut-filen</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.8 <i>f)</i></span></b></pre>

<p>
 Hvor god er denne komprimeringsteknikken?
 I <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a>
 i <i>Avsnitt</i> 5.4.6 ble filen som inneholder
 <a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a>, analysert.
 Filen er på 330.520 byter. Flg. figur viser hva som blir skrevet på
 utskriftsfilen hvis filen med <a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a>
 komprimeres:
</p>

<a name="figur.5.4.8.a"></a>
<table border="0" cellpadding="0" cellspacing="0"  style="margin-right: auto; margin-left: auto; font-family: Arial; font-size: 11px; text-align: center;">
<tr style="background-color: lightgray;">
 <td style="border-right: solid white 2px;">3</td>
 <td style="border-right: solid white 2px;">731</td>
 <td style="border-right: solid white 2px;">6</td>
 <td style="width: 350px; border-right: solid white 2px;">1.659.544</td>
 <td style="border-right: solid white 2px;">19</td>
</tr>
<tr>
 <td>&nbsp;Siffer&nbsp;</td>
 <td>&nbsp; &nbsp;Bitkodelengder&nbsp; &nbsp;</td>
 <td>&nbsp;&nbsp;Vaktpost&nbsp;&nbsp;</td>
 <td>Komprimeringen</td>
 <td>&nbsp; Vaktpost &nbsp;</td>
</tr>
<tr>
 <td colspan="5">Figur 5.4.8 a) : Bitene på uskriftsfilen</td>
</tr>
</table>

<p>
 Bitkodelengder kan variere fra 1 til 31. Hvis største bitkodelengde er mindre enn
 16, kan vi skrive ut hver av dem 4 binære siffer. Men vi må bruke 5 binære siffer
 hvis noen av dem er 16 eller større. Første utskrift forteller hvor mange binære siffer
 som vi bruker for lengdene. Maks antall er 5 siden ingen bitkodelengde kan være større
 enn 31. For å skrive et tall som er 5 eller mindre trengs kun 3 binære siffer.
 I vårt eksempel er 19 største bitkodelengde (lengden til vaktposten) og dermed må vi bruke 5
 binære siffer for å skrive ut lengdene. Det betyr at variabelen <i>k</i> blir 5 og dermed
 at 101 (= 5) blir de tre første bitene på utskrifsfilen.
</p>

<p>
 Videre har vi 256 biter der
 en 1-bit forteller at tilhørende tegn er med og en 0-bit at det ikke er med.
 I <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a> er det med 95
 tegn av de 256 mulige og for hvert av de 95 tegnene skrives tegnets bitkodelengde med
 5 biter. Tilsammen blir det 256 + 95&middot;5 = 731 biter. Deretter kommer data om vaktposten.
 Normalt vil vaktposten ha liten frekvens, ofte kun 1. Men i teorien kan den være svært
 stor. Hvis vi har en kjempestor fil med bare to forskjellige tegn, vil et av dem bli vaktpost.
 Uansett hvor stor frekvensen til vaktposten er, holder det med 5 biter for å fortelle hvor
 mange biter frekvensen kan skrives med. I vårt eksempel er frekvensen 1 og dermed
 får variabelen <i>s</i> verdien 1. Tilsammen blir det 5 + 1 = 6 biter.
</p>

<p>
 I selve komprimeringen blir hvert av de 330.520 tegnene (bytene) erstattet med sin bikode.
 Det utgjør 1.659.544 biter. Det hele avsluttes med de 19 bitene i vaktpostens bitkode.
 Sammenlagt 1.660.303 biter. Tallet 1.660.303 kan skrives som
 207.537&thinsp;&middot;&thinsp;8 + 7 biter. Med andre ord mangler det én bit for å fylle opp den siste byten.
 Den biten legges til etterpå og utskriftsfilen vil derfor komme til å inneholde 207.538 byter.
</p>

<p>
 <b>Komprimeringsgrad</b> er definert som differensen mellom gammel og ny filstørrelese delt med
 gammel filstørrelse. I vårt eksempel blir det (330.520 &minus; 207.538)&thinsp;/&thinsp;330.520
 = 0,37 = 37&thinsp;%. En frekvensfordeling er skjev hvis noen tegn forekommer ofte,
 mens andre tegn er sjeldne og jevn hvis alle tegnene forekommer omtrent like ofte.
 Jo skjevere fordeling er, jo høyere komprimeringsgrad gir Huffmans metode. Tekstfiler er gode
 eksempler på skjeve fordelinger.
</p>

<p>
 Hvis en fil inneholder alle eller de fleste av de 256 aktuelle
 tegnene og i tillegg har jevn frekvensfordeling, kan det hende at komprimeringsgraden blir lav og til og med
 negativ. Den blir negativ hvis den komprimerte filen blir større enn den opprinnelige. Ta
 pdf-versjonen av <a tabindex="-1" href="../../kap1/3/kap13.pdf"><i>Delkapittel</i> 1.3</a> som
 eksempel. Den er på 769.757 byter.
 <a tabindex="-1" href="#kode.5.4.8.f"><i>Programkode</i> 5.4.8 <i>f)</i></a> brukt på den vil
 gi en utskriftsfil på 753.492 byter, dvs. en komprimeringsgrad på 2&thinsp;%.
</p>

<p>
 Første del av den komprimerte filen skal inneholde nok informasjon til at tegnenes bitkoder
 kan rekonstrueres. Hvis vi har en stor fil slik som i
 <a tabindex="-1" href="#figur.5.4.8.a"><i>Figur</i> 5.4.8 <i>a)</i></a>, har størrelsen på denne
 informasjonen lite å si for komprimeringsgraden. Men for små filer kan det bli annerledes. Da
 er det gunstig at informasjonen tar så liten plass som mulig. En mulighet er å bruke
 Huffmans metode også på bitkodelengdene. Flg. tabell viser fordelingen:
</p>

<a name="tabell.5.4.8.a"></a>
<table class="sentrert-tabell-20" cellspacing="0" cellpadding="5">
<tr>
 <td>1</td><td>6</td><td>7</td><td>9</td><td>8</td><td>11</td>
 <td>8</td><td>12</td><td>13</td><td>2</td><td>6</td><td>2</td>
 <td>2</td><td>2</td><td>3</td><td>1</td><td>2</td>
</tr>
<tr>
 <td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td>
 <td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td>
 <td>15</td><td>16</td><td>17</td><td>18</td><td>19</td>
</tr>
</table>

<p>
 Bitkodelengde 3 forekommer bare én gang, mens lengdene 10 og 11
 forkommer 12 og 13 ganger. I
 <a tabindex="-1" href="#figur.5.4.8.a"><i>Figur</i> 5.4.8 <i>a)</i></a> ble alle bitkodelengdene
 skrevet ut med 5 binære siffer. Men kan vi isteden la de bitkodelengdene det er mange av få en
 kortere bitkode og dermed en lenger bitkode for de lengdene det er få av (f.eks. lengdene 3 og 18).
 Dette tas opp i <a tabindex="-1" href="#oppg.5.4.8"><i>Oppgave</i> 7</a>.
</p>

<p>
 Det finnes komprimeringsteknikker som gir en vesentlig høyere komprimeringsgrad enn Huffmans metode.
 Det skal vi se mer på et annet sted. Huffmans metode er likevel i bruk, men da først og fremst
 som et ledd i andre algoritmer. F.eks. algoritmen
 <a tabindex="-1" href="http://en.wikipedia.org/wiki/DEFLATE"><i>Deflate</i></a> som brukes bl.a. i filformatet
 <a tabindex="-1" href="http://en.wikipedia.org/wiki/Portable_Network_Graphics"><i>PNG</i></a>.
</p>

<a name="oppg.5.4.8"></a>
<div>
<a tabindex="-1" href="fasit548.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.8</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>Kopier klassene <a tabindex="-1" href="../../vedlegg/A/BitOutputStream.html"><code>BitOutputStream</code></a>
 og <a tabindex="-1" href="../../vedlegg/A/BitInputStream.html"><code>BitInputStream</code></a>
 over til deg. Legg dem under mappen (package) <code>bitio</code>.
 </td></tr>
 <tr><td>2.</td>
 <td>Legg metoden i <a tabindex="-1" href="#kode.5.4.8.a"><i>Programkode</i> 5.4.8 <i>a)</i></a>
 inn i klassen <code>Huffman</code>.
 Finn så bitkodene som blir brukt under komprimering av meldingen "Dette er en test!"
 og sjekk at det stemmer med utskriften i
 <a tabindex="-1" href="#eksempel.5.4.8.1"><i>Eksempel</i> 1</a>.
 </td></tr>
 <tr><td>3.</td>
 <td>Huffmans metode virker best hvis &laquo;meldingen&raquo; har en skjev
 frekvensfordeling, f.eks. tekstfiler eller filer med javakode. På slike filer vil de aller fleste
 tegnene ligge i intervallet 0&thinsp;&minus;&thinsp;127. På norsk er det imidlertid noen unntak siden
 bokstavene <i>Æ</i>, <i>æ</i>, <i>Ø</i>, <i>ø</i>, <i>Å</i> og <i>å</i> ligger i intervallet
 128&thinsp;&minus;&thinsp;255. Gjør om metoden i
 <a tabindex="-1" href="#kode.5.4.8.f"><i>Programkode</i> 5.4.8 <i>f)</i></a>
 slik at det brukes 128 biter for å markere hvilke tegn i intervallet 0&thinsp;&minus;&thinsp;127
 som finnes. Tegnene fra 128&thinsp;&minus;&thinsp;255 oppgis ved at antallet oppgis og så en byte
 (nok med 7 biter siden tegnet starter med en 1-bit) for
 hvert tegn. Hvor mange biter ville dette ha blitt for tegnene
 i <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a>?
 </td></tr>
 <tr><td>4.</td>
 <td>Hvis det er få forskjellige tegn, kan det lønne seg å oppgi hvilke tegn det er ved å ramse dem
 opp (antallet og så tegnene). Da kan det lønne seg å dele det i to grupper:
 1) de i intervallet 0&thinsp;&minus;&thinsp;127 og 2) de i intervallet 128&thinsp;&minus;&thinsp;255.
 Da er det nok å bruke 7 biter per tegn siden alle tegn i gruppe 1) starter med 0 og alle i gruppe 2)
 med 1. Hvor går grensen (antall forskjellige tegn) for at dette lønner seg i forhold til slik
 det gjøres i <i>Oppgave</i> 3? Gjør disse endringene i
 <a tabindex="-1" href="#kode.5.4.8.f"><i>Programkode</i> 5.4.8 <i>f)</i></a>. La dette tilfellet
 svare til at tallet 1 (0001) skrives ut som filhode.
 </td></tr>
 <tr><td>5.</td>
 <td>Et hvilket som helst av tegnene kan brukes som &laquo;vaktpost&raquo;. Hva blir fordelen og
 hva blir ulempen ved å velge et annet tegn som &laquo;vaktpost&raquo; enn et som har lengst bitkode?
 </td></tr>
 <tr><td>6.</td>
 <td>Lag tillegg i <a tabindex="-1" href="#kode.5.4.8.f"><i>Programkode</i> 5.4.8 <i>f)</i></a> som
 behandler spesialtilfellene 1) filen er tom og 2) alle tegnene er like. Signaliser tilfellene 1)
 og 2) ved å bruke henholdsvis 2 (0010) og 3 (0011) som filhode.
 </td></tr>
 <tr><td>7.</td>
 <td>Det antallet biter vi bruker for å skrive ut bitkodelengdene kan reduseres. Lengdene
 har en skjev frekvensfordeling og kan derfor representeres med variabel bitkodelengde. Se
 f.eks. <a tabindex="-1" href="#tabell.5.4.8.a">tabellen</a> med bitkodelengder hentet fra
 <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a>. Hvis metoden i
 <a tabindex="-1" href="#kode.5.4.8.f"><i>Programkode</i> 5.4.8 <i>f)</i></a> brukes på
 den filen, vil lengdene bli skrevet ut med 5 biter for hver lengde, dvs. 95&middot;5 = 475 biter.
 Hvor mange biter vil det bli hvis vi bruker Huffmans metode på bitkodelengdene?
 Gjør om <a tabindex="-1" href="#kode.5.4.8.f"><i>Programkode</i> 5.4.8 <i>f)</i></a> slik
 at denne ideen brukes.
 </td></tr>
 <tr><td>8.</td>
 <td>Alle bitkodelengder er større enn 0. Dermed kan vi skrive dem ut redusert med 1. Dermed kan det
 være mulig å bruke færre siffer. F.eks. kun 4 siffer hvis største lengde var 16 siden 16 - 1 = 15
 krever kun fire siffer. Eller vi kan redusere med lengden til minste lengde. Hvis den er 3 reduseres med 3.
 Hvis f.eks. lengdene går fra 3 til 18, vil det isteden bli fra 0 til 15 og vi trenger kun fire siffer.
 </td></tr>
 <tr><td>9.</td>
 <td>Som vaktpost brukes et tegn med maksimal bitkodelengde. Et slikt tegn finner vi allerede
 da treet bygges siden den tas ut først fra prioritetskøen. Kan det benyttes videre?
 </td></tr>
</table>


<div class="sideskift"></div>


<!-- ////// 5.4.9 /////////////////////// -->


<p><a name="5.4.9" tabindex="9"></a>
<a tabindex="-1" href="#5.4.10"><img class="icon" src="../../images/kvadrat.gif"
 alt="Til Avsnitt 5.4.10 - Effektiv dekomprimering"
 title="Til Avsnitt 5.4.10 - Effektiv dekomprimering" width="25" height="25" /></a>
<b>&nbsp; 5.4.9 &nbsp;Enkel dekomprimering</b><br/>

 Å dekomprimere er å reversere det som ble utført under komprimeringen. Vi tar
 utgangspunkt i komprimeringsmetoden slik den er satt opp i
 <a tabindex="-1" href="#kode.5.4.8.f"><i>Programkode</i> 5.4.8 <i>f)</i></a>.
 Hvis metoden er endret og/eller har fått tillegg (se oppgavene i
 <a tabindex="-1" href="#oppg.5.4.8"><i>Avsnitt</i> 5.4.8</a>), må
 dekomprimeringsmetoden endres tilsvarende. I komprimeringsmetoden ble det
 først skrevet ut tre biter. Vi må derfor starte med å lese dem. De tre
 bitene gir oss et tall (variabelen <i>k</i>) som sier hvor
 mange biter som bitkodelengdene er skrevet ut med.
 Neste oppgave er å lese den informasjonen som forteller hvilke tegn det handler om,
 deres bitkodelengder og vaktpostinformasjonen. En dekomprimeringsmetode må
 derfor starte slik (obs: du må ha tilgang til
 <code><a tabindex="-1" href="../../vedlegg/A/BitInputStream.html">BitInputStream</a></code>):
</p>

<a name="kode.5.4.9.a"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>
  dekomprimer(String fraUrl, String tilFil) <span class="keyword">throws</span> IOException
  {
    BitInputStream inn =
      <span class="keyword">new</span> BitInputStream((<span class="keyword">new</span> URL(fraUrl)).openStream());  <span class="comment">// åpner filen</span>

    <span class="keyword">int</span> k = inn.readBits(3);                  <span class="comment">// antall biter i lengdene</span>
    <span class="keyword">int</span>[] lengder = <span class="keyword">new</span> <span class="keyword">int</span>[256];             <span class="comment">// 256 mulige tegn</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; lengder.<span class="variable">length</span>; i++)
    {
      <span class="keyword">if</span> (inn.readBit() == 1)
      {
        lengder[i] = inn.readBits(k);
      }
    }

    <span class="keyword">int</span> vaktpost = Tabell.maks(lengder);      <span class="comment">// tegnet med størst lengde</span>

    <span class="keyword">int</span> s = inn.readBits(5);       <span class="comment">// antall siffer i vaktpostens frekvens</span>
    <span class="keyword">int</span> vaktpostfrekvens = inn.readBits(s) + 1;

    <span class="comment">// her vil det komme mer kode</span>

    inn.close();    <span class="comment">// lukker inn-filen</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.9 <i>a)</i></span></b></pre>

<p>
 Gitt at vi har laget et kanonisk tre ved hjelp av bitkodelengdene.
 Dekomprimeringen kan da utføres ved at én og én bit leses.
 Fra rotnoden går vi til venstre ved en 0-bit og til høyre ved en 1-bit, osv.
 Før eller senere kommer vi til et tegn (en bladnode). Hvis det er vaktposten
 og vi har funnet den for siste gang, er vi ferdige. Hvis ikke, skriver vi ut tegnet
 og starter på nytt i rotnoden. Dette er en enkel, men <b>ikke</b> effektiv
 dekomprimeringsteknikk. Vi skal finne en vesentlig mer effektiv måte
 i neste avsnitt, dvs. i <a tabindex="-1" href="#5.4.10"><i>Avsnitt</i> 5.4.10</a>.
</p>

<p>
 Vi må først lage det kanoniske treet. Det kan gjøres på flere måter. Den
 enkleste måten er nok å gjøre det ved hjelp av bitkodene. Vi har allerede
 en metode som finner dem ved hjelp av bitkodelengdene.
 Se <a tabindex="-1" href="#kode.5.4.7.b"><i>Programkode</i> 5.4.7 <i>b)</i></a>.
 Bitkoden for hvert aktuelt tegn utgjør en gren i treet. Husk at en gren i et binærtre
 består av rotnoden og nodene på veien ned til en bladnode. Vi bygger treet ved å
 bygge det gren for gren. En ny gren kan bestå av noder som allerede ligger i treet
 og av nye noder. Grenens nye noder må lages fortløpenede nedover mot den aktuelle
 bladnoden.
</p>

<p>
 Ta som eksempel
 at vi har de åtte tegnene fra <i>A</i> til <i>H</i> med flg. bitkoder:
 <i>A</i> = 001, <i>B</i> = 010,<br /> <i>C</i> = 0000, <i>D</i> = 011, <i>E</i> = 11,
 <i>F</i> = 100, <i>G</i> = 0001 og <i>H</i> = 101. Vi legger inn &laquo;grenene&raquo;
 fortløpende, først <i>A</i> = 001. Deretter <i>B</i> = 010, men da kun noder som er nye i forhold til A:
</p>


<table class="mbilde">
<tr><td><img src="images/549a.png" alt="Starten på et kanonisk tre" title="Starten på et kanonisk tre"
 width="430" height="207" /></td></tr>
<tr><td>Grenen A = 001 er lagt inn &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Grenen B = 010 er lagt inn</td></tr>
</table>

<p>
 Med utgangspunkt i en lengdetabell kan dette kodes slik (metoden legges i class Huffman):
</p>

<a name="kode.5.4.9.b"></a>
<pre>  <span class="keyword">private</span> <span class="keyword">static</span> Node byggKanoniskTre(<span class="keyword">int</span>[] lengder)
  {
    <span class="keyword">int</span>[] bitkoder = finnBitkoder(lengder);   <span class="comment">// bitkodene</span>
    Node rot = <span class="keyword">new</span> Node();                    <span class="comment">// rotnoden</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; lengder.<span class="variable">length</span>; i++)  <span class="comment">// går gjennom tabellen</span>
    {
      <span class="keyword">if</span> (lengder[i] &gt; 0)                     <span class="comment">// denne skal være med</span>
      {
        <span class="keyword">int</span> n = bitkoder[i];                  <span class="comment">// bitkoden til tegnet i</span>
        <span class="keyword">int</span> k = (1 &lt;&lt; lengder[i]) &gt;&gt; 1;       <span class="comment">// posisjonen til første bit</span>
        Node p = rot;                         <span class="comment">// starter i roten</span>

        <span class="keyword">while</span> (k &gt; 1)                         <span class="comment">// alle unntatt siste bit</span>
        {
          <span class="keyword">if</span> ((k &amp; n) == 0)                   <span class="comment">// biten på plass k</span>
          {
            <span class="keyword">if</span> (p.venstre == <span class="keyword">null</span>) p.venstre = <span class="keyword">new</span> Node();
            p = p.venstre;
          }
          <span class="keyword">else</span>
          {
            <span class="keyword">if</span> (p.høyre == <span class="keyword">null</span>) p.høyre = <span class="keyword">new</span> Node();
            p = p.høyre;
          }
          k &gt;&gt;= 1;   <span class="comment">// flytter k en posisjon mot høyre</span>
        }
        <span class="comment">// lager bladnoden til slutt</span>
        <span class="keyword">if</span> ((n &amp; 1) == 0) p.venstre = <span class="keyword">new</span> BladNode((<span class="keyword">char</span>)i,0);
        <span class="keyword">else</span> p.høyre = <span class="keyword">new</span> BladNode((<span class="keyword">char</span>)i,0);
      }
    }

    <span class="keyword">return</span> rot;  <span class="comment">// roten til det kanoniske treet</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.9 <i>b)</i></span></b></pre>

<p>
 Hvis vi bruker <i>Programkode</i> 5.4.9 <i>b)</i> på en lengdetabell der
 <i>A</i> = 3, <i>B</i> = 3, <i>C</i> = 4, <i>D</i> = 3, <i>E</i> = 2, <i>F</i> = 3,
 <i>G</i> = 4 og <i>H</i> = 3, får vi flg. kanoniske tre:
</p>

<a name="figur.5.4.9.a"></a>
<table class="mbilde">
<tr><td><img src="images/549b.png" alt="Starten på et kanonisk tre" title="Starten på et kanonisk tre"
 width="318" height="240" /></td></tr>
<tr><td>Figur 5.4.9 a) : Et kanonisk tre</td></tr>
</table>

<p>
 <a tabindex="-1" href="#kode.5.4.9.a"><i>Programkode</i> 5.4.9 <i>a)</i></a>
 inneholder starten på dekomprimeringen. Som fortsettelse må vi først konstruere det
 kanoniske treet, så åpne utskriftsfilen, opprette en frekvensvariabel og sette i gang
 selve dekomprimeringen. Ved hjelp av én og én bit går vi fra rotnoden ned til et tegn
 (en bladnode). Tegnet telles med hvis det er vaktposttegnet og vi
 avslutter hvis det var siste forekomst.
 Hvis ikke, skrives tegnet ut og vi starter på nytt fra rotnoden. Flg. kodebit skal legges inn i
 <a tabindex="-1" href="#kode.5.4.9.a"><i>Programkode</i> 5.4.9 <i>a)</i></a> der det står
 <span class="comment">// her vil det komme mer kode</span>:
</p>

<a name="kode.5.4.9.c"></a>
<pre>  Node rot = byggKanoniskTre(lengder);   <span class="comment">// bygger treet</span>
  BitOutputStream ut = <span class="keyword">new</span> BitOutputStream(tilFil);
  <span class="keyword">int</span> frekvens = 0;   <span class="comment">// opptellingsvariabel</span>

  <span class="keyword">for</span> (Node p = rot; ; p = rot)
  {
    <span class="keyword">while</span> (p.venstre != <span class="keyword">null</span>)  <span class="comment">// p er ikke en bladnode</span>
      p = inn.readBit() == 0 ? p.venstre : p.høyre;

    <span class="keyword">if</span> (((BladNode)p).tegn == vaktpost)
    {
      <span class="keyword">if</span> (++frekvens == vaktpostfrekvens) <span class="keyword">break</span>;  <span class="comment">// ferdig</span>
    }

    ut.write(((BladNode)p).tegn);  <span class="comment">// skriver ut</span>
  }

  ut.close();

              <b><span class="code"><i>Programkode</i> 5.4.9 <i>c)</i></span></b></pre>

<p>
 Filen <span class="character">"komprimert.huf"</span> inneholder
 en komprimert &laquo;melding&raquo; der filtypen
 <span class="character">"huf"</span> signaliserer at Huffmans metode
 er brukt. Hvis programbiten i
 <i>Programkode</i> 5.4.9 <i>c)</i> er lagt inn i metoden i
 <a tabindex="-1" href="#kode.5.4.9.a"><i>Programkode</i> 5.4.9 <i>a)</i></a>
 og den igjen er lagt inn i class Huffman, vil flg. kodebit virke:
</p>

<a name="kode.5.4.9.d"></a>
<pre>  String inn = <span class="character">"http://www.iu.hio.no/~ulfu/appolonius/kap5/4/komprimert.huf"</span>;
  Huffman.dekomprimer(inn,<span class="character">"ut.txt"</span>);

              <b><span class="code"><i>Programkode</i> 5.4.9 <i>d)</i></span></b></pre>

<p>
Kjør programbiten over og sjekk utskriftsfilen
<span class="character">"ut.txt"</span>. Den skal inneholde
den originale &laquo;meldingen&raquo; og skal kunne leses uten problemer. I
tillegg kan det sjekkes om den dekomprimerte filen er nøyaktig like stor
som den opprinnelige filen. Men for å være helt sikker på at komprimeringen
og dekomprimeringer fungerer korrekt, bør det sjekkes om filene er
nøyaktig like, dvs. like byte for byte. Se <i>Oppgave</i> 3.
</p>

<a name="oppg.5.4.9"></a>
<div>
<a tabindex="-1" href="fasit549.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.9</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>Legg <a tabindex="-1" href="#kode.5.4.9.b"><i>Programkode</i> 5.4.9 <i>b)</i></a>
 inn i <code>class Huffman</code>.
 </td></tr>
 <tr><td>2.</td>
 <td>Legg <a tabindex="-1" href="#kode.5.4.9.a"><i>Programkode</i> 5.4.9 <i>a)</i></a>
 inn i <code>class Huffman</code> og legg så programbiten i
 <a tabindex="-1" href="#kode.5.4.9.c"><i>Programkode</i> 5.4.9 <i>c)</i></a>
 inn i metoden der det står <span class="comment">// her vil det komme mer kode</span>.
 </td></tr>
 <tr><td>3.</td>
 <td>Lag en metode som sjekker om to filer er identiske, dvs. om de er like byte for byte. Bruk metoden
 til å sammenligne utskriftsfilen <span class="character">"ut.txt"</span> i
 <a tabindex="-1" href="#kode.5.4.9.d"><i>Programkode</i> 5.4.9 <i>d)</i></a> med
 originalfilen <span class="character">"http://www.iu.hio.no/~ulfu/appolonius/kap5/4/test.txt"</span>.
 </td></tr>
 <tr><td>4.</td>
 <td>Komprimer og dekomprimer kap13.html
 </td></tr>
 <tr><td>5.</td>
  <td>Som i <i>Oppgave</i> 4 men med kap13.pdf.
 </td></tr>
 <tr><td>6.</td>
  <td>Ta hensyn til de endringene i komprimer som er gjort i Oppgave ......
 </td></tr>

</table>

<div class="sideskift"></div>

<!-- ////// 5.4.10 /////////////////////// -->


<p><a name="5.4.10" tabindex="10"></a>
<a tabindex="-1" href="#5.4.11"><img class="icon" src="../../images/kvadrat.gif"
 alt="Til Avsnitt 5.4.11 - xxx"
 title="Til Avsnitt 5.4.11 - xxx" width="25" height="25" /></a>
<b>&nbsp; 5.4.10 &nbsp;Effektiv dekomprimering</b><br/>

Dekomprimeringsteknikken som brukes i
<a tabindex="-1" href="#kode.5.4.9.c"><i>Programkode</i> 5.4.9 <i>c)</i></a>
er ikke effektiv. For det første leses én og én bit og det er kostbart.
For det andre må vi sammenligne for hver bit for å kunne gå nedover i treet.
Tilsammen blir dette mye arbeid. En bedre teknikk er å kunne &laquo;hoppe ned&raquo;
til rett tegn i én operasjon. Vi bruker treet i
<a tabindex="-1" href="#figur.5.4.9.a"><i>Figur</i> 5.4.9 <i>a)</i></a> som utgangspunkt.
Fyller vi opp med nodene som mangler på hver rad, får vi et perfekt binærtre.
Ekstranodene har fått grå farge på figuren under:
</p>

<a name="figur.5.4.10.a"></a>
<table class="mbilde">
<tr><td><img src="images/5410a.png" alt="Et perfekt tre" title="Et perfekt tre"
 width="561" height="201" /></td></tr>
<tr><td>Figur 5.4.10 a) : Et utvidelse til et perfekt tre</td></tr>
</table>

<p>
I treet over er det <i>C</i> og <i>G</i> som har lengst bitkode og lengden er fire.
Anta nå at vi leser fire biter om gangen. Et eksempel er bitene 0101. De første
tre bitene bringer oss ned til den røde noden med bokstaven <i>B</i>. Den siste biten
bringer oss videre ned til siste rad og da til en grå node som også har bokstaven <i>B</i>.
Hvis de fire bitene isteden hadde vært 0100, ville det samme ha skjedd bortsett fra
at vi nå vil teffe en annen grå node med bokstaven <i>B</i>.
</p>

<p>
Anta nå at vi har fire biter der de to første er 11. Det vil bringe oss først ned til den
røde noden med boktsven <i>E</i>. Men uansett hva de to neste bitene er (00, 01, 10 eller 11),
vil de bringe oss ned til en grå node med bokstaven <i>E</i>. Siste rad i
treet i <i>Figur</i> 5.4.10 <i>a)</i> har 16 noder. De kan nummereres fra 0 til 15. Bokstaven <i>C</i> ligger lengst
til venstre. Den har bitoden 0000 og det svarer til tallet 0 skrevet med fire binære
siffer. Bokstaven <i>G</i> har bitkoden 0001 og det gir tallet 1 skrevet med fire
binære siffer. Den første grå noden med bokstaven <i>A</i> har bitkoden 0010 og det
er tallet 2 med fire binære siffer. Osv.
</p>

<p>
Vi kan erstatte den siste raden i treet med flg. tabell:
</p>

<a name="figur.5.4.10.b"></a>
 <table class="sentrert-tabell-25" cellspacing="0" cellpadding="4">
 <tr>
 <td>C</td> <td>G</td> <td>A</td> <td>A</td> <td>B</td> <td>B</td>
 <td>D</td> <td>D</td> <td>F</td> <td>F</td> <td>H</td> <td>H</td>
 <td>E</td> <td>E</td> <td>E</td><td>E</td>
 </tr>
 <tr>
  <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
  <td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td>
 </tr>
 <tr>
  <td colspan="16">Figur 5.4.10 b) : En tegntabell med samme innhold som nederste rad i treet</td>
 </tr>
 </table>

<p>
 Tabellindeksene går fra 0 til 15. Det betyr at når fire biter tolkes som et heltall fungerer
 det som en tabellindeks. Dermed kan vi lese rett ut fra tabellen hvilken bokstav det er.
 F.eks. er 1101 = 13 og det gir bokstaven <i>E</i>. Det er imidlertid et lite problem. Det er
 kun de to bitene 11 som er den egentlige bitkoden til <i>E</i>. Det betyr at de to siste bitene,
 dvs. 01, må &laquo;legges tilbake&raquo; og utgjøre de første to bitene ved neste lesing
 av fire biter. Tabellen under viser hvor mange biter som må &laquo;legges tilbake&raquo;
 for hver bokstav. F.eks. er det 2 for bokstaven <i>E</i>:
</p>

<a name="figur.5.4.10.c"></a>
 <table class="sentrert-tabell-25" cellspacing="0" cellpadding="4">
 <tr>
 <td>1</td> <td>1</td> <td>0</td> <td>1</td> <td>2</td> <td>1</td>
 <td>0</td> <td>1</td>
 </tr>
 <tr>
  <td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td>
 </tr>
 <tr>
  <td colspan="8">Figur 5.4.10 c) : Antall biter for mange</td>
 </tr>
 </table>

<p>
 Hvis <i>n</i> er største bitkodelengde, vil nederste rad i utvidelsen av det
 kanoniske treet til et perfekt tre få 2<sup><i>n</i></sup> noder.
 Den tilhørende tabellen vil dermed få indekser fra 0 til 2<sup><i>n</i></sup> &minus; 1.
 Tabellen som skal fortelle hvor mange biter som skal
 &laquo;legges tilbake&raquo;, skal ha plass til alle de 256 mulige tegnene.
 I dekomprimeringen leses <i>n</i> og <i>n</i> biter. En samling på
 <i>n</i> biter, tolket som et heltall, utgjør en indeks i tabellen. Dermed får vi tak
 i rett tegn ved å &laquo;slå opp&raquo; i tabellen. Deretter bruker vi tegnet som indeks
 i den andre tabellen og får vite hvore mange biter som skal &laquo;legges tilbake&raquo; og
 dermed utgjøre de første bitene i neste innlesing på <i>n</i> biter.
</p>

<p>
 For et tegn <i>X</i> med bitkodelengde <i>k</i> vil det være <i>d</i> =
 <i>n</i> &minus; <i>k</i> biter som skal &laquo;legges tilbake&raquo;.
 Første posisjon for <i>X</i> i tegntabellen finner vi ved å legge <i>d</i> stykker
 0-biter bakerst i bitkoden til <i>X</i>. I tegntabellen vil det være 2<sup><i>d</i></sup>
 forekomster av <i>X</i>.
 Ta treet i <a tabindex="-1" href="#figur.5.4.10.a"><i>Figur</i> 5.4.10 <i>a)</i></a>,
 tegntabellen i <a tabindex="-1" href="#figur.5.4.10.b"><i>Figur</i> 5.4.10 <i>b)</i></a>
 og bokstaven <i>E</i> som eksempel. Da vil <i>n</i> = 4, <i>k</i> = 2 og <i>d</i> = 2.
 Første posisjon for <i>E</i> er 11 pluss to 0-biter, dvs. 1100 = 12. Antall forekomster
 av <i>E</i> er 2<sup><i>d</i></sup> = 2<sup>2</sup> = 4, dvs. <i>E</i> går fra 12 til
 (men ikke med) 12 + 4 = 16.
</p>

<p>
 Flg. metode som skal legges i <code>class Huffmann</code>, tar i mot en lengdetabell,
 en tabell for antall biter som skal &laquo;legges tilbake&raquo; og
 største bitkodelengde (obs: 1 &lt;&lt; <i>n</i> er lik 2<sup><i>n</i></sup>&thinsp;):
</p>

<a name="kode.5.4.10.a"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] lagTegntabell(<span class="keyword">int</span>[] lengder, <span class="keyword">int</span>[] tilbake, <span class="keyword">int</span> n)
  {
    <span class="keyword">int</span>[] bitkoder = finnBitkoder(lengder);    <span class="comment">// finner bitkodene</span>

    <span class="keyword">byte</span>[] tegntabell = <span class="keyword">new</span> <span class="keyword">byte</span>[1 &lt;&lt; n];      <span class="comment">// en byte-tabell</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; lengder.<span class="variable">length</span>; i++)   <span class="comment">// går gjennom tabellen</span>
      <span class="keyword">if</span> (lengder[i] &gt; 0)                      <span class="comment">// tegn nr. i er med</span>
      {
        <span class="keyword">int</span> d = n - lengder[i];                <span class="comment">// d er lengdeforskjellen</span>
        tilbake[i] = d;                        <span class="comment">// antall tilbake</span>
        <span class="keyword">int</span> fra = bitkoder[i] &lt;&lt; d;            <span class="comment">// starten på tegn nr. i</span>
        <span class="keyword">int</span> til = fra + (1 &lt;&lt; d);              <span class="comment">// slutten på tegn nr. i</span>

        <span class="keyword">for</span> (<span class="keyword">int</span> j = fra; j &lt; til; j++)        <span class="comment">// fyller ut intervallet</span>
          tegntabell[j] = (<span class="keyword">byte</span>)i;             <span class="comment">// med tegn nr. i</span>
    }
    <span class="keyword">return</span> tegntabell;
  }
              <b><span class="code"><i>Programkode</i> 5.4.10 <i>a)</i></span></b></pre>

<p>
 <b>Eksempel</b>: I flg. kodebit brukes tegnene og birkodelengdene fra
 <a tabindex="-1" href="#figur.5.4.9.a"><i>Figur</i> 5.4.9 <i>a)</i></a>:
</p>

<a name="kode.5.4.10.b"></a>
<pre>  <span class="keyword">int</span>[] lengder = <span class="keyword">new</span> <span class="keyword">int</span>[256];
  <span class="keyword">int</span>[] tilbake = <span class="keyword">new</span> <span class="keyword">int</span>[256];

  lengder[<span class="character">'A'</span>] = 3; lengder[<span class="character">'B'</span>] = 3; lengder[<span class="character">'C'</span>] = 4; lengder[<span class="character">'D'</span>] = 3;
  lengder[<span class="character">'E'</span>] = 2; lengder[<span class="character">'F'</span>] = 3; lengder[<span class="character">'G'</span>] = 4; lengder[<span class="character">'H'</span>] = 3;

  <span class="keyword">byte</span>[] tegntabell = Huffman.lagTegntabell(lengder, tilbake, 4);
  <span class="keyword">for</span> (<span class="keyword">byte</span> b : tegntabell) System.out.print((<span class="keyword">char</span>)(b &amp; 255) + <span class="character">" "</span>);

  <span class="comment">// Utskrift: C G A A B B D D F F H H E E E E</span>

              <b><span class="code"><i>Programkode</i> 5.4.10 <i>b)</i></span></b></pre>

<p>
 Teknikken krever, som nevnt flere steder, at biter som er lest må kunne
 &laquo;legges tilbake&raquo; slik at de kan leses på nytt. Klassen
 <a tabindex="-1" href="../../vedlegg/A/BitInputStream.html"><code>BitInputStream</code></a>
 har flere metoder som gjør nettopp det, f.eks. metoden
 <code>void unreadBits(int numberOfBits)</code> som &laquo;legger tilbake&raquo;
 en, noen eller alle de bitene som sist ble lest inn. Antallet oppgis ved hjelp av
 parameteren <code>numberOfBits</code>.
</p>

<p>
 Det kan oppstå et problem med tabellstørrelsen hvis det er store bitkodelengder.
 Setningen <code>byte[] tegntabell = new byte[1 &lt;&lt; n];</code> oppretter en
 tabell med 2 opphøyd i <i>n</i> som størrelse. I
 <a tabindex="-1" href="#eksempel.5.4.6.3"><i>Eksempel</i> 3</a> i
 <a tabindex="-1" href="#5.4.6"><i>Avsnitt</i> 5.4.6</a> ble filen som
 innholder <a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a>
 analysert. Der ble <i>n</i> = 19 største bitkodelengde. Det
 vil gi en tabell på størrelse 524.288 byter = 512kb. Det er ikke spesielt stort.
 Men hvis <i>n</i> blir en del større og nærmer seg 31, kan det bli problemer med
 minnet. Hvis det ikke er plass, kommer Java-feilmeldingen
 <span class="error">OutOfMemoryError: Java heap space</span>. Dette problemet
 tas opp lenger ned.
</p>

<p>
 I <a tabindex="-1" href="#kode.5.4.9.a"><i>Programkode</i> 5.4.9 <i>a)</i></a> laget vi
 starten på en dekomprimering. Der det står
 <span class="comment">// her vil det komme mer kode</span>, setter vi inn flg. kode:
</p>

<a name="kode.5.4.10.c"></a>
<pre>  <span class="keyword">int</span> n = lengder[vaktpost];                  <span class="comment">// lengden til vaktposten</span>
  <span class="keyword">int</span>[] tilbake = <span class="keyword">new</span> <span class="keyword">int</span>[lengder.<span class="variable">length</span>];    <span class="comment">// for tilbakelegging</span>

  <span class="keyword">byte</span>[] tegntabell = lagTegntabell(lengder, tilbake, n);

  BitOutputStream ut = <span class="keyword">new</span> BitOutputStream(tilFil);  <span class="comment">// for utskrift</span>
  <span class="keyword">int</span> frekvens = 0;   <span class="comment">// forekomster av vaktposttegnet</span>

  <span class="keyword">for</span>(;;)
  {
    <span class="keyword">int</span> tegn = tegntabell[inn.readBits(n)] &amp; 255;    <span class="comment">// finner et tegn</span>
    <span class="keyword">if</span> (tegn == vaktpost)
    {
      <span class="keyword">if</span> (++frekvens == vaktpostfrekvens) <span class="keyword">break</span>;
    }

    ut.write(tegn);                           <span class="comment">// skriver ut tegnet</span>

    inn.unreadBits(tilbake[tegn]);            <span class="comment">// legger biter tilbake</span>
  }

  ut.close();   <span class="comment">// lukker ut-filen</span>

              <b><span class="code"><i>Programkode</i> 5.4.10 <i>c)</i></span></b></pre>

<p>
 Hvis metoden <i>lagTegntabell</i> i
 <a tabindex="-1" href="#kode.5.4.10.a"><i>Programkode</i> 5.4.10 <i>a)</i></a>
 legges inn i klassen <code>Huffman</code> og kodebiten i
 <a tabindex="-1" href="#kode.5.4.10.a"><i>Programkode</i> 5.4.10 <i>c)</i></a>
 legges inn der det står <span class="comment">// her vil det komme mer kode</span>
 i <a tabindex="-1" href="#kode.5.4.9.a"><i>Programkode</i> 5.4.9 <i>a)</i></a>,
 vil flg. kodebit virke:
</p>

<a name="kode.5.4.10.d"></a>
<pre>  String inn = <span class="character">"http://www.iu.hio.no/~ulfu/appolonius/kap5/4/komprimert.huf"</span>;
  Huffman.dekomprimer(inn,<span class="character">"ut.txt"</span>);

              <b><span class="code"><i>Programkode</i> 5.4.10 <i>d)</i></span></b></pre>

<p>
Kjør programbiten i <i>Programkode</i> 5.4.10 <i>d)</i> og sjekk utskriftsfilen
<span class="character">"ut.txt"</span>. Den skal inneholde
den originale &laquo;meldingen&raquo; og skal kunne leses uten problemer.
</p>



<div class="sideskift"></div>

<p>
 <b>Store bitkodelengder</b> La <i>n</i> være største bitkodelengde. Hvis <i>n</i> = 19
 vil tegntabellen få 1 &lt;&lt; 19 = 524.288 byter = 512kb = 0,5mb som størrelse. Dette er
 ikke spesielt mye. Men for hver 1-er som <i>n</i> øker med, dobles størrelsen.
 Derfor er det viktig å ha en teknikk for å unngå &laquo;Out Of Memory&raquo; for
 store verdier av <i>n</i>.
</p>

<p>
 En mulig løsning er å lese inn bitene i to etapper.
 La oss dele det kanoniske treet på &laquo;midten&raquo;, dvs. la nivåene fra og med
 <i>m</i> = (<i>n</i> + 1)/2 og oppover være én del og nivåene nedenfor <i>m</i> en annen del.


 Ta filen som inneholder
 <a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a>
 som eksempel. Analysen av den filen viste at det kanoniske treet har
 flg. antall noder på nivåene fra 0 til 19:
</p>

<a name="figur.5.4.10.d"></a>
<table class="sentrert-todimtabell" cellspacing="0" cellpadding="4">
<tr class="litenskrift">
 <td>Antall bladnoder:</td>
 <td>0</td><td>0</td><td>0</td><td>1</td><td>6</td>
 <td>7</td><td>9</td><td>8</td><td>11</td><td>8</td>
 <td>12</td><td>13</td><td>2</td><td>6</td><td>2</td>
 <td>2</td><td>2</td><td>3</td><td>1</td><td>2</td>
</tr>
<tr class="litenskrift">
 <td>Antall indre noder:</td>
 <td>1</td><td>2</td><td>4</td><td>7</td><td>8</td>
 <td>9</td><td>9</td><td>10</td><td>9</td><td>10</td>
 <td>8</td><td>3</td><td>4</td><td>2</td><td>2</td>
 <td>2</td><td>2</td><td>1</td><td>1</td><td>0</td>
</tr>
<tr class="litenskrift">
 <td>Antall noder:</td>
 <td>&nbsp;1&nbsp;</td><td>&nbsp;2&nbsp;</td><td>&nbsp;4&nbsp;</td><td>&nbsp;8&nbsp;</td><td>14</td>
 <td>16</td><td>18</td><td>18</td><td>20</td><td>18</td>
 <td>20</td><td>16</td><td>6</td><td>8</td><td>4</td>
 <td>4</td><td>4</td><td>4</td><td>2</td><td>2</td>
</tr>
<tr class="litenskrift">
 <th>Nivå:</th>
 <th>0</th><th>1</th><th>2</th><th>3</th><th>4</th>
 <th>5</th><th>6</th><th>7</th><th>8</th><th>9</th>
 <th>10</th><th>11</th><th>12</th><th>13</th><th>14</th>
 <th>15</th><th>16</th><th>17</th><th>18</th><th>19</th>
</tr>
<tr class="litenskrift">
 <th colspan="21">Figur 5.4.10 d) : Antall bladnoder, antall indre noder og totalt antall noder på hvert nivå</th>
</tr>
</table>

<p>
Her er <i>n</i> = 19 og dermed <i>m</i> = (19 + 1)/2 = 10.
Tabellen viser at det på nivå 10 er totalt 20 noder derav 12 bladnoder og 8 indre noder.
Nå &laquo;glemmer&raquo; vi for en kort stund den delen av treet som ligger under nivå 10.
Hvis vi da utvider det vi har igjen til et perfekt tre slik som
i <a tabindex="-1" href="#figur.5.4.10.a"><i>Figur</i> 5.4.10 <i>a)</i></a>, vil det bli
2 opphøyd i <i>m</i> noder på nivå <i>m</i> = 10. Disse nodene
kan som før &laquo;erstattes&raquo; med en byte-tabell med størrelse 1 &lt;&lt; <i>m</i> =
1 &lt;&lt; 10 = 1024. De første 8 posisjonene hører til indre noder, mens resten skal fylles med
tegn. De 12 posisjonene fra 8 til 19 skal ha hver sin bokstav siden de representerer
tegn med <i>m</i> = 10 som bitkodelengde. På de neste posisjonene vil det komme flere
av hvert tegn. F.eks. to forekomster av alle tegn med bitkodelengde 9, fire forekomster av
alle med bitkodelengde 8, osv. Tabellen fylles opp med verdier omtrent slik som i
<a tabindex="-1" href="#kode.5.4.10.a"><i>Programkode</i> 5.4.10 <i>a)</i></a>.
</p>

<p>
Dekomprimeringen skjer nå ved at <i>m</i> = 10 biter leses. Hvis tallet som disse
representerer, er større enn 7, vil vi få tegnet ved å slå opp i tabellen og så
i tabellen for &laquo;tilbakelegging&raquo; for å finne hvor mange biter som skal
&laquo;legges tilbake&raquo;. Filen med
<a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a> inneholder
330.520 tegn og av dem er det hele 327.702 stykker som har en bitkodelengde på 10 eller
mindre. Det betyr at det å lese med 10 biter gir oss rett tegn i hele 99% av tilfellene.
</p>

<div>
Men resten av tegnene må tas med. Hvis de 10 bitene
representerer et heltall fra 0 til 7, kommmer vi til en indre node på nivå
10. Hver slik node er rotnode i sitt eget tre. Vi må vite
høydene i disse. Vi finner
det ved å starte nederst i det kanoniske treet og gå oppover mot
det aktuelle nivået. Tallene
i <a tabindex="-1" href="#figur.5.4.10.d"><i>Figur</i> 5.4.10 <i>d)</i></a>

<table class="vbilde">
<tr>
 <td><img src="images/5410e.png" alt="Den nederste delen av treet" title="Den nederste delen av treet" /></td>
</tr>
<tr>
 <td>Figur 5.4.10 e) : Den nederste delen av treet</td>
</tr>
</table>

forteller hvordan de nederste nivåene i treet skal tegnes. Se figuren til venstre.
På nivå 15 skal det imidlertid være fire noder, mens det på figuren kun
er tatt med to.
</div>

<p>
 På nivå 18 er det kun én indre node og det tilhørende treet har høyde 1. På
 nivå 17 er det også kun én indre node og treet har høyde 2. På
 nivå 16 er det to indre noder. Treet til den første har høyde 3 og det til den
 andre høyde 1. Tabellen sier at det også er to indre noder på nivå 15. Tegningen
 viser at de tilhørende trærne har høyde 4 og 1.
</p>

<p>
 Høyden til en node (eller treet med noden som rot)
 er én mer en høyden til det største
 (størst høyde) av nodens to subtrær. Flg. metode tar i mot en tabell <code>blader</code>
 som forteller hvor mange bladnoder det er på hvert nivå og returnerer en tabell som
 viser høyden til trærne til de indre nodene på et oppgitt <code>nivå</code>.
 Returtabellens lengde er lik antallet indre noder:
</p>

<a name="kode.5.4.10.e"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] treHøyde(<span class="keyword">int</span>[] blader, <span class="keyword">int</span> nivå)
  {
    <span class="keyword">int</span> n = blader.<span class="variable">length</span>;         <span class="comment">// n er antall nivåer i treet (0 til n-1)</span>
    <span class="keyword">int</span>[] noder = <span class="keyword">new</span> <span class="keyword">int</span>[n];      <span class="comment">// antall noder på hvert nivå (0 til n-1)</span>
    noder[n-1] = blader[n-1];      <span class="comment">// kun bladnoder på nederste nivå</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> k = n - 1; k &gt; nivå; k--)           <span class="comment">// n-1 er nederste nivå</span>
      noder[k - 1] = noder[k]/2 + blader[k-1];   <span class="comment">// antall noder på nivå k-1</span>

    <span class="keyword">int</span> maks = noder[Tabell.maks(noder)];  <span class="comment">// maks antall noder på et nivå</span>

    <span class="keyword">int</span>[] høyder = <span class="keyword">new</span> <span class="keyword">int</span>[maks];

    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - 2; i &gt;= nivå; i--)
    {
      <span class="keyword">int</span> k = noder[i] - blader[i];  <span class="comment">// antall indre noder på nivå i</span>

      <span class="keyword">for</span> (<span class="keyword">int</span> j = 0; j &lt; k; j++)
      {
        høyder[j] = Math.max(høyder[2*j],høyder[2*j+1]) + 1;
      }
      <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt; noder[i+1]; j++) høyder[j] = 0;
    }

    <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[noder[nivå] - blader[nivå]];
    System.arraycopy(høyder,0,h,0,h.<span class="variable">length</span>);

    <span class="keyword">return</span> h;
  }
              <b><span class="code"><i>Programkode</i> 5.4.10 <i>e)</i></span></b></pre>

<p>
 Tabellen i <a tabindex="-1" href="#figur.5.4.10.d"><i>Figur</i> 5.4.10 <i>d)</i></a>
 inneholder antallet bladnoder på hvert nivå. Flg. eksempel viser
 hvordan metoden <code>treHøyde</code> kan brukes til å finne
 høyden til trærne på gitte nivåer:
</p>

<a name="kode.5.4.10.f"></a>
<pre>  <span class="keyword">int</span>[] blader = {0,0,0,1,6,7,9,8,11,8,12,13,2,6,2,2,2,3,1,2};

  <span class="keyword">for</span> (<span class="keyword">int</span> nivå = 8; nivå &lt; 13; nivå++)
  {
    System.out.print(<span class="character">"nivå "</span> + nivå + <span class="character">": "</span>);
    Tabell.skrivln(Huffman.treHøyde(blader,nivå));
  }

  <span class="comment">// Utskrift:</span>
  <span class="comment">// nivå 8: 11 3 2 2 2 1 1 1 1</span>
  <span class="comment">// nivå 9: 10 2 2 2 1 1 1 1 1 1</span>
  <span class="comment">// nivå 10: 9 2 1 1 1 1 1 1</span>
  <span class="comment">// nivå 11: 8 2 1</span>
  <span class="comment">// nivå 12: 7 1 1 1</span>

              <b><span class="code"><i>Programkode</i> 5.4.10 <i>f)</i></span></b></pre>

<p>
 Det er nå en hel serie med &laquo;detaljer&raquo; som må på plass før selve dekomprimeringen
 kan starte. Vi tar utgangspunkt i
 <a tabindex="-1" href="#kode.5.4.9.a"><i>Programkode</i> 5.4.9 <i>a)</i></a>.
 Flg. &laquo;detaljer&raquo; skal inn der det står <span class="comment">// her vil det komme mer kode</span>:
</p>

<pre>  <span class="keyword">int</span> n = lengder[vaktpost];                <span class="comment">// lengden til vaktposten</span>
  <span class="keyword">int</span>[] blader = <span class="keyword">new</span> <span class="keyword">int</span>[n + 1];            <span class="comment">// n er nederste nivå</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> lengde : lengder)
    <span class="keyword">if</span> (lengde > 0) blader[lengde]++;       <span class="comment">// finner antallet på hvert nivå</span>

  <span class="keyword">int</span>[] bitkoder = finnBitkoder(lengder);   <span class="comment">// finner bitkodene</span></pre>

<p>
 Neste skritt er å dele det kanoniske treet på midten. Vi behandler den delen av treet
 som går ned til og med nivå <i>m</i> = (<i>n</i> + 1)/2 for seg. Vi lager først en byte-tabell med
 størrelse 1 &lt;&lt; <i>m</i> og fyller den med tegn på samme måte som i
 <a tabindex="-1" href="#kode.5.4.10.a"><i>Programkode</i> 5.4.10 <i>a)</i></a>. Et
 heltall gitt ved <i>m</i> biter blir da en indeks. Dermed kan vi finne tilhørende tegn
 ved å slå opp i tabellen og så bruke tegnet til å slå opp i tilbakeleggingstabellen. Forskjellen
 er at de første posisjonene i byte-tabellen nå representerer indre noder i det
 kanoniske treet. I de posisjonene legger vi derfor høyden til de tilhørende trærne:
</p>

<pre>  <span class="keyword">int</span> m = (n + 1)/2;                      <span class="comment">// det midterste nivået i treet</span>
  <span class="keyword">byte</span>[] tegntabell = <span class="keyword">new</span> <span class="keyword">byte</span>[1 &lt;&lt; m];   <span class="comment">// en byte-tabell</span>

  <span class="keyword">int</span>[] høyder = treHøyde(blader, m);     <span class="comment">// de indre nodene på nivå m</span>
  <span class="keyword">int</span> grense = høyder.<span class="variable">length</span>;             <span class="comment">// skiller indre noder og blader</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; grense; i++)
  {
    tegntabell[i] = (<span class="keyword">byte</span>)høyder[i];        <span class="comment">// høydene først i tegntabellen</span>
  }

  <span class="keyword">int</span>[] tilbake = <span class="keyword">new</span> <span class="keyword">int</span>[lengder.<span class="variable">length</span>];  <span class="comment">// for tilbakelegging</span></pre>

<p>
 Variabelen <i>grense</i> er skillet mellom de indre nodene og resten.
 Hvis heltallet representert med <i>m</i> biter er mindre enn <i>grense</i>, betyr
 det at vi må lenger ned i det kanoniske treet for å finne rett tegn.
 I vårt eksempel (<a tabindex="-1" href="#figur.5.4.10.d"><i>Figur</i> 5.4.10 <i>d</i></a>&thinsp;)
 er <i>n</i> = 19, <i>m</i> = (19 + 1)/2 = 10 og <i>grense</i> = 8. Utskriften fra
 <a tabindex="-1" href="#kode.5.4.10.f"><i>Programkode</i> 5.4.10 <i>f)</i></a> sier
 at høydene til trærne til de 8 indre nodene er henholdsvis 9, 2, 1, 1, 1, 1, 1 og 1.
 Det første treet har høyde 9. Hvis vi fyller ut det med nodene som mangler vil
 nederste nivå der få 1 &lt;&lt; 9 = 512 noder. Denne raden erstatter vi med en byte-tabell
 som fylles med tegn. Dermed kan et heltall gitt med 9 biter gi oss rett tegn ved
 et tabelloppslag. Osv. Vi trenger imidlertid 8 byte-tabeller. Da passer det å bruke
 en to-dimensjonal byte-tabell, dvs. en tabell med 8 rader. Størrelsene på de 8
 radene blir da 1 &lt;&lt; 9 = 512, 1 &lt;&lt; 2 = 4, 1 &lt;&lt; 1 = 2, osv:
</p>

<pre>  <span class="keyword">byte</span>[][] tegntabeller = <span class="keyword">new</span> <span class="keyword">byte</span>[grense][];    <span class="comment">// en to-dimensjonal tabell</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; grense; i++)
  {
    tegntabeller[i] = <span class="keyword">new</span> <span class="keyword">byte</span>[1 &lt;&lt; høyder[i]];  <span class="comment">// størrelse 1 &lt;&lt; høyder[i]</span>
  }
</pre>

<p>
 Legg merke til at i vårt eksempel vil hele systemet med byte-tabeller bestå av
 tabeller med størrelser 1024, 512, 4, 2, 2, 2, 2, 2 og 2. Tilsammen 1552 byter.
 Dette er dramatisk mindre bruk
 av minne enn å ha én byte-tabell på 1 &lt;&lt; 19 = 524288 byter.
</p>

<p>
 Den mest kompliserte oppgaven gjenstår. Det er å fylle alle byte-tabellene med
 de riktige tegnene. Da skal tegn med lengde &lt;= <i>m</i> legges i den &laquo;store&raquo;
 tabellen <code>tegntabell</code> og tegn med lengde > <i>m</i> i en av de &laquo;små&raquo;
 tabellene i <code>tegntabeller</code>:
</p>

<pre>  <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; lengder.<span class="variable">length</span>; i++)    <span class="comment">// går gjennom alle lengdene</span>
  {
    <span class="keyword">int</span> lengde = lengder[i];                  <span class="comment">// hjelpevariabel</span>

    <span class="keyword">if</span> (lengde &gt; 0)                           <span class="comment">// tegnet i skal være med</span>
    {
      <span class="keyword">if</span> (lengde &lt;= m)                        <span class="comment">// den store tabellen</span>
      {
        <span class="comment">// <b>tegntabell</b> skal fylles ut med tegnet asciiverdi i</span>
      }
      <span class="keyword">else</span>                                    <span class="comment">// de små tabellene</span>
      {
        <span class="comment">// en av tabellene i <b>tegntabeller</b> skal fylles ut med tegnet i</span>
      }
    }
  }</pre>

<p>
 Det å legge tegnet med ascii-verdi <i>i</i> inn i <code>tegntabell</code> gjøres
 som i <a tabindex="-1" href="#kode.5.4.10.a"><i>Programkode</i> 5.4.10 <i>a)</i></a>:
</p>

<pre>  <span class="keyword">int</span> d = m - lengde;                   <span class="comment">// lengdeforskjellen</span>
  tilbake[i] = d;                       <span class="comment">// antall tilbake</span>

  <span class="keyword">int</span> fra = bitkoder[i] &lt;&lt; d;           <span class="comment">// starten på tegn nr. i</span>
  <span class="keyword">int</span> til = fra + (1 &lt;&lt; d);             <span class="comment">// slutten på tegn nr. i</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> j = fra; j &lt; til; j++) tegntabell[j] = (<span class="keyword">byte</span>)i;  <span class="comment">// fyller ut</span></pre>

<p>
 Er bitkodelengden > <i>m</i>, skal tegnet ligge i en av tabellene
 i <code>tegntabeller</code>. I vårt eksempel
 er <i>m</i> = 10. La tegnet <i>i</i> ha en bitkodelengde på 15. De
 10 første bitene i bitkoden bringer oss ned til en av de indre nodene på nivå 10.
 Tallet gitt ved de 10 bitene vil være et av tallene fra 0 til 7 siden nivået har 8
 indre noder. Trærne til de 8 nodene har høyder på henholdsvis 9, 2, 1, . . . 1.
 Siden lengden er 15, skal tegnet legges i treet med høyde 9. Dermed skal
 det leses 9 biter til (og 9 &minus; 5 = 4 av dem må legges tilbake).
 De 10 første bitene i bitkoden må utgjøre tallet 0 (alle bitene
 er 0-biter). De 5 siste bitene sammen med 4 ekstra 0-biter bakerst, bestemmer
 posisjonen til første forekomst av tegnet <i>i</i>. Antallet forekomster er 1 &lt;&lt; 4 = 16.
 Istedenfor tallene 10, 15 og 9 skal vår kode bruke variablene <i>m</i>, <i>lengde</i> og <i>d1</i>&thinsp;:
</p>

<pre>  <span class="keyword">int</span> kode = bitkoder[i];        <span class="comment">// bitkoden til tegnet med i som asciiverdi</span>
  <span class="keyword">int</span> d1 = lengde - m;           <span class="comment">// differensen mellom lengde og m</span>

  <span class="keyword">int</span> kode1 = kode &gt;&gt; d1;               <span class="comment">// de m første bitene i kode</span>
  <span class="keyword">int</span> kode2 = kode &amp; ((1 &lt;&lt; d1) - 1);   <span class="comment">// de d1 siste bitene i kode</span>

  <span class="keyword">byte</span>[] b = tegntabeller[kode1];       <span class="comment">// finner rett tabell</span>

  <span class="keyword">int</span> d2 = tegntabell[kode1] - d1;      <span class="comment">// differensen mellom høyden og d1</span>
  tilbake[i] = d2;                      <span class="comment">// antall tilbake</span>

  <span class="keyword">int</span> fra = kode2 &lt;&lt; d2;                <span class="comment">// starten på tegn i</span>
  <span class="keyword">int</span> til = fra + (1 &lt;&lt; d2);            <span class="comment">// slutten på tegn i</span>

  <span class="keyword">for</span> (<span class="keyword">int</span> j = fra; j &lt; til; j++) b[j] = (<span class="keyword">byte</span>)i;  <span class="comment">// fyller ut</span></pre>

<p>
 Nå gjenstår selve dekomprimeringen. Kjernen der er at <i>m</i> biter leses.
 Det tilhørende heltallet gir en indeks til tabellen <code>tegntabell</code>.
 Hvis indeksen ikke hører til en indre node, finner vi tegnet i tabellen.
 Hvis den hører til en indre node, finne vi høyden til det tilhørende treet og det
 sier hvor mange biter vi skal lese i neste innlesning. Videre finner vi
 hvilken av tabellene til <code>tegntabeller</code> som vi da skal slå opp.
 Har vi lest for mange biter legges de overflødige tilbake.
 Hvis tegnet er lik vaktposttegnet, teller vi opp. Osv:
</p>

<pre>  BitOutputStream ut = <span class="keyword">new</span> BitOutputStream(tilFil);  <span class="comment">// for utskrift</span>
  <span class="keyword">int</span> frekvens = 0;   <span class="comment">// forekomster av vaktposttegnet</span>

  <span class="keyword">for</span>(;;)
  {
    <span class="keyword">int</span> lest = inn.readBits(m);               <span class="comment">// leser m biter</span>
    <span class="keyword">int</span> tall = tegntabell[lest] &amp; 255;        <span class="comment">// slår opp i tegntabellen</span>

    <span class="keyword">if</span> (lest &lt; grense)                        <span class="comment">// lest gir en indre node</span>
    {
      <span class="keyword">byte</span>[] b = tegntabeller[lest];          <span class="comment">// finner rett tabell</span>
      lest = inn.readBits(tall);              <span class="comment">// leser flere biter</span>
      tall = b[lest] &amp; 255;                   <span class="comment">// slår opp i tabellen</span>
    }

    <span class="comment">// tall er nå ascii-verdien til et tegn</span>

    <span class="keyword">if</span> (tall == vaktpost)
    {
      <span class="keyword">if</span> (++frekvens == vaktpostfrekvens) <span class="keyword">break</span>;
    }

    ut.write(tall);                           <span class="comment">// skriver ut tegnet</span>

    inn.unreadBits(tilbake[tall]);            <span class="comment">// legger biter tilbake</span>
  }

  ut.close();    <span class="comment">// lukker ut-filen</span></pre>

<p>
 I dette avsnittet behandler vi først hele det kanoniske treet under ett. Da
 holder det med å lage én tegntabell og bruke kun én bit-innlesing for hvert tegn.
 Men tabellen kan bli stor hvis største bitkodelengde <i>n</i> er stor. En annen teknikk
 er å dele treet på midten. Da bruker vi flere tegntabeller, men sammenlagt bruker
 de dramatisk mindre plass en den ene store tabellen. Ulempen er at vi får én ekstra
 sammenligning <code>lest &lt; grense</code>. Men den vil sjelden være sann. I vårt
 eksempel er den sann for kun én prosent av innlesningene. Dette er en helt marginal kostnad.
 Derfor bør vi alltid bruke todelingsteknikken. Det å sette alt sammen til en metode for
 todelingsteknikken gis som <i>Oppgave</i> xx.
</p>

<br/>

<a name="oppg.5.4.10"></a>
<div>
<a tabindex="-1" href="fasit5410.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.10</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>xxx
 </td></tr>
</table>

<div class="sideskift"></div>

<!-- ////// 5.4.11 /////////////////////// -->

<p><a name="5.4.11" tabindex="11"></a>
<a tabindex="-1" href="#5.4.12"><img class="icon" src="../../images/kvadrat.gif"
 alt="Til Avsnitt 5.4.12 - Den adaptive Huffmanteknikken"
 title="Til Avsnitt 5.4.12 - Den adaptive Huffmanteknikken" width="25" height="25" /></a>
<b>&nbsp; 5.4.11 &nbsp;Huffmans metode med begrenset bitkodelengde</b><br/>
</p>

<p>
 <a tabindex="-1" href="http://en.wikipedia.org/wiki/Package-merge_algorithm">The Package-merge-algorithm</a>.
</p>


<a name="oppg.5.4.11"></a>
<div>
<a tabindex="-1" href="fasit5411.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.11</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
 <td>xxx
 </td></tr>
</table>


<div class="sideskift"></div>

<!-- ////// 5.4.12 /////////////////////// -->


<p><a name="5.4.12" tabindex="12"></a>
<a tabindex="-1" href="#5.4.13"><img class="icon" src="../../images/kvadrat.gif"
 alt="Til Avsnitt 5.4.13 - Algoritmeanalyse"
 title="Til Avsnitt 5.4.13 - Algoritmeanalyse" width="25" height="25" /></a>
<b>&nbsp; 5.4.12 &nbsp;Den adaptive Huffmanteknikken</b><br/>

Den statiske Huffmanteknikken krever at frekvensfordelingen for tegnene i
den &laquo;meldingen&raquo; som
skal komprimeres, er kjent. Hvis ikke må &laquo;meldingen&raquo;
leses en gang først. Under komprimeringen må den så leses på nytt.
Det er selvfølgelig uheldig med to innlesinger hvis det å lese
tar lang tid. Det vil også være situasjoner der det ikke
er mulig å lese &laquo;meldingen&raquo; to ganger og da kan ikke denne teknikken brukes.
</p>

<p>
 I den adaptive (eller dynamiske) Huffmanteknikken bygges Huffmantreet fortløpende mens
 &laquo;meldingen&raquo; leses. For hvert tegn som leses er det to muligheter:
</p>

 <ol>
  <li>Hvis tegnet finnes fra før, brukes bitkoden som treet gir. Deretter økes tegnets
  frekvens og treet oppdateres slik at det blir et korrekt Huffmantre.</li>
  <li>Hvis tegnet er nytt, skrives det først ut et &laquo;signal&raquo; (en spesiell bitkode)
      og så tegnets ordinære bitkode (ascii-kode). I tillegg legges det nye tegnet inn i treet.</li>
 </ol>

<p>
Hvis denne teknikken skal virke, må vi for det første ha en regel som forteller når
et tre er et korrekt Huffmantre og for det andre en algoritme som på en forholdsvis
effektiv måte vil oppdatere et korrekt Huffmantre til et tre som fortsatt er korrekt.
</p>

<a name="figur.5.4.12.a-c"></a>
<table class="vbilde">
<tr>
<td align="center"><img src="images/5412a.png" alt="Et tomt Huffmantre" title="Et tomt Huffmantre" /></td>
</tr>
<tr>
<td>Figur 5.4.12 a) : Tomt tre</td>
</tr>
<tr>
<td align="center"><img src="images/5412b.png" alt="Et Huffmantre med ett tegn" title="Et Huffmantre med ett tegn" /></td>
</tr>
<tr>
<td>Figur 5.4.12 b) : E er satt inn</td>
</tr>
<tr>
<td><img src="images/5412c.png" alt="Et Huffmantre med 6 forskjellige tegn" title="Et Huffmantre med 6 forskjellige tegn" /></td>
</tr>
<tr>
<td>Figur 5.4.12 c) : Totalt 14 tegn</td>
</tr>
</table>

<p>
 Anta som eksempel at teksten <span class="character">"EDEAEEFECDAFDB"</span> utgjør første
 del av en melding. På forhånd har vi et &laquo;tomt&raquo; Huffmantre, dvs. et tre som
 kun består av &laquo;nullnoden&raquo;. Den skal representere tegn som ennå ikke har
 blitt observert og har dermed frekvens lik 0. Se <i>Figur</i> 5.4.12 <i>a)</i> til venstre.
</p>

<p>
<i>E</i> er første tegn. Når det legges inn får vi
<i>Figur</i> 5.4.12 <i>b)</i>. Det kan ses på som et Huffmantre siden rotnodens frekvens er summen av
barnas frekvenser og venstre barns frekvens er mindre enn eller lik høyre
barns frekvens. Nodene er nummerert slik at nummerrekkefølgen gir avtagende frekvenser. Her blir
det 0, 1 og 2 med frekvenser 1, 1 og 0.
</p>

<p>
Vi trenger et litt større tre for å kunne forklare gangen i oppdateringen.
Anta at hvert av de 13 øvrige tegnene i meldingen er lagt inn
og at treet har blitt oppdatert etter hver innlegging. Resultatet er
<i>Figur</i> 5.4.12 <i>c)</i>. Vi ser at frekvensen i hver indre node er lik summen av
barnas frekvenser og at nummerrekkefølgen 0, 1, . . 12 (i dette tilfellet svarer det til
<a tabindex="-1" href="../1/kap51.html#def.5.1.8.a">speilvendt nivåorden</a>)
gir avtagende frekvenser, dvs. 14, 9, 5, 5, 4, 3, 2, 2, 2, 1, 1, 1, 0.
</p>

<p>
La <i>p</i> og <i>q</i> være to noder i treet. Vi sier at <i>p</i> kommer foran
<i>q</i> hvis <i>p</i> har et lavere plassnummer enn <i>q</i>. Videre sier vi at <i>p</i> er den
første (eller den minste) noden i en samling noder hvis <i>p</i> har det laveste
plassnummeret. Ta f.eks. alle nodene som har frekvens 1 i
<i>Figur</i> 5.4.12 <i>c)</i>, dvs. nodene på plassene 9, 10 og 11. Da er det
noden på plass 9 (bokstaven <i>C</i>) som er den første (eller den minste) av dem.
Noden på plass 6 (bokstaven <i>A</i>) er den første av de som har frekvens 2.
</p>

<p>
Anta at <i>B</i> er neste tegn i meldingen. Vi må først avgjøre om <i>B</i> ligger i treet.
I vårt eksempel - <i>Figur</i> 5.4.12 <i>c)</i> - ligger <i>B</i>
i noden på plass 11. Den skal nå bytte plass med den <i>første</i> av de
som har samme frekvens (dvs. 1) som <i>B</i>-noden, dvs. med noden på plass 9 (bokstaven
<i>C</i>). Etter flyttingen økes frekvensen med 1. <i>Figur</i> 5.4.12 <i>d)</i> viser resultatet:
</p>

<a name="figur.5.4.12.d-e"></a>
<table class="mbilde">
<tr>
 <td><img src="images/5412d.png" alt="B og C har bytte plass" title="B og C har bytte plass" /></td>
 <td style="width: 60px">&nbsp;</td>
 <td><img src="images/5412e.png" alt="Nodene på plass 5 og 7 er byttet" title="Nodene på plass 5 og 7 er byttet" /></td>
</tr>
<tr>
 <td>Figur 5.4.12 d) :<br/> <i>B</i> og <i>C</i> har byttet plass</td>
 <td>&nbsp;</td>
 <td>Figur 5.4.12 e) : <br/> To noder har byttet plass</td>
</tr>
</table>

<p>
Neste skritt er å gå til forelderen til den som nettopp ble flyttet, dvs.
til noden på plass 8. Se <i>Figur</i> 5.4.12 <i>d)</i>. Den skal bytte
plass med den <i>første</i> av de nodene som har samme frekvens. Dvs.
noden på plass 8 flyttes til plass 6 (og omvendt). Etter flyttingen økes frekvensen med 1.
Se <i>Figur</i> 5.4.12 <i>e)</i> over.
Legg merke til at en node flyttes ved at hele treet til noden flyttes.
</p>

<p>
På nytt går vi til forelderen til noden som ble flyttet (noden på plass 6),
dvs. til noden på plass 3. Se
<a tabindex="-1" href="#figur.5.4.12.d-e"><i>Figur</i> 5.4.12 <i>e)</i></a> over.
Den skal som vanlig byttes med den <i>første</i> av de nodene som har samme frekvens, dvs.
frekvens 5. Med andre ord skal den byttes med noden på plass 2 (bokstaven <i>E</i>).
Frekvensen økes med 1. Så går vi til dens
forelder, men siden det er rotnoden er vi ferdig. Til slutt økes rotnodens
frekvens med 1. Se <i>Figur</i> 5.4.12 <i>f)</i> under:
</p>

<a name="figur.5.4.12.f"></a>
<table class="mbilde">
<tr>
 <td><img src="images/5412f.png" alt="Nodene på plass 2 og 3 er byttet" title="Nodene på plass 2 og 3 er byttet" /></td>
</tr>
<tr>
 <td>Figur 5.4.12 f) : Nodene på plass 2 og 3 er byttet</td>
</tr>
</table>

<p>
 Legg merke til at det bare er noder med samme frekvens som bytter plass. Det betyr
 at etter hver ombytting vil frekvensen i hver indre node fortsatt være summen av
 frekvensene til nodens to barn. Etter en ombytting økes frekvensen med 1 i den første
 av nodene med samme frekvens. Det betyr dens frekvens fortsatt blir mindre enn eller
 lik frekvensen i den noden som kommer rett foran i rekkefølgen. Med andre ord vil
 frekvensene fortsatt komme i avtagende rekkefølge med hensyn på nodenes nummerrekkefølge.
</p>

<p>
Vi må ta hensyn til et spesialtilfelle: Anta at tegnet <i>C</i> skal inn i treet
i <a tabindex="-1" href="#figur.5.4.12.f"><i>Figur</i> 5.4.12 <i>f)</i></a>.
Da starter vi i noden på plass 11. Men den <i>første</i> av de som har samme frekvens
(frekvens 1), er noden på plass 10, dvs. foreldernoden. I et slikt tilfelle skal det
ikke skje en ombytting. Vi øker isteden frekvensen og går rett til foreldernoden
på plass 10. Den er <i>først</i> blant de med samme frekvens, men å bytte den med seg
selv er helt unødvendig. Vi øker frekvensen og går så rett
til foreldernoden, dvs noden på plass 6. Den må byttes med noden på plass 5 og så få sin frekvens økt.
Det hele fortsetter i dens forelder, dvs. noden på plass 2. Den er &laquo;enslig&raquo;, dvs.
den er alene om å ha den frekvensen den har. Dermed kun frekvensøkning, men ingen ombytting.
Dens forelder er rotnoden og etter at vi har økt dens frekvens, er vi ferdig.
<i>Figur</i> 5.4.12 <i>g)</i> under viser resultatet:
</p>

<a name="figur.5.4.12.g"></a>
<table class="mbilde">
<tr>
 <td><img src="images/5412g.png" alt="En forekomst av C er lagt inn" title="En forekomst av C er lagt inn" /></td>
</tr>
<tr>
 <td>Figur 5.4.12 g) : En ny forekomst av <i>C</i></td>
</tr>
</table>

<p>
Hvis det er et nytt tegn, blir det litt annerledes.
I <i>Figur</i> 5.4.12 <i>g)</i> inngår
bokstavene <i>A</i>&thinsp;, <i>B</i>&thinsp;, <i>C</i>&thinsp;, <i>D</i>&thinsp;,
<i>E</i> og <i>F</i>. Anta at
<i>G</i> skal inn. Det gjøres ved at <i>nullnoden</i> på plass 12 blir en indre node
med frekvens 1, med bokstaven <i>G</i> som høyre barn og en ny <i>nullnode</i> som venstre barn.
Så går vi rett til forelderen til den gamle <i>nullnoden</i>, dvs. til
noden på plass 10. Se <a tabindex="-1" href="#figur.5.4.12.h"><i>Figur</i> 5.4.12 <i>g)</i></a>.
Derfra er oppdateringen som før. Noden bytter plass med den på plass 7 og frekvensen økes.
Så går vi til dens forelder på plass 4, osv. <i>Figur</i> 5.4.12 <i>h)</i> viser resultatet:
</p>

<a name="figur.5.4.12.h"></a>
<table class="mbilde">
<tr>
 <td><img src="images/5412h.png" alt="G er lagt inn" title="G er lagt inn" /></td>
</tr>
<tr>
 <td>Figur 5.4.12 h) : <i>G</i> er lagt inn som nytt tegn</td>
</tr>
</table>

<p>
Legg merke til at når et helt nytt tegn legges inn, får treet to nye noder. Det betyr at hvis treet
inneholder <i>n</i> forskjellige tegn vil det ha 2<i>n</i> + 1 noder. Treet i
<i>Figur</i> 5.4.12 <i>h)</i> har 7 forskjellige tegn og 2&middot;7 + 1 = 15 noder
(nummerert fra 0 til 14).
</p>

<p>
OBS. Første gang det legges inn et tegn, dvs. når vi starter med et tomt Huffmantre, blir det som
<a tabindex="-1" href="#figur.5.4.12.a-c"><i>Figur</i> 5.4.12 <i>b)</i></a> viser.
</p>

<p>
 Et prefikskodetre med frekvenser har <b>søskenegenskapen</b> (eng: the sibling property)
hvis:
</p>

<ol>
<li>Frekvensen i hver indre node er lik summen av frekvensene til
de to barna.</li>
<li>Nodene kan nummereres i avtagende rekkefølge med hensyn på frekvens. I nummereringen
skal alltid det venstre barnet i et søskenpar følge rett etter det høyre barnet og
forelderen alltid ha et nummer som kommer foran disse.</li>
</ol>

<p>
Det kan bevises at et prefikskodetre som har søskenegenskapen, er et Huffmantre. Legg
merke til at treet i <a tabindex="-1" href="#figur.5.4.12.h"><i>Figur</i> 5.4.12 <i>h)</i></a>
har søskenegenskapen. Det samme har alle de andre trærne vi har tegnet. Algoritmen
beskrevet over sørger for at denne egenskapen bevares ved hver oppdatering.
</p>

<p>
I alle trærne som er tegnet svarer nummereringen til <i>speilvendt
nivåorden</i>. Den starter i roten (nr. 0) og går nedover nivå for nivå og for hvert nivå
fra <b>høyre</b> mot venstre. Men kravet i søskenegenskapen er ikke fullt så strengt.
Algoritmen sørger for at egenskapen bevares, men ikke nødvendigvis at nummereringen
er i speilvendt nivåorden. Se <a tabindex="-1" href="#oppg.5.4.12"><i>Oppgave</i> 3</a>.
Men det vil hele tiden være slik at frekvensene
kommer i avtagende rekkefølge både i denne spesielle nummereringen og i speilvendt
nivåorden selv om de to kan være forskjellige.
</p>

<p>
Beskrivelsen over svarer til det som kalles  FGK-algoritmen (etter
<a tabindex="-1" href="http://en.wikipedia.org/wiki/Newton_Faller">Newton Faller</a>,
<a tabindex="-1" href="http://en.wikipedia.org/wiki/Robert_G._Gallager">Robert Gallager</a>
og <a tabindex="-1" href="http://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>).
En forskjell er at når FGK-algortimen beskrives, er det vanlig å nummerere
nodene motsatt vei. I en slik nummerering  kommer <i>nullnoden</i> først og rotnoden sist.
Ulempen er at alle nodene må renummereres når det kommer inn nye
noder. Alternativt kan en la rotnoden fra starten av få et stort nummer. Anta at
&laquo;meldingen&raquo; kun kan inneholde ascii-tegn (tallverdier fra 0 til 255). Det
betyr at treet kan ha maksimalt 256 bladnoder og dermed maksimalt 513 noder. Dermed
kunne rotnoden få nummer 512 og de øvrige nummereres nedover. I treet i
<a tabindex="-1" href="#figur.5.4.12.h"><i>Figur</i> 5.4.12 <i>h)</i></a> ville
da <i>nullnoden</i> bli nummer 498.
</p>

<div>
<a name="figur.5.4.12.i"></a>
<table class="vbilde" cellspacing="0" cellpadding="0">
<tr><td><img src="images/5412i.png" alt="Et Huffmantre" title="Et Huffmantre" /></td></tr>
<tr><td>Figur 5.4.12 i) : Huffmantre med 15 noder</td></tr>
</table>

I treet i figuren til venstre står frekvensen inne i noden, nodenummeret
ved siden av og tegnet under hver bladnode. En nodestruktur
må derfor ha variabler for <code>frekvens</code>, <code>tegn</code> og <code>nummer</code>,
og som ellers variabler for <code>venstre</code> og <code>høyre</code> barn.
</div>

<p>
Hvis to noder skal bytte plass, gjøres det implisitt ved at nodene bytter foreldre.
Noden må derfor ha <code>forelder</code> som variabel. Et ledd i algoritmen er
at en node skal bytte plass med den første av de som har samme frekvens. Ta
f.eks. noden på plass 11 i treet til venstre. Den første av de med frekvens 2 er den på
plass 8. Hvordan skal vi på en effektiv måte kunne finne den ved å starte fra
plass 11? Det kan f.eks. løses ved hjelp av en nodetabell med pekere til hver node
i treet. Hvis tabellindeksen til en peker og nummeret til noden den peker på er like,
blir det effektivt.
</p>

<a name="kode.5.4.12.a"></a>
<pre>  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> Node          <span class="comment">// en indre nodeklasse</span>
  {
    <span class="keyword">private</span> <span class="keyword">int</span> frekvens;                  <span class="comment">// nodens frekvens</span>
    <span class="keyword">private</span> <span class="keyword">int</span> c;                         <span class="comment">// nodens tegn</span>
    <span class="keyword">private</span> <span class="keyword">int</span> nummer;                    <span class="comment">// nodens nummer</span>
    <span class="keyword">private</span> Node forelder;                 <span class="comment">// peker til forelder</span>
    <span class="keyword">private</span> Node venstre = <span class="keyword">null</span>;           <span class="comment">// peker til venstre barn</span>
    <span class="keyword">private</span> Node høyre = <span class="keyword">null</span>;             <span class="comment">// peker til høyre barn</span>

    <span class="keyword">private</span> Node(<span class="keyword">int</span> frekvens, <span class="keyword">int</span> c, <span class="keyword">int</span> nummer, Node forelder)
    {
      <span class="keyword">this</span>.frekvens = frekvens;
      <span class="keyword">this</span>.c = c;
      <span class="keyword">this</span>.nummer = nummer;
      <span class="keyword">this</span>.forelder = forelder;
    }
  }  <span class="comment">// Node</span>
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>a)</i></span></b></pre>

<p>
Tabellen <code>noder</code> under har 15 verdier. Den kobles til treet
i <a tabindex="-1" href="#figur.5.4.12.i"><i>Figur</i> 5.4.12 <i>i)</i></a>&thinsp; ved at
<code>noder[0]</code> peker til roten, <code>noder[1]</code> til den på plass 1, osv.
til <code>noder[14]</code> som peker til <i>nullnoden</i>.
</p>

<table class="sentrert-tabell-20" cellspacing="0" cellpadding="3">
<tr>
<td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
<td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
<td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td>
</tr>
<tr>
<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
<td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
<td>10</td><td>11</td><td>12</td><td>13</td><td>14</td>
</tr>
<tr>
<td colspan="15">Figur 5.4.12 k) : En tabell som skal koblet til treet i Figur 5.4.12 j)</td>
</tr>
</table>

<p>
 En node har et eksplisitt nummer (variablen <code>nummer</code>) og et implisitt
 nummer (det samme tallet) gjennom sin plassering i tabellen <code>noder</code>. Vi finner
 den første av de som har samme frekvens som <i>p</i> ved å slå opp i tabellen
 med <code>p.nummer</code> som indeks. Derfra leter vi mot venstre.
 To noder <i>p</i> og <i>q</i> bytter plass ved at de implisitt bytter plass i treet
 (bytter foreldre) og eksplisitt ved at de bytter plass i tabellen. Nodene må også
 bytte (interne) nummer:
</p>

<a name="kode.5.4.12.b"></a>
<pre>  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> bytt(Node p, Node q, Node[] noder)
  {
    Node f = p.forelder, g = q.forelder;  <span class="comment">// finner foreldrene</span>

    <span class="keyword">if</span> (p == f.venstre) f.venstre = q;    <span class="comment">// f får q som barn</span>
    <span class="keyword">else</span> f.høyre = q;

    <span class="keyword">if</span> (q == g.høyre) g.høyre = p;        <span class="comment">// g får p som barn</span>
    <span class="keyword">else</span> g.venstre = p;

    p.forelder = g;                <span class="comment">// p får g som forelder</span>
    q.forelder = f;                <span class="comment">// q får f som forelder</span>

    noder[q.nummer] = p;           <span class="comment">// p flyttes til plassen til q</span>
    noder[p.nummer] = q;           <span class="comment">// q flyttes til plasen til p</span>

    <span class="keyword">int</span> nummer = p.nummer;         <span class="comment">// p og q bytter nummer</span>
    p.nummer = q.nummer;
    q.nummer = nummer;
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>b)</i></span></b></pre>

<p>
Tabellen <code>tegn</code> skal være slik at
hvis <code>'A'</code> er i treet, skal <code>tegn['A']</code> peke på noden til
<code>'A'</code>. Hvis <code>'B'</code> ikke er der, skal <code>tegn['B']</code> være
<i>null</i>. Siden alle ascii-tegn kan forekomme, får den 257 (256 + 1) som
dimensjon. Tegnet <i>EOC</i> = 256 står for &laquo;End of Compression&raquo;:
</p>

<a name="kode.5.4.12.c"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">class</span> AdHuffman     <span class="comment">// adaptiv Huffman</span>
  {
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EOC = 256;   <span class="comment">// End of Compression</span>

    <span class="comment">// Nodeklassen fra <a tabindex="-1" href="#kode.5.4.12.a"><i>Programkode</i> 5.4.12 <i>a)</i></a> skal inn her</span>

    <span class="keyword">private</span> Node rot, NULL;         <span class="comment">// pekere til rotnoden og nullnoden</span>
    <span class="keyword">private</span> Node[] noder;           <span class="comment">// nodetabell for nodene</span>
    <span class="keyword">private</span> Node[] tegn;            <span class="comment">// nodetabell for tegn</span>
    <span class="keyword">int</span> antall = 0;                 <span class="comment">// antall noder i treet</span>

    <span class="keyword">public</span> AdHuffman()              <span class="comment">// kontruktør - lager et tomt tre</span>
    {
      rot = NULL = <span class="keyword">new</span> Node(0,-1,0,<span class="keyword">null</span>);   <span class="comment">// rotnoden er lik nullnoden</span>
      noder = <span class="keyword">new</span> Node[2*8 + 1];            <span class="comment">// plass til 17 noder (8 tegn)</span>
      noder[antall++] = rot;                <span class="comment">// roten legges i posisjon 0</span>
      tegn = <span class="keyword">new</span> Node[257];                 <span class="comment">// alle ascii-verdier + EOC</span>
    }

    <span class="comment">// Metoden bytt fra <a tabindex="-1" href="#kode.5.4.12.b"><i>Programkode</i> 5.4.12 <i>b)</i></a> skal inn her</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>c)</i></span></b></pre>

<p>
Et nytt tegn <i>c</i> legges som høyre barn til <i>nullnoden</i>. Barnet legges
på første ledige plass i nodetabellen og i <code>tegn[c]</code>.
Venstre barn blir ny nullnode og legges i nodetabellen på neste
ledige plass. Se beskrivelsen mellom <a tabindex="-1" href="#figur.5.4.12.g"><i>Figur</i> 5.4.12 <i>g)</i></a>
og <a tabindex="-1" href="#figur.5.4.12.h"><i>Figur</i> 5.4.12 <i>h)</i></a>.
Det må være samsvar mellom nodenumrene og plasseringene i nodetabellen:
</p>

<a name="kode.5.4.12.d"></a>
<pre>  <span class="keyword">private</span> Node nyttTegn(<span class="keyword">int</span> c)                    <span class="comment">// et nytt tegn</span>
  {
    <span class="keyword">if</span> (antall == noder.<span class="variable">length</span>)                   <span class="comment">// er tabellen full?</span>
    {
      noder = Arrays.copyOf(noder,2*antall - 1);  <span class="comment">// dobler</span>
    }

    Node p = NULL;                          <span class="comment">// p settes lik nullnoden</span>

    p.høyre = <span class="keyword">new</span> Node(1,c,antall,p);       <span class="comment">// ny node som høyre barn</span>
    tegn[c] = p.høyre;                      <span class="comment">// noden inn i tegn-tabellen</span>
    noder[antall++] = p.høyre;              <span class="comment">// noden inn i nodetabellen</span>

    p.venstre = <span class="keyword">new</span> Node(0,-1,antall,p);    <span class="comment">// ny node som venstre barn</span>
    noder[antall++] = p.venstre;            <span class="comment">// noden inn i nodetabellen</span>

    NULL = p.venstre;                       <span class="comment">// ny nullnode</span>

    <span class="keyword">if</span> (p == rot) <span class="keyword">return</span> p;                 <span class="comment">// returnerer roten</span>

    p.frekvens = 1;                         <span class="comment">// frekvens lik 1</span>
    <span class="keyword">return</span> p.forelder;
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>d)</i></span></b></pre>

<p>
Nå har vi de byggestenene som trengs for å lage en oppdateringsmetode, dvs. en metode
som enten øker frekvensen til et eksistrende tegn eller som legger inn et nytt tegn,
og som deretter oppdaterer treet slik som beskrevet i første del av dette
avsnittet:
</p>

<a name="kode.5.4.12.e"></a>
<pre>  <span class="keyword">private</span> <span class="keyword">void</span> oppdater(<span class="keyword">int</span> c)
  {
    Node p = tegn[c];                  <span class="comment">// slår opp i tegntabellen</span>
    <span class="keyword">if</span> (p == <span class="keyword">null</span>) p = nyttTegn(c);    <span class="comment">// er det et nytt tegn?</span>

    <span class="keyword">while</span> (p != rot)                   <span class="comment">// går fra p og opp mot roten</span>
    {
      <span class="comment">// sammenligner p med noden rett foran</span>
      <span class="keyword">if</span> (noder[p.nummer - 1].frekvens == p.frekvens)
      {
        <span class="keyword">int</span> k = p.nummer - 1;          <span class="comment">// leter videre mot venstre</span>
        <span class="keyword">while</span> (noder[k-1].frekvens == p.frekvens) k--;

        Node q = noder[k];                      <span class="comment">// q er minst</span>
        <span class="keyword">if</span> (q != p.forelder) bytt(p,q,noder);   <span class="comment">// p og q bytter plass</span>
      }

      p.frekvens++;                             <span class="comment">// øker frekvensen</span>
      p = p.forelder;                           <span class="comment">// går til forelderen</span>
    }
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>e)</i></span></b></pre>

<p>
Ytterste while-løkke i <i>Programkode</i> 5.4.12 <i>e)</i> stopper når <i>p</i>
kommer til roten. Men frekvensen økes ikke. Det betyr at rotnodens frekvens blir stående på 0.
Dermed kan den brukes som en &laquo;vaktpost&raquo;. Den innerste while-løkken inneholder
<i>k--</i> og det er situasjoner der <i>k</i> da kan bli negativ. Se på situasjonen etter at
det første tegnet er lagt inn slik som i
<a tabindex="-1" href="#figur.5.4.12.a-c"><i>Figur</i> 5.4.12 <i>b)</i></a>. Hvis det samme
tegnet (bokstaven <i>E</i>) skal legges inn en gang til, vil letingen etter den første
blant de som har frekvens 1 kunne bringe oss ut av tabellen. Men det kan ikke skje nå siden
rotnodens frekvens er 0. Derfor trengs ingen sammenligning
av typen <code>k &gt; 0</code> for å stoppe while-løkken. Hvis det var nødvendig å vite
hva rotnodens frekvens skulle ha vært hvis den hadde vært oppdatert på vanlig måte, er
det bare å legge sammen barnas frekvenser.
</p>

<p>
Hvis vi skal skrive ut nodene i et tre for å sjekke at ting stemmer, kan det være
lurt å ha en <code>toString</code>-metode i nodeklassen. Hvis meldingen inneholder
&laquo;usynlige&raquo; tegn, kan vi legge tabellen <i>ascii</i> fra
<a tabindex="-1" href="#kode.5.4.6.f"><i>Programkode</i> 5.4.6 <i>f)</i></a> inn i
<code>class ADHuffman</code>. Metoden kan da lages slik:
</p>

<a name="kode.5.4.12.f"></a>
<pre>  <span class="keyword">public</span> String toString()
  {
    String s = <span class="character">"("</span> + nummer + <span class="character">","</span> + frekvens;
    <span class="keyword">if</span> (c &gt;= 0)  <span class="comment">// bladnoder har c = -1</span>
    {
      <span class="keyword">if</span> (c &lt; 32) s += <span class="character">","</span> + ascii[32];
      <span class="keyword">else</span> s += <span class="character">","</span> + (<span class="keyword">char</span>)c;
    }
    <span class="keyword">return</span> s + <span class="character">")"</span>;
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>f)</i></span></b></pre>

<p>
Flg. metode bygger opp et tre ved hjelp av &laquo;melding&raquo; i form av en tegnstreng og
skriver ut nodenes innhold i nummerrekkefølge:
</p>

<a name="kode.5.4.12.g"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> skrivTre(String melding)
  {
    AdHuffman h = <span class="keyword">new</span> AdHuffman();             <span class="comment">// lager et tomt tre</span>

    <span class="keyword">char</span>[] tegn = melding.toCharArray();       <span class="comment">// gjør om til en tegntabell</span>
    <span class="keyword">for</span> (<span class="keyword">char</span> c : tegn) h.oppdater(c);         <span class="comment">// bygger opp treet</span>

    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i &lt; h.antall; i++)         <span class="comment">// skriver ut nodene</span>
      System.out.print(h.noder[i] + <span class="character">" "</span>);
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>g)</i></span></b></pre>

<p>
All den koden som er laget til nå, ligger på
<a tabindex="-1" href="AdHuffman1.html"><code>class AdHuffman</code></a>. Hvis du flytter den
over til ditt system, vil flg. kodebit skrive ut nodene i treet fra
<a tabindex="-1" href="#figur.5.4.12.a-c"><i>Figur</i> 5.4.12 <i>c)</i></a>.
I &laquo;utskriften&raquo; er bare de åtte første nodene tatt med.
Se også <a tabindex="-1" href="#oppg.5.4.12"><i>Oppgave</i> 2</a>.
</p>

<a name="kode.5.4.12.h"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)
  {
    AdHuffman.skrivTre(<span class="character">"EDEAEEFECDAFDB"</span>);
  }

  <span class="comment">// Utskrift: (0,0) (1,9) (2,5,E) (3,5) (4,4) (5,3,D) (6,2,A) (7,2,F) . . .</span>

              <b><span class="code"><i>Programkode</i> 5.4.12 <i>h)</i></span></b></pre>

<p>
<b>Bitkoder</b>&nbsp; For hvert tegn i meldingen må det avgjøres om
det er et helt nytt tegn eller om tegnet har forekommet tidligere. Hvis
tegnet er nytt skal først bitkoden til <i>nullnoden</i> skrives ut og
deretter tegnet på vanlig form (ascii-verdi). Hvis tegnet har forkommet før,
skrives bitkoden til tegnet slik det ligger i treet.
</p>

<p>
Problemet er at treet endrer seg etter hvert som vi leser tegn og oppdaterer treet.
Dermed vil både <i>nullnoden</i> og bladnodene kunne skifte plasser. Bitkoden
til et tegn er gitt ved veien fra roten ned til tegnet. Men den veien vil endre
seg når treet endrer seg. Det betyr at vi må finne denne veien på nytt for hvert
tegn vi leser. Et oppslag i tabellen <code>tegn</code> gir oss direkte aksess til den bladnoden
som inneholder tegnet. Derfor er det enklest og mest effektivt å gå motsatt vei, dvs.
fra noden og opp til roten. Da finner vi imidlertid bitene i en rekkefølge som er
motsatt av den vi må ha, men det fikser vi.
</p>

<p>
La <code>biter</code> og <code>lengde</code> være en int-variabler og <i>p</i>
en nodepeker. Vi starter med at alle bitene i <code>biter</code> er 0 og at
<code>lengde</code> er 0. For hver node oppover skyves bitene i
<code>biter</code> en enhet mot høyre. Da kommer det inn en 0-bit fra venstre.
Hvis <i>p</i> er et venstre barn, så lar vi 0-biten stå. Men hvis <i>p</i> derimot
er et høyre barn, må vi ersatte den med en 1-bit. Til det bruker vi
tallet <code>0x80000000</code>, dvs. tallet som har en 1-bit lengst til venstre og
resten 0-biter:
</p>

<a name="kode.5.4.12.i"></a>
<pre>  lengde++;                 <span class="comment">// lengden øker med 1</span>
  biter &gt;&gt;&gt;= 1;             <span class="comment">// skyver inn en 0-bit fra venstre</span>
  <span class="keyword">if</span> (p.forelder.høyre == p) biter |= 0x80000000;  <span class="comment">// er p et høyre barn?</span>
  p = p.forelder;

              <b><span class="code"><i>Programkode</i> 5.4.12 <i>i)</i></span></b></pre>

<p>
Når vi kommer til roten, vil tegnets bitkode ligge i venstre del av <code>biter</code> og
<code>lengde</code> sier hvor mange det er. Da kan vi bruke metoden
<code>writeLeftBits</code> fra klassen <code>BitOutputStream</code>.
Den skriver ut så mange biter fra venstre i <code>biter</code> som <code>lengde</code>
sier.
</p>

<p>
Hvis det er et helt nytt tegn, skal som nevnt bitkoden til <i>nullnoden</i> skrives ut og
deretter tegnet. Da dukker det opp et problem. Helt til slutt kan vi stå igjen med
færre enn 8 biter. Da legges det på ekstra 0-biter for å få en full byte.
Vi trenger derfor en &laquo;vaktpost&raquo;
som som sier fra når &laquo;våre&raquo; biter slutter. Det må være et tegn som
helt sikkert ikke forekommer i meldingen, f.eks. tegnet med ascii-verdi 256 og som vi har
kalt <i>EOC</i> (eng: end of compression). <i>EOC</i> har imidlertid 9 biter og dermed må
også alle andre tegn skrives ut med 9 istedenfor de normale 8 bitene. Kostnaden er 1 ekstra
bit for hvert av de ulike tegnene. Men det utgjør lite siden det maksimalt kan
være 256 forskjellige tegn, normalt vesentlig færre:
</p>

<a name="kode.5.4.12.j"></a>
<pre>  <span class="keyword">private</span> <span class="keyword">void</span> skrivBitkode(<span class="keyword">int</span> c, BitOutputStream ut) <span class="keyword">throws</span> IOException
  {
    <span class="keyword">int</span> biter = 0, lengde = 0;
    Node blad = tegn[c];

    Node p = blad != <span class="keyword">null</span> ? blad : NULL;  <span class="comment">// p tegnnode eller nullnoden</span>

    <span class="keyword">while</span> (p != rot)    <span class="comment">// går oppover mot roten</span>
    {
      lengde++;
      biter >>>= 1;
      <span class="keyword">if</span> (p.forelder.høyre == p) biter |= 0x80000000;
      p = p.forelder;
    }

    ut.writeLeftBits(biter,lengde);
    <span class="keyword">if</span> (blad == <span class="keyword">null</span>) ut.writeBits(c,9);  <span class="comment">// tegnet med 9 biter</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>j)</i></span></b></pre>

<p>
Metoden <code><b>komprimer</b></code> henter tegn fra en fil og skriver resultatet
til en annen fil. For hvert tegn som leses sørger metoden
<code>skrivBitkode</code> for å få ut bitene og metoden <code>oppdater</code>
for å legge tegnet inn i Huffmantreet:
</p>

<a name="kode.5.4.12.k"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>
  komprimer(String fraUrl, String tilFil) <span class="keyword">throws</span> IOException
  {
     InputStream inn =
      <span class="keyword">new</span> BufferedInputStream((<span class="keyword">new</span> URL(fraUrl)).openStream());  <span class="comment">// inn</span>

     BitOutputStream ut = <span class="keyword">new</span> BitOutputStream(tilFil);          <span class="comment">// ut</span>

    AdHuffman h = <span class="keyword">new</span> AdHuffman();   <span class="comment">// oppretter et tomt Huffmantre</span>

    <span class="keyword">int</span> c = 0;
    <span class="keyword">while</span> ((c = inn.read()) != -1)   <span class="comment">// leser til filslutt</span>
    {
      h.skrivBitkode(c,ut);          <span class="comment">// skriver ut bitkoden</span>
      h.oppdater(c);                 <span class="comment">// oppdaterer Huffmantreet</span>
    }

    h.skrivBitkode(EOC,ut);          <span class="comment">// Vaktpost: End of Compression</span>

    inn.close(); ut.close();         <span class="comment">// lukker filene</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>k)</i></span></b></pre>

<p>
<b>Dekomprimeringen</b> foregår på en tilsvarende måte som for den statiske
Huffmanteknikken. Bitene leses en for en og ved hjelp av dem kommer vi ned
til en bladnode i treet. Hvis det er <i>nullnoden</i>, vil de 9 neste bitene
representere et helt nytt tegn. Hvis ikke, innholder bladnoden det aktuelle
tegnet. Tegnet skrives ut, treet oppdateres og vi fortsetter inntil
&laquo;vaktposten&raquo; <i>EOC</i> kommer:
</p>

<a name="kode.5.4.12.l"></a>
<pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>
  dekomprimer(String fraUrl, String tilFil) <span class="keyword">throws</span> IOException
  {
    BitInputStream inn =
      <span class="keyword">new</span> BitInputStream((<span class="keyword">new</span> URL(fraUrl)).openStream());      <span class="comment">// inn</span>

    OutputStream ut =
      <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(tilFil));  <span class="comment">// ut</span>

    AdHuffman h = <span class="keyword">new</span> AdHuffman();         <span class="comment">// et tomt Huffmantre</span>

    <span class="keyword">for</span> (Node p = h.rot; ; p = h.rot)      <span class="comment">// starter i roten</span>
    {
      <span class="keyword">while</span> (p.venstre != <span class="keyword">null</span>)            <span class="comment">// er p er en bladnode?</span>
      {
        <span class="keyword">if</span> (inn.readBit() == 0)
          p = p.venstre;                   <span class="comment">// til venstre ved 0-bit</span>
        <span class="keyword">else</span>
          p = p.høyre;                     <span class="comment">// til høyre ved 1-bit</span>
      }

      <span class="keyword">int</span> c = p.c;                         <span class="comment">// tegnet i noden</span>
      <span class="keyword">if</span> (c == -1) c = inn.readBits(9);    <span class="comment">// er p lik nullnoden?</span>

      <span class="keyword">if</span> (c == EOC) <span class="keyword">break</span>;                 <span class="comment">// End of Compression</span>
      ut.write(c);                         <span class="comment">// skriver ut tegnet</span>
      h.oppdater(c);                       <span class="comment">// oppdaterer Huffmantreet</span>
    }

    inn.close(); ut.close();               <span class="comment">// lukker filene</span>
  }
              <b><span class="code"><i>Programkode</i> 5.4.12 <i>l)</i></span></b></pre>

<p>
Hvis du legger <code>skrivBitkode</code>, <code>komprimer</code> og <code>dekomprimer</code>
inn i <a tabindex="-1" href="AdHuffman1.html"><code>class AdHuffman</code></a>, vil
flg. programbit kunne kjøres:
</p>

<a name="kode.5.4.12.m"></a>
<pre>  String fraUrl = <span class="character">"http://www.iu.hio.no/~ulfu/appolonius/kap1/3/kap13.html"</span>;
  AdHuffman.komprimer(fraUrl,<span class="character">"ut.txt"</span>);

              <b><span class="code"><i>Programkode</i> 5.4.12 <i>m)</i></span></b></pre>

<p>
I siste del av <a tabindex="-1" href="#5.4.8"><i>Avsnitt</i> 5.4.8</a> fant vi at
metoden i <a tabindex="-1" href="#kode.5.4.8.f"><i>Programkode</i> 5.4.8 <i>f)</i></a>
(den statiske Huffmanteknikken) komprimerte filen
<a tabindex="-1" href="../../kap1/3/kap13.html"><i>Delkapittel</i> 1.3</a>
ned til 207.538 byter. Hvis en kikker på filen <span class="character">"ut.txt"</span>,
vil en se at den er på 207.631 byter. Dette er imidlertid noen få byter mer, men til gjengjeld
leser den adaptive Huffmanteknikken filen kun én gang. Se
<a tabindex="-1" href="#oppg.5.4.12"><i>Oppgave</i> 5</a>.
Sjekk at dekomprimeringsmetooden virker som den skal - se
<a tabindex="-1" href="#oppg.5.4.12"><i>Oppgave</i> 6</a>.
</p>

<p>
<b>Effektivitet</b> Anta at &laquo;meldingen&raquo; innholder tilsammen <i>n</i> tegn derav
<i>k</i> forskjellige. I den adaptive Huffmanteknikken bygges treet fortløpende
og for hvert tegn er treet et Huffmantre for de tegnene som er lest inntil da.
Hvis alle de <i>k</i> tegnene forekommer like ofte, vil treet kunne være nær perfekt med
en gjennomsnittlig bitkodelengde for de leste tegnene på omtrent log<sub>2</sub>&thinsp;<i>k</i>.
Men hvis det er skjev fordeling vil gjennomsnittlig bitkodelengde være mindre enn det.
Det betyr at både komprimeringen og dekomprimeringen vil være av orden
<i>n</i>&thinsp;log<sub>2</sub>&thinsp;<i>k</i>. I vanlige tilfeller er <i>k</i> svært mye mindre
enn <i>n</i> og da vil metodene i praksis være av orden <i>n</i>.
</p>

<p>
 <span class="error">Det kommer her stoff om Vitters adaptive Huffmanteknikk.</span>
</p>

<a name="oppg.5.4.12"></a>
<div>
<a tabindex="-1" href="fasit5412.html"><img class="icon" src="images/blaakule.jpg"
  alt="Til fasit" title="Til fasit" width="20" height="20"/></a>
<b>&nbsp; Oppgaver til Avsnitt 5.4.12</b>
</div>

<table class="oppgave">
 <tr><td>1.</td>
  <td>Start med et tomt tre og legg så inn bokstavene <i>A</i>, <i>B</i>, <i>C</i>
  og <i>D</i> slik som beskrevet i første del av dette avsnittet. Hvordan ser treet
  ut? Lag en tegning. Bygg det videre ut med <i>E</i>, <i>A</i> og <i>A</i>.
  Tegn treet. Avslutt med å legge inn <i>B</i>, <i>D</i>, <i>B</i>, <i>E</i>
  og <i>F</i>. Tegn treet.
 </td></tr>

 <tr><td>2.</td>
 <td>Ta <a tabindex="-1" href="AdHuffman1.html"><code>class AdHuffman</code></a>
 over til deg og lag et program som kjører
 <a tabindex="-1" href="#kode.5.4.12.h"><i>Programkode</i> 5.4.12 <i>h)</i></a>. Det
 andre tallet i hver parentes er frekvensen. Sjekk at de (bortsett fra den første som er
 rotnoden) kommer i avtagende rekkefølge. Gjør om
 <a tabindex="-1" href="#kode.5.4.12.g"><i>Programkode</i> 5.4.12 <i>g)</i></a>
 slik at det blir korrekt frekvens også i utskriften av rotnoden.
 Husk at rotnodens frekvens skal være lik summen av barnas frekvenser. Gjør om
 <a tabindex="-1" href="#kode.5.4.12.h"><i>Programkode</i> 5.4.12 <i>h)</i></a> slik
 at du får treet/trærne fra <i>Oppgave</i> 1.
 </td></tr>

 <tr><td>3.</td>
 <td>Lag en metode <code>public static void skrivTre2(String melding)</code> som
 skriver ut nodene slik som
 <a tabindex="-1" href="#kode.5.4.12.g"><i>Programkode</i> 5.4.12 <i>g)</i></a> gjør, men
 skriver dem i <i>speilvendt nivåorden</i>. Da må du bruke en kø.
 Sjekk at det da blir samme utskriftsrekkefølge for "EDEAEEFECDAFDB" som
 i <a tabindex="-1" href="#kode.5.4.12.g"><i>Programkode</i> 5.4.12 <i>g)</i></a>.
 Blir det samme rekkefølge hvis du bruker "ABCDEAA"?
 </td></tr>

 <tr><td>4.</td>
 <td>Vi har tidligere sett på den statiske Huffmanteknikken. Frekvensfordelingen
 i <a tabindex="-1" href="#tabell.5.4.1"><i>Tabell</i> 5.4.1</a> førte da til
 Huffmantreet til høyre i <a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>.
 Lag en tegnstreng med 100 tegn med bokstavene fra <i>A</i> til <i>H</i> slik at det blir
 denne frekvensfordelingen. Kjør så <a tabindex="-1" href="#kode.5.4.12.g"><i>Programkode</i> 5.4.12 <i>g)</i></a>
 med denne tegnstrengen. Sammenlign resultatet med
 <a tabindex="-1" href="#figur.5.4.3.e"><i>Figur</i> 5.4.3 <i>e)</i></a>.
 </td></tr>

 <tr><td>5.</td>
  <td>I den adaptive Huffmanteknikken legges det ikke ut noen informasjon i starten av
  komprimeringen slik som i den statiske Huffmanteknikken. Likevel blir resultatet
  en fil som er litt større. Hva tror du er årsaken?
 </td></tr>

 <tr><td>6.</td>
  <td>Legg inn <a tabindex="-1" href="#kode.5.4.12.j"><i>Programkode</i> 5.4.12 <i>j)</i></a>,
  <a tabindex="-1" href="#kode.5.4.12.k"><i>Programkode</i> 5.4.12 <i>k)</i></a> og
  <a tabindex="-1" href="#kode.5.4.12.l"><i>Programkode</i> 5.4.12 <i>l)</i></a> i
  <a tabindex="-1" href="AdHuffman1.html"><code>class AdHuffman</code></a> og kjør programmet
  i <a tabindex="-1" href="#kode.5.4.12.m"><i>Programkode</i> 5.4.12 <i>m)</i></a>. Sjekk
  størrelsen på filen <span class="character">"ut.txt"</span>. Lag en programbit der
  <span class="character">"ut.txt"</span> dekomprimeres. Da må du bruke dens url.
  Sjekk at resultatet blir korrekt.
 </td></tr>

 <tr><td>7.</td>
  <td>Bruk både den statiske og adaptive Huffmanteknikken på noen filer som inneholder
  få forskjellige tegn. Hvem av dem komprimerer best i slike tilfeller?
 </td></tr>

 <tr><td>8.</td>
  <td>
 </td></tr>

</table>

<div class="sideskift"></div>


<!-- ////// 5.4.13 /////////////////////// -->


<p><a name="5.4.13" tabindex="13"></a>
<a tabindex="-1" href="#"><img class="icon" src="../../images/kvadrat.gif"
 alt="Til starten på Delkapittel 5.4"
 title="Til starten på Delkapittel 5.4" width="25" height="25" /></a>
<b>&nbsp; 5.4.13 &nbsp;Algoritmeanalyse</b><br/>

Et <b>alfabet</b> defineres som en vilkårlig samling av forskjellige "tegn". Hva
slags tegn det er snakk om spiller ingen rolle, men for oss vil det være nærliggende
å tenke på en samling ascii-tegn. Vi sier at <i>alfabetet</i> har <b>prefikskoder</b> hvis
det til hvert tegn i <i>alfabetet</i> er tilordnet en bitkode, dvs, en sekvens med biter (0 og 1),
slik at ingen tegn har en bitkode som utgjør første delen av bitkoden for et annet tegn.
En <b>bitkodelengde</b> er antallet biter i en bitkode.
</p>

<p>
Prefikskodene til et <i>alfabet</i> kan representeres som veier i et binærtre. Treet har
da nøyaktig like mange <i>bladnoder</i> som det er tegn og hvert tegn er tilknyttet
en bladnode. Veien fra rotnoden til bladnoden representerer prefikskoden - en 0 når
vi går til venstre og en 1 til høyre. Se f.eks. <i>figur 5.4.2 a)</i>. Et slikt tre
kalles et <b>prefikskodetre</b>.  I <i>avsnitt 5.4.2</i> ble det krevd at
et prefikskodetre måtte være fullt, men det er egentlig for strengt. Ethvert binærtre
med like mange bladnoder som det er tegn i <i>alfabetet</i>, definerer et sett med
prefikskoder. Men vi skal straks se at et prefikskodetre som ikke er fullt, er av liten
interesse for oss.
</p>

<p>
Vi sier at <i>alfabetet</i> har en <b>frekvensfordeling</b> hvis det til hvert tegn er tilordnet
en <b>frekvens</b> (et positivt heltall). Hvis <b><i>T</i></b> er et prefikskodetre
til et <i>alfabet</i> med en gitt frekvensfordeling, så skal <b><i>B(T)</i></b> betegne
bitsummen, dvs. summen av produktene av frekvens og bitkodelengde for hvert tegn.
Se <i>avsnitt 5.4.2</i>.
</p>

<p>
Hvis vi tar for oss alle mulige prefikskodetrær <b><i>T</i></b> for et <i>alfabet</i> med
en gitt frekvensfordeling, så vil minst et av dem gi minst mulig verdi på
<b><i>B(T)</i></b>. Et slikt tre kalles et <b>optimalt</b> prefikskodetre.
</p>

<p>
<b>Lemma 5.4.13 a)</b> &nbsp;<i>Et optimalt prefikskodetre er fullt</i>.
</p>

<p>
<b>Bevis</b> &nbsp;Hvis et optimalt prefikskodetre <i>T</i> ikke er fullt,
må det være en indre node som har kun ett barn. Denne noden kan vi fjerne ved at den
erstattes av sitt barn. Da vil alle tegn/bladnoder i det tilhørende subtreet få bitkoder
som er kortere enn før og dermed vil <i>B(T)</i> bli mindre. Men det er
umulig siden <i>T</i> er optimalt.
</p>

<p>
<b>Lemma 5.4.13 b)</b> &nbsp;<i>La x og y være to bladnoder/tegn i et optimalt
prefikskodetre med frekvenser f(x) og f(y). La l(x) og l(y) være bitkodelengdene.
Hvis f(x) &lt; f(y), så er l(x) &lt;= l(y)</i>.
</p>

<p>
<b>Bevis</b> &nbsp;Anta omvendt at det finnes bladnoder/tegn <i>x</i> og <i>y</i>
slik at <i>f(x) &lt; f(y)</i> og <i>l(x) &gt; l(y)</i>. Da vil produktet
<i>(f(y) - f(x))(l(x) - l(y))</i> være større enn 0. La <i>T'</i> være
det treet vi får ved å bytte om <i>x</i> og <i>y</i>, dvs. <i>x</i> får bitkoden
og frekvensen til <i>y</i> og omvendt. Da vil <i>B(T')</i> =
<i>B(T)</i> - <i>f(x)l(x)</i> - <i>f(y)l(y)</i> + <i>f(x)l(y)</i>
+ <i>f(y)l(x)</i> = <i>B(T)</i> + <i>(f(y) - f(x))(l(x) - l(y))</i> &gt; <i>B(T)</i>.
Men dette er i strid med forutsetningen at <i>B(T)</i> er optimalt. Dermed må
<i>l(x) &lt;= l(y)</i>.
</p>

<p>
 <span class="error">Det kommer mer stoff her.</span>
</p>

<br/>
<br/>

<a tabindex="-1" href="http://validator.w3.org/check?uri=referer">
<img style="border:0;width:88px;height:31px;" src="../../valid-xhtml10-blue.png"
alt="Valid XHTML 1.0 Strict" title="Valid XHTML 1.0 Strict" /></a>


<p id="copyright"></p>


</div>
</body>
</html>
