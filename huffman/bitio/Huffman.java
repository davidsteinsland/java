/**
 * Huffman Trees
 */
package bitio;
import java.io.BufferedInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.io.IOException;
import java.util.Comparator;
import java.util.Queue;
import java.util.PriorityQueue;
import java.util.Iterator;
 
public class Huffman
{	
	private static class Node
	{
		private int frequency;
		private Node left;
		private Node right;
		
		private Node ()
		{ }
		
		private Node (int f, Node l, Node r)
		{
			this.frequency = f;
			this.left = l;
			this.right = r;
		}
	}
	
	private static class LeafNode extends Node
	{
		private char character;
		
		private LeafNode (char c, int f)
		{
			super (f, null, null);
			this.character = c;
		}
	}
	
	private static class FrequencyComparator implements Comparator<Node>
	{
		public int compare (Node p, Node q)
		{
			return p.frequency - q.frequency;
		}
	}
	
	/* First 32 chars in the ascii table */
	public static String[] ascii = {
		"NUL","SOH","STX","ETX", "EOT","ENQ","ACK","BEL","BS","HT","LF",	
		"VT","FF","CR","SO","SI","DLE","DC1","DC2","DC3","DC4","NAK",
		"SYN","ETB","CAN","EM","SUB","ESC","FS","GS","RS","US"
	};
	
	public Huffman ()
	{	
	}
	
	/**
	 * Returns the root in the Huffman tree
	 * generated by the frequency table given
	 */
	private static Node buildHuffmanTree (int[] freq)
	{
		Comparator<Node> c = new FrequencyComparator();
		Queue<Node> queue = new PriorityQueue<Node>(freq.length, c);
		
		for (int i = 0; i < freq.length; i++)
			if (freq[i] > 0)
				queue.offer (new LeafNode((char)i, freq[i]));
			
		if ( queue.size() < 2)
			throw new IllegalArgumentException ("Too few characters");
			
		while ( queue.size() > 1 )
		{
			Node left = queue.poll();
			Node right = queue.poll();
			
			int sum = left.frequency + right.frequency;
			queue.offer (new Node (sum, left, right));
		}
		
		return queue.poll();
	}
	
	public static void findBitcodes (Node p, String code, String[] codes)
	{
		if ( p instanceof LeafNode )
			codes[((LeafNode)p).character] = code;
		else
		{
			// add '0' when going left
			findBitcodes (p.left, code + '0', codes);
			// add '1' when traversing right
			findBitcodes (p.right, code + '1', codes);
		}
	}
	
	/**
	 * Finds the bitcode lengths for each node,
	 * i.e. the same value as the length of the bitcodes
	 * returned by Huffman.findBitcodes().
	 * But it is faster to have a method in which the lengths
	 * becomes values in an integer table.
	 */
	public static void findLengths (Node p, int length, int[] lengths)
	{
		if ( p.left == null )
			lengths[((LeafNode)p).character] = length;
		else
		{
			findLengths (p.left, length + 1, lengths);
			findLengths (p.right, length + 1, lengths);
		}
	}
	
	public static int[] findBitcodes (int[] lengths)
	{
		// number of characters of each length
		int[] leaves = new int[32];
		
		for (int length : lengths)
			if (length < 32)
				leaves[length]++;
			else throw new IllegalStateException ("Bitcode length > 31!");
		
		int[] pos = new int[32];
		for (int k = 31; k > 0; k--)
			pos[k - 1] = (pos[k] + leaves[k]) / 2;
		
		int[] bitcodes = new int[lengths.length];
		
		for (int i = 0; i < bitcodes.length; i++)
			if (lengths[i] > 0)
				bitcodes[i] = pos[lengths[i]]++;
		return bitcodes;
	}
	
	public static String[] bitcodes (int[] freq)
	{
		Node root = buildHuffmanTree(freq);
		String[] bitcodes = new String[freq.length];
		findBitcodes (root, "", bitcodes);

		return bitcodes;
	}
	
	public static int[] frequency (String text)
	{
		int[] frequency = new int[256];
		for (int i = 0, length = text.length(); i < length; i++)
			frequency[text.charAt(i)]++;
		return frequency;
	}
	
	public static int[] frequency (InputStream in)
		throws IOException
	{
		int[] freq = new int[256];
		for (int c = 0; (c = in.read()) != -1; freq[c]++);
		in.close();
		
		return freq;
	}
	
	public static int numberOfBinaryDigits (int k)
	{
		return k == 0 ? 0 : 32 - Integer.numberOfLeadingZeros(k);
	}
	
	public static int compress (InputStream in, OutputStream out)
		throws IOException
	{
		if ( in.markSupported() == false )
			throw new IllegalStateException ("Cannot reset InputStream");
		
		int[] freq = frequency (in);
		in.reset();
		
		Node root = buildHuffmanTree (freq);
		
		int[] lengths = new int[freq.length];
		findLengths (root, 0, lengths);
		
		int[] bitcodes = findBitcodes (lengths);
		
		BitOutputStream bitOut = new BitOutputStream (out);
		
		int numBits = 0, read = 0;
		while ( (read = in.read()) != -1 )
		{
			bitOut.writeBits ( bitcodes[read], lengths[read] );
			numBits += lengths[read];
		}
		
		in.close();
		bitOut.close();
		
		return numBits;
	}
	
	private static int max (int[] a)
	{
		int m = 0;               // indeks til største verdi
		int max = a[0];    // største verdi

		for (int i = 1; i < a.length; i++) 
			if (a[i] > max)
			{
				max = a[i];
				m = i;
			}
		return m;
	}
	
	public static void compress (String fromUrl, String toFile)
		throws IOException
	{
		InputStream in = new BufferedInputStream (new URL(fromUrl).openStream());
		
		int[] freq = frequency (in);
		Node root = buildHuffmanTree (freq);
		
		int[] lengths = new int[freq.length];
		findLengths (root, 0, lengths);
		
		int[] bitcodes = findBitcodes (lengths);
		
		int guard = max (lengths);
		int k = numberOfBinaryDigits (lengths[guard]);
		
		BitOutputStream out = new BitOutputStream (toFile);
		out.writeBits (k, 3);
		
		for (int length : lengths )
			if (length == 0)
				out.write0Bit();
			else
				out.writeBits ( length | 1 << k, k + 1);
		
		int s = numberOfBinaryDigits (freq[guard]);
		out.writeBits (s, 5);
		out.writeBits (freq[guard], s);
		
		in = new BufferedInputStream ( (new URL (fromUrl)).openStream());
		
		int read = 0;
		while ( (read = in.read()) != -1 )
			out.writeBits (bitcodes[read], lengths[read]);
		
		out.writeBits (bitcodes[guard], lengths[guard]);
		
		in.close();
		out.close();
	}
	
	public static void decompress (String fromUrl, String toFile)
		throws IOException
	{
		BitInputStream in = new BitInputStream ((new URL(fromUrl)).openStream());
		
		int k = in.readBits(3);
		int[] lengths = new int[256];
		
		for (int i = 0; i < lengths.length; i++)
			if ( in.readBit() == 1 )
				lengths[i] = in.readBits(k);
		
		int guard = max (lengths);
		
		int s = in.readBits(5);
		int guardFrequence = in.readBits(s) + 1;
		
		Node root = buildCanonicalTree (lengths);
		BitOutputStream out = new BitOutputStream (toFile);
		int freq = 0;
		
		for (Node p = root; ; p = root)
		{
			while (p.left != null)
				p = in.readBit() == 0 ? p.left : p.right;

			if (((LeafNode)p).character == guard && ++freq == guardFrequence)
				break;
			
			out.write(((LeafNode)p).character);
		}
		
		out.close();
		in.close();
	}
	
	/* According to tests, this method is actually the fastest */
	public static void decompressEfficient (String fromUrl, String toFile)
		throws IOException
	{
		BitInputStream in = new BitInputStream ((new URL(fromUrl)).openStream());
		
		int k = in.readBits(3);
		int[] lengths = new int[256];
		
		for (int i = 0; i < lengths.length; i++)
			if ( in.readBit() == 1 )
				lengths[i] = in.readBits(k);
		
		int guard = max (lengths);
		
		int s = in.readBits(5);
		int guardFrequence = in.readBits(s) + 1;
		
		int n = lengths[guard];
		int[] back = new int[lengths.length];
		byte[] charArray = makeCharArray (lengths, back, n);
		
		BitOutputStream out = new BitOutputStream (toFile);
		int freq = 0;
		
		while (true)
		{
			int character = charArray[in.readBits(n)] & 255;
			if (character == guard && ++freq == guardFrequence)
				break;
			out.write (character);
			in.unreadBits(back[character]);
		}
		
		out.close();
		in.close();
	}
	
	public static void decompressMoreEfficient (String fromUrl, String toFile) throws IOException
	{
		BitInputStream in = new BitInputStream((new URL(fromUrl)).openStream());

		int k = in.readBits(3);
		int[] lengths = new int[256];

		for (int i = 0; i < lengths.length; i++)
			if (in.readBit() == 1)
				lengths[i] = in.readBits(k);

		int guard = max(lengths);

		int s = in.readBits(5);
		int guardfrequency = in.readBits(s) + 1;

		int n = lengths[guard];
		int[] leaves = new int[n + 1];

		for (int i : lengths)
			if (i > 0) leaves[i]++;

		int[] bitcodes = findBitcodes(lengths);

		int m = (n + 1)/2;
		byte[] charArray = new byte[1 << m];

		int[] heights = treeHeight(leaves, m);
		int limit = heights.length;

		for (int i = 0; i < limit; i++)
			charArray[i] = (byte)heights[i];

		int[] back = new int[lengths.length];

		byte[][] charArrays = new byte[limit][];

		for (int i = 0; i < limit; i++)
			charArrays[i] = new byte[1 << heights[i]];

		for (int i = 0; i < lengths.length; i++)
		{
			int length = lengths[i];

			if (length > 0)
			{
				if (length <= m)
				{
					int d = m - length;
					back[i] = d;

					int from = bitcodes[i] << d;
					int to = from + (1 << d);

					for (int j = from; j < to; j++)
						charArray[j] = (byte)i;
				}
				else
				{
					int code = bitcodes[i];
					int d1 = length - m;

					int code1 = code >> d1;
					int code2 = code & ((1 << d1) - 1);

					byte[] b = charArrays[code1];

					int d2 = charArray[code1] - d1;
					back[i] = d2;

					int from = code2 << d2;
					int to = from + (1 << d2);

					for (int j = from; j < to; j++) 
						b[j] = (byte)i;
				}
			}
		}

		BitOutputStream out = new BitOutputStream(toFile);
		int freq = 0;

		for(;;)
		{
			int read = in.readBits(m);
			int number = charArray[read] & 255;

			if (read < limit)
			{
				byte[] b = charArrays[read];
				read = in.readBits(number);
				number = b[read] & 255;
			}
			
			if (number == guard && ++freq == guardfrequency)
				break;

			out.write(number);
			in.unreadBits(back[number]);
		}

		out.close();
		in.close();
	}
	
	private static Node buildCanonicalTree (int[] lengths)
	{
		int[] bitcodes = findBitcodes (lengths);
		Node root = new Node();
		
		for (int i = 0; i < lengths.length; i++)
		{
			if (lengths[i] > 0)
			{
				int n = bitcodes[i];
				int k = (1 << lengths[i]) >> 1;
				Node p = root;
				
				while (k > 1)
				{
					if ((k & n) == 0)
					{
						if ( p.left == null )
							p.left = new Node();
						p = p.left;
					}
					else
					{
						if (p.right == null)
							p.right = new Node();
						p = p.right;
					}
					
					k >>= 1;
				}
				
				if ((n & 1) == 0)
					p.left = new LeafNode ((char)i, 0);
				else
					p.right = new LeafNode ((char)i, 0);
			}
		}
		
		return root;
	}
	
	public static byte[] makeCharArray(int[] lengths, int[] back, int n)
	{
		int[] bitcodes = findBitcodes(lengths);

		byte[] charArray = new byte[1 << n];

		for (int i = 0; i < lengths.length; i++)
		  if (lengths[i] > 0)
		  {
				int d = n - lengths[i];
				back[i] = d;
				int from = bitcodes[i] << d;
				int to = from + (1 << d);

				for (int j = from; j < to; j++)
					charArray[j] = (byte)i;
			}
		
		return charArray;
	}
	
	public static int[] treeHeight(int[] leaves, int level)
	{
		int n = leaves.length;
		int[] nodes = new int[n];
		nodes[n-1] = leaves[n-1];

		for (int k = n - 1; k > level; k--)
		  nodes[k - 1] = nodes[k]/2 + leaves[k-1];

		int max = nodes[max(nodes)];

		int[] hights = new int[max];
	
		for (int i = n - 2; i >= level; i--)
		{
			int k = nodes[i] - leaves[i];
		  
			for (int j = 0; j < k; j++)
				hights[j] = Math.max(hights[2*j], hights[2*j+1]) + 1;
			
			for (int j = k; j < nodes[i+1]; j++)
				hights[j] = 0;
		}

		int[] h = new int[nodes[level] - leaves[level]];
		System.arraycopy(hights, 0, h, 0, h.length);

		return h;
	}
}