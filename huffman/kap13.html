Algoritmer og datastrukturer
Kapittel 1 - Delkapittel 1.3 

1.3 Ordnede tabeller 

1.3.1 Partisjonering
Vi kan gruppere verdiene i en tabell, dvs. dele dem opp i intervaller etter 
bestemte kriterier. Dette kalles å partisjonere (eng: partition) tabellen. 

Eksempel 1.3.1 a): Flg. tabell inneholder kun tallene 0 og 1: 
0 0 1 0 0 1 0 1 1 0 0 1 1 1 0 1 0 1 1 0 

Her ønsker vi å få omorganisert verdiene slik at alle 0-ene kommer først. Dermed 
får vi partisjonert tabellen i to - første del inneholder bare 0-er og andre del 
bare 1-ere. Vi kan få det til ved å sortere tabellen, men det er å «skyte spurv 
med kanon». En slik partisjonering bør kunne gjøres på en langt mer effektiv 
måte. 

Eksempel 1.3.1 b): Flg. tabell inneholder 20 tall i området fra 1 til 25: 
8 3 15 13 1 9 20 3 18 2 6 25 14 8 20 16 5 21 11 14 

Også her vil vi ha tabellen delt i to: Venstre del skal inneholde tall med ett 
siffer (alle tall mindre enn 10) og resten (de med to siffer) i høyre del. Vi 
setter ingen krav til hvordan tallene er fordelt innen hver av de to delene. 
Målet er å få det gjort med minst mulig innsats. 

Eksempel 1.3.1 c): Flg. tabell inneholder kun bokstavene R, H og B: 
H B R B H H R B R H B R H R R B H B H R 

Her ønsker vi å omorganisere tabellen slik at R-ene kommer først, så H-ene og 
til slutt B-ene. Tabellen blir dermed tredelt. Det å gjøre dette på en mest 
mulig effektiv måte er kjent som «Det hollandske flaggproblemet» (eng: The Dutch 
National Flag Problem). Her står bokstavene R, H og B for flaggfargene rød, hvit 
og blå. 

Todelt partisjonering Målet er å lage en algoritme som omorganiserer en 
heltallstabell slik at alle verdier som er mindre enn en skilleverdi kommer 
først. Vi kan bruke Eksempel 1.3.1 b) som utgangspunkt, men idéen vil også virke 
for Eksempel 1.3.1 a). Tabellen kan, men behøver ikke, inneholde selve 
skilleverdien. I Eksempel 1.3.1 b) var målet å få alle tall med ett siffer først. 
Da passer 10 som skilleverdi og 10 ligger ikke i tabellen. To indekser v og h 
starter i hver sin ende av tabellen. I figuren har vi latt hele tabellen få grå 
bakgrunn: 
8 3 15 13 1 9 20 3 18 2 6 25 14 8 20 16 5 21 11 14 
v                   h 
Figur 1.3.1 a) : Indeksene v og h starter i hver sin ende 

Partisjoneringsprosessen starter ved at indeks v flyttes mot høyre så lenge som 
tilhørende tabellverdi er mindre enn skilleverdien 10. Da vil v stoppe ved 
tallet 15. Så flyttes h mot venstre så lenge som tilhørende tabellverdi er 
større enn eller lik skilleverdien 10. Da vil h stoppe ved tallet 5. De verdiene 
som v og h har passert får hvit bakgrunn. Se figuren under: 
8 3 15 13 1 9 20 3 18 2 6 25 14 8 20 16 5 21 11 14 
v              h    
Figur 1.3.1 b) : v er flyttet mot høyre og h mot venstre 

Idéen i partisjoneringsprosessen er å holde tabellen tredelt. Første (venstre) 
del (hvit bakgrunn) skal inneholde verdier mindre enn skilleverdien og siste (høyre) 
del (også hvit bakgrunn) verdier som er større enn (eller eventuelt lik) 
skilleverdien. Den midterste delen (grå bakgrunn) skal inneholde de «ukjente» 
verdiene, dvs. de verdiene som ennå ikke er undersøkt. Indeksene v og h skal 
hele tiden ligge i hver sin ende av den «ukjente» delen. 

I Figur 1.3.1 b) har indeksen v stoppet på en verdi (15) som er større enn 
skilleverdien og indeksen h på en (5) som er mindre enn skilleverdien. Hvis de 
to bytter plass vil 5 komme sammen med de som er mindre og 15 sammen med de som 
er større enn (eller lik) skilleverdien 10. Men da må også v flyttes en posisjon 
mot høyre og h en mot venstre for at de to skal ligge i hver sin ende av den «ukjente» 
delen. Figuren under viser resultatet: 
8 3 5 13 1 9 20 3 18 2 6 25 14 8 20 16 15 21 11 14 
v            h     
Figur 1.3.1 c) : «Ukjent» del har blitt redusert til 13 verdier etter kun én 
ombytting 

Nå står allerede v på en verdi (13) som er større enn 10 og kan dermed ikke 
flyttes videre mot høyre. Men h kan flyttes videre mot venstre til første verdi 
som er mindre enn 10: 
8 3 5 13 1 9 20 3 18 2 6 25 14 8 20 16 15 21 11 14 
v          h       
Figur 1.3.1 d) : Tallet 13 er større enn 10 og 8 mindre enn 10 

Verdiene til v og h (13 og 8) bytter plass, v og h flyttes en posisjon: 
8 3 5 8 1 9 20 3 18 2 6 25 14 13 20 16 15 21 11 14 
v        h        
Figur 1.3.1 e) : «Ukjent» del har fått 9 verdier etter to ombyttinger 

Prosessen fortsetter (se Oppgave 1) til den «ukjente» (grå) delen «forsvinner». 
Da vil v være posisjonen til den første av de som er større enn (eller lik) 
skilleverdien 10 og h posisjonen til den siste av de som er mindre enn 
skilleverdien. Med andre ord vil v og h ligge ved siden av hverandre, men med h 
til venstre for v. Sluttresultatet blir en tabell der alle tallene med ett 
siffer (tall mindre enn 10) kommer først og deretter alle med to siffer (større 
enn eller lik 10): 
8 3 5 8 1 9 6 3 2 18 20 25 14 13 20 16 15 21 11 14 
h v           
Figur 1.3.1 f) : Tabellen er partisjonert 

Legg merke til at det i tabellen i Figur 1.3.1 f) ikke er noen spesiell 
rekkefølge på tallene i venstre del (de mindre enn 10) og heller ingen spesiell 
rekkfølge på de i høyre del. 

Det er to spesialtilfeller vi må ta hensyn til når idéen over skal kodes. Hvis 
alle verdiene i tabellen er mindre enn skilleverdien, vil indeks v havne utenfor 
tabellen hvis den flyttes mot høyre så lenge tilhørende verdi er mindre enn 
skilleverdien. Omvendt vil h havne utenfor tabellen til venstre hvis alle 
verdiene er større enn eller lik skilleverdien. 

Flg. metode partisjonerer det lukkede tabellintervallet a[v:h]: 

  public static int parter(int[] a, int v, int h, int skilleverdi)
  {
    while (v <= h && a[v] < skilleverdi) v++;   // h er stoppverdi for v
    while (v <= h && skilleverdi <= a[h]) h--;  // v er stoppverdi for h

    while (true)
    {
      if (v < h) Tabell.bytt(a,v++,h--);   // bytter om a[v] og a[h]
      else  return v;                      // partisjoneringen er ferdig
      while (a[v] < skilleverdi) v++;      // flytter v mot høyre
      while (skilleverdi <= a[h]) h--;     // flytter h mot venstre
    }
  }
                 Programkode 1.3.1 a) 

Første linje inne i metoden i Programkode 1.3.1 a) inneholder v <= h. Det betyr 
at v vil stoppe på h + 1 hvis alle verdiene i a[v:h] er mindre enn skilleverdien. 
Omvendt vil h stoppe på v ? 1 hvis alle verdiene i a[v:h] er større enn eller 
lik skilleverdien. Hvis ingen av disse tilfellene er tilstede, vil første 
ombytting i løkken while (true) gi oss en stoppverdi (vaktpost) for a[v] og a[h] 
på hver side. Dermed kan vi fjerne v <= h i resten av algoritmen. 

Eksempel 1.3.1 d): Eksempel 1.3.1 a) og b) kan løses ved hjelp av Programkode 1.3.1 
a). Metoden må legges i samleklassen Tabell før flg. programbit er kjørbar: 

  int[] a = {0,0,1,0,0,1,0,1,1,0,0,1,1,1,0,1,0,1,1,0};

  Tabell.parter(a,0,a.length-1,1);    // bruker 1 som skilleverdi
  Tabell.skrivln(a);                  // se Oppgave 5 i Avsnitt 1.2.2

  int[] b = {8,3,15,13,1,9,20,3,18,2,6,25,14,8,20,16,5,21,11,14};

  Tabell.parter(b,0,b.length-1,10);   // bruker 10 som skilleverdi
  Tabell.skriv(b);                    // se Oppgave 4 i Avsnitt 1.2.2

  // Utskrift:

  // 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1
  // 8 3 5 8 1 9 6 3 2 18 20 25 14 13 20 16 15 21 11 14

              Programkode 1.3.1 b) 

Eksempel 1.3.1 e): Tabellen i Eksempel 1.3.1 b) ble brukt til å utlede 
algoritmen for partisjonering, men den inneholdt ikke selve skilleverdien. 
Tabellen i Figur 1.3.1 g) nedenfor inneholder en permutasjon av tallene fra 1 
til 20. Den skal partisjoneres med 11 som skilleverdi. Her kan en som en øvelse 
på papir og med penn finne hvilket resultat algoritmen vil gi. Fasit får en så 
ved å kjøre Programkode 1.3.1 c) under: 
4 3 17 10 6 20 1 11 15 8 18 9 2 7 19 13 5 14 16 12 
Figur 1.3.1 g) : Tabellen inneholder en permutasjon av tallene fra 1 til 20 

  int[] a = {4,3,17,10,6,20,1,11,15,8,18,9,2,7,19,13,5,14,16,12};
  Tabell.parter(a,11);    // bruker 11 som skilleverdi
  Tabell.skriv(a);

  // Utskrift: 4 3 5 10 6 7 1 2 9 8 18 15 11 20 19 13 17 14 16 12

              Programkode 1.3.1 c) 

I utskriften i Programkode 1.3.1 c) kommer, som forventet, de tallene som er 
mindre enn skilleverdien 11 (tallene fra 1 til 10) først og så resten av tallene 
(fra 11 til 20). Skilleverdien 11 vil havne i den andre delen, men nøyaktig hvor 
den vil havne avhenger av hvordan verdiene er fordelt på forhånd. Det vil være 
situasjoner der det er ønskelig at skilleverdien havner nøyaktig på grensen 
mellom de to delene. Det er det mulig å få til. Hvis det skjer er vi faktisk i 
gang med å sortere tabellen. Se Avsnitt 1.3.2. 

Eksempel 1.3.1 f): Programkode 1.3.1 a) kan ikke brukes til å løse problemet i 
Eksempel 1.3.1 c) siden det der inngår tegn og ikke heltall. Men en 
heltallstabell kan «tredeles» ved at Programkode 1.3.1 a) brukes to ganger. 
Eksempel: Tabellen i Figur 1.3.1 h) under inneholder 20 tall mellom 1 til 30. 
Målet er å få delt den i tre deler: første del tall med bare ett siffer, andre 
del de med to siffer og første siffer lik 1 og siste del resten av tallene: 
20 7 18 10 3 25 21 14 8 29 16 15 4 24 11 7 27 12 16 2 
Figur 1.3.1 h) : Tabellen skal tredeles 

Dette kan løses ved at vi først partisjonerer tabellen ved å bruke 10 som 
skilleverdi. Metoden returnerer indeksen til første tall som ikke er mindre enn 
10. Deretter partisjoner vi det tabellintervallet som inneholder tallene som 
ikke er mindre enn 10 med 20 som skilleverdi: 

  int[] a = {20,7,18,10,3,25,21,14,8,29,16,15,4,24,11,7,27,12,16,2};
  int v = Tabell.parter(a,10);          // bruker 10 som skilleverdi
  Tabell.parter(a,v,a.length-1,20);     // bruker 20 som skilleverdi
  Tabell.skriv(a);

  // Utskrift: 2 7 7 4 3 8 16 14 12 18 16 15 10 11 24 29 27 25 21 20

              Programkode 1.3.1 d) 

Det finnes mer effektive måter å tredele en tabell på enn å partisjonere to 
ganger. Både dette og den beste løsningen på Eksempel 1.3.1 c) («Det hollandske 
flaggproblemet») diskuteres nøye i Avsnitt 1.3.4. 

Effektivitet Hvor effektiv er partisjoneringsalgoritmen? Skilleverdien 
sammenlignes med alle verdiene i tabellen, dvs. n sammenligninger hvis tabellen 
har n verdier. Algoritmen er derfor av orden n med tanke på sammenligninger. Men 
hva med ombyttinger, dvs. kall på metoden bytt? For å gjøre analysen enklere 
antar vi at tabellen a inneholder en permutasjon av tallene fra 1 til n og at et 
av dem, for eksempel tallet s, brukes som skilleverdi. Etter partisjoneringen 
vil tallene som er mindre enn s (tallene fra 1 til s ? 1) havne først, dvs. på 
de s ? 1 første plassene. Det betyr at alle tall som ikke er mindre enn s blant 
de s ? 1 første i den opprinnelige tabellen, vil bli flyttet ved ombyttinger. 
Det gir flg. setning: 

Setning 1.3.1 a) La tabellen a inneholde en vilkårlig permutasjon av tallene fra 
1 til n og la s være et av dem. Da vil antallet tall blant de s ? 1 første som 
ikke er mindre enn s (dvs. større enn eller lik s), være det samme som antallet 
ombyttinger med s som skilleverdi i partisjoneringsalgoritmen. 

Se på tabellen i Eksempel 1.3.1 e). Den inneholder en permutasjon av tallene fra 
1 til 20. Skilleverdien s = 11. Vi ser at blant de s ? 1 = 10 første tallene er 
det fire tall (17, 20, 11 og 15) som ikke er mindre enn s. Dermed blir det fire 
ombyttinger. Legg merke til at vi kan snu dette på hodet. Antallet ombyttinger 
blir også lik antallet tall blant de n ? s + 1 siste som er mindre enn s. Flg. 
metode teller opp og finner antallet: 

  public static int antallBytt(int[] a, int s)
  {
    int antall = 0, m = s - 1;
    for (int i = 0; i < m; i++) if (a[i] > m) antall++;
    return antall;
  }
              Programkode 1.3.1 e) 

I programbiten nedenfor (Programkode 1.3.1 f??) lages en tilfeldig permutasjon 
av tallene fra 1 til n (n = 100). Så gir metoden antallBytt gi oss antallet 
ombyttinger for hver skilleverdi s fra 1 til n. Gjennomsnittet finnes ved at 
antallene summeres og at summen deles på n. Gjennomsnittet for denne bestemte 
permutasjonen skrives så ut: 

  int n = 100, antall = 0;
  int[] a = Tabell.randPerm(n);            // en tilfeldig permutasjon

  for (int s = 1; s <= n; s++) antall += antallBytt(a,s);

  System.out.println((double)antall/n);   // gjennomsnittet

              Programkode 1.3.1 f) 

Da Programkode 1.3.1 f) ved en anledning ble kjørt fem ganger, kom følgende 
resultater: 16.32, 17.54, 15.66, 15.88 og 16.13 med 16.3 som gjennomsnitt. Vi 
kunne (i teorien) finne det nøyaktige gjennomsnittet ved kjøre programmet for 
alle permutasjonene (100! stykker), men det er selvfølgelig umulig i praksis. 
Hvis vi isteden lar n = 10, så er det realistisk å prøve alle permutasjonene. Se 
Avsnitt 1.3.3. En matematisk analyse (se Avsnitt 1.3.18) gir imidlertid at 
gjennomsnittet er nøyaktig lik (n2 ? 1)/6n ? n/6. Med n = 100 blir det ?16.7. 

Setning 1.3.1 b) Det gjennomsnittlige antallet ombyttinger i algoritmen for 
partisjonering, der gjennomsnittet er over alle permutasjoner av tallene fra 1 
til n og over alle skilleverdier s fra 1 til n, er eksakt lik (n2 ? 1)/6n. 

Oppgaver til Avsnitt 1.3.1 
1. Tabellen i Figur 1.3.1 e) over viser resultatet av partisjoneringsalgoritmen 
etter to ombyttinger. Vis på figuren hvordan det blir etter tredje og fjerde 
ombytting.  
2. Gitt tabellen 7,10,3,4,1,6,8,2,9,5. Finn resultatet når 
partisjoneringsalgoritmen anvendes på tabellen og med 7 som skilleverdi! Bruk så 
5 som skilleverdi! Finn svaret først ved hjelp av «papir og penn». En «fasit» 
kan du få ved å tilpasse Programkode 1.3.1 c).  
3. Gitt tabellen 11,2,17,1,9,8,12,14,15,3,19,18,7,10,16,20,13,4,6,5. Som Oppgave 
2. Bruk først 6 som skilleverdi, så 10 og til slutt 15. 
4. Bruk Setning 1.3.1 a) til på forhånd å finne antallet ombyttinger for de 
ulike tilfellene i Oppgave 2 og Oppgave 3.  
5. Kjør Programkode 1.3.1 f) også for andre verdier av n enn 100. Prøv f.eks. 
med n lik 600, 6000 og 60000. Sammenlign utskriften med det teoretiske 
gjennomsnittet på n/6.  
6. Hvor mange ombyttinger skjer i partisjoneringsalgoritmen hvis tabellen 
inneholder en permutasjon av tallene fra 1 til n og 1 er skilleverdi? Hvor mange 
ombyttinger blir det i gjennomsnitt for alle permutasjoner av tallene fra 1 til 
n med n fast som skilleverdi.  
7. Flg. idé vil gi oss en annen algoritme for å partisjonere en tabell a (eller 
et tabellintervall): Vi starter med en indeks v lengst til venstre og en indeks 
h lengst til høyre i intervallet. Hvis a[v] er mindre enn skilleverdien, økes v 
med 1. Hvis ikke bytter tabellverdiene a[v] og a[h] plass og h reduseres med 1. 
Så sammenlignes a[v] og skilleverdien igjen. Osv. så lenge som v ? h. Til slutt 
skal metoden returnere v som vil være indeksen til den første av verdiene som 
ikke er mindre enn skilleverdien. Lag en metode som bruker denne idéen. Lag to 
versjoner - en som partisjonerer et tabellintevall og en som partisjonerer en 
hel tabell. Se Programkode 1.3.1 a). Hvor mange sammenligninger og ombyttinger 
er det i denne algoritmen. 
8. Flg. partisjoneringsalgoritme bruker ikke ombyttinger, men to tilordninger 
for å flytte tall til rett plass. Som utgangspunkt er indeks v lengst til 
venstre og indeks h lengst til høyre. Algoritmen starter med at verdien a[v] 
legges tilside i en hjelpevariabel. Dermed blir posisjon v ledig. Vi bruker en 
indeks k til å markere den ledige plassen. Indeks v flyttes én mot høyre. La 
tabellen fra Eksempel 1.3.1 e) være eksempel. Etter noen iterasjoner med 11 som 
skilleverdi, får vi flg. tabell:

Verdien 4 er lagt til side. Tabellen er delt i tre deler. Verdiene til venstre 
for den ledige plassen (indeks k) er mindre enn skilleverdien 11, verdiene til 
høyre for k og til venstre for v er større enn eller lik skilleverdien. 
Indeksene v og h er endepunktene på den «ukjente» (grå) delen, dvs. den delen 
som ennå ikke er undersøkt. Gangen videre er nå: Hvis a[v] er mindre enn 
skilleverdien, flyttes den til den ledige plassen k. Dermed blir plass v ledig. 
Verdien som ligger i posisjon k + 1 flyttes til plass v og det gjør plass k + 1 
ledig (dvs. k økes med 1). Hvis a[v] ikke er mindre enn skilleverdien, økes v 
med 1. Algoritmen går så lenge som v <= h. Til slutt, når alle tallene er 
undersøkt, må tallet som ble lagt til side, legges på den ledige plassen og 
undersøkes. Metoden skal returnere venstre indeks til andre del, dvs. den som 
inneholder de som er større enn eller lik skilleverdien. Lag metoder, med samme 
signatur som metodene i Programkode 1.3.1 a), som utfører denne algoritmen. Hvor 
effektiv er denne metoden?  

1.3.2 Partisjonering og sortering
Partisjoneringsalgoritmen i Programkode 1.3.1 a) anvendt på en tabell der 
skilleverdien s hører med i tabellen, vil ha som resultat at s havner et eller 
annet sted i høyre del. Dvs. blant de verdiene som er større enn eller lik s. 
Det hadde imidlertid vært fordelaktig om s havnet nøyaktig på grensen mellom de 
to delene. Med andre ord at tallene mindre enn s kom først, så s og så resten av 
tallene. Hvis det er tilfellet, sier vi at s er på rett sortert plass: 

Definisjon 1.3.2 a) En verdi i en tabell står på rett sortert plass hvis alle 
elementene til venstre for verdi er mindre enn eller lik verdi og alle 
elementene til høyre for verdi er større enn eller lik verdi. 

Hvis vi gjør litt forarbeid og litt etterarbeid, kan vi bruke 
partisjoneringsalgoritmen til få skilleverdien på rett sortert plass. Det er 
normalt ikke mulig å vite om en gitt skilleverdi ligger i en tabell fra før 
eller ikke. Men hvis vi isteden oppgir en tabellindeks og bruker den tilhørende 
tabellverdien som skilleverdi, så er vi på den sikre siden. La oss f.eks. bruke 
den verdien som ligger på midten (dvs. indeks m = (v + h)/2) som skilleverdi: 
4 3 17 10 6 20 1 11 15 8 18 9 2 7 19 13 5 14 16 12 
v  m  h 
Figur 1.3.2 a) : En permutasjon der tallet 8 ligger på midten m = (v + h)/2 . 

Ved en ombytting flytter vi verdien på midten (indeks m) bakerst. Dvs. 8 og 12 
bytter plass: 
4 3 17 10 6 20 1 11 15 12 18 9 2 7 19 13 5 14 16 8 
v  h 
Figur 1.3.2 b) : 8 ligger bakerst og intervallet a[v:h ? 1] har fått grå 
bakgrunn. 

Hvis vi partisjonerer intervallet a[v:h ? 1] (den grå delen i Figur 1.3.2 b) med 
den bakerste verdien (8) som skilleverdi, får vi delt a[v:h ? 1] i to deler der 
p angir skillet: 
4 3 5 7 6 2 1 11 15 12 18 9 20 10 19 13 17 14 16 8 
v  p  h 
Figur 1.3.2 c) : p er posisjonen til den første i a[v:h ? 1] som er >= 
skilleverdien 8 

Metoden i Programkode 1.3.1 a) returnerer posisjonen p til den første i a[v:h ? 
1] som ikke er mindre enn skilleverdien. Det er der 8 må plasseres for at den 
skal komme på rett sortert plass. Vi bytter om verdien på plass p og 
skilleverdien (som ligger bakerst): 
4 3 5 7 6 2 1 8 15 12 18 9 20 10 19 13 17 14 16 11 
v  p  h 
Figur 1.3.2 d) : Skilleverdien 8 som opprinnelig lå på midten, er nå på sortert 
plass 

Idéen over kan generaliseres. En vilkårlig tabellverdi a[i] kan inngå som 
skilleverdi. Vi lager en metode sParter (s for sortert) som benytter Programkode 
1.3.1 a) til å få a[i] på rett sortert plass. Obs: Det er a[i] som blir 
skilleverdi og ikke i. Vi lager vi to versjoner (legges i class Tabell) ? den 
første arbeider i et lukket intervall og den andre i en hel tabell: 

  // Tabellverdien a[i] blir nå skilleverdi
  public static int sParter(int[] a, int v, int h, int i)
  {
    if (v < 0 || h >= a.length || i < v || i > h) throw new
        IllegalArgumentException("Ulovlig parameterverdi");

    bytt(a,i,h);   // bytter - skilleverdien a[i] legges bakerst
    int p = parter(a,v,h-1,a[h]);  // partisjonerer a[v:h - 1]
    bytt(a,p,h);   // bytter for å få skilleverdien på rett plass

    return p;      // returnerer posisjonen til skilleverdien
  }
              Programkode 1.3.2 a) 

Flg. eksempel viser hvordan sParter-metoden i Programkode 1.3.2 a) kan gjenskape 
det som ble utledet ved hjelp av Figurene 1.3.2 a) ? d): 

  int[] a = {4,3,17,10,6,20,1,11,15,8,18,9,2,7,19,13,5,14,16,12};

  int v = 0, h = a.length - 1, m = (v + h)/2;
  int p = Tabell.sParter(a,v,h,m);

  for (int i = 0; i < p; i++) System.out.print(a[i] + " ");
  System.out.print("[" + a[p] + "] ");
  for (int i = p + 1; i < a.length; i++) System.out.print(a[i] + " ");

  // Utskrift: 4 3 5 7 6 2 1 [8] 15 12 18 9 20 10 19 13 17 14 16 11

              Programkode 1.3.2 b) 

I utskriften fra Programkode 1.3.2 b) er verdien 8 som opprinnelig lå på midten, 
markert (med hakeparenteser). Vi ser fort at den ligger på rett sortert plass. 
Se Oppgave 1.3.2.1. 

I Programkode 1.3.2 a) foregår sammenligningene i parter-metoden. Hvis 
intervallet a[v:h] har n verdier, blir det n ? 1 stykker siden kallet skjer på a[v:h 
? 1]. Det blir to ekstra ombyttinger (kall på bytt) ? en før og en etter kallet 
på parter-metoden. I tillegg kommer ombyttingene som skjer der. Det kan vises at 
hvis metoden sParter i Programkode 1.3.2 a) kalles på en permutasjon av tallene 
fra 1 til n og med en tilfeldig indeks, så vil det gjennomsnittlige antallet 
ombyttinger bli eksakt 2 + (n ? 2)/6 = (n + 10)/6. 

Kvikksortering Figur 1.3.2 a) inneholder en permutasjon av tallene fra 1 til 20. 
Velges midtverdien, dvs. den med indeks lik (v + h)/2 som skilleverdi, vil 
metoden sParter i Programkode 1.3.2 a) gjøre at tabellen blir slik som i Figur 1.3.2 
d). Tallet 8 er på rett sortert plass. På figuren under har de to delene på hver 
side av 8 fått grå bakgrunn: 
4 3 5 7 6 2 1 8 15 12 18 9 20 10 19 13 17 14 16 11 
v  p  h 
Figur 1.3.2 e) : Tallene i a[v:p ? 1] er mindre enn 8 og de i a[?p + 1:h] større 
enn 8 

De to «grå» delene i Figur 1.3.2 e), dvs. intervallene a[v?:?p ? 1] og a[?p + 1?:?h] 
kan nå ses på som separate intervaller. Hvis f.eks. a[v?:?p ? 1] partisjoneres 
med hensyn på den midterste verdien i intervallet (tallet 7), vil alle verdiene 
etterpå ligge på rett side av 8. Tallet 7 er størst av tallene i a[v?:?p ? 1] og 
rett sortert plass for den blir lengst til høyre. På samme måte blir det for a[?p 
+ 1?:?h] hvis den partisjoneres med hensyn på midtverdien (tallet 10). Gjør vi 
begge delene, får vi flg. resultat: 
4 3 5 1 6 2 7 8 9 10 18 15 20 11 19 13 17 14 16 12 
Figur 1.3.2 f) : Tallene 7, 8, 9 og 10 ligger alle nå på rett sortert plass 

Etter tre kall på sParter får vi, som Figur 1.3.2 f) viser, at fire tall (7, 8, 
9 og 10) har kommet på rett sortert plass. Dette kan fortsettes ved at sParter 
kalles på hver av de to «grå» delene. Osv. Dermed er vi faktisk i gang med den 
svært effektive sorteringsalgoritmen kvikksortering (eng: quick sort). Vi skal 
se nøyere på den senere. Koden er faktisk ganske enkel. Vi starter med et 
intervall a[v?:?h]. Hvis det er tomt (v > h) eller hvis det inneholder kun én 
verdi (v = h), er det allerede sortert. Da gjør vi ikke noe mer. Hvis a[v?:?h] 
har minst to verdier, partisjonerer vi intervallet med hensyn på midtverdien. 
Dermed havner den verdien på rett sortert plass. Deretter fortsetter vi på de to 
intervallene på hver side: 

  private static void kvikksortering(int[] a, int v, int h)
  {
    if (v < h)  // hvis v >= h er a[v:h] allerede sortert
    {
      int p = Tabell.sParter(a,v,h,(v + h)/2);  // bruker midtverdien
      kvikksortering(a,v,p-1);     // sorterer intervallet a[v : p - 1]
      kvikksortering(a,p+1,h);     // sorterer intervallet a[p + 1 : h]
    }
  }

  public static void kvikksortering(int[] a)   // sorterer hele tabellen
  {
    kvikksortering(a,0,a.length-1);
  }
              Programkode 1.3.2 c) 

I kvikksortering er det to kall på den samme metoden. Dette kalles rekursjon. 
Mer om det i Avsnitt 1.5.7. De to kallene skjer på intervaller som helt sikkert 
er kortere enn a[v:h]. I verste fall er det ene intervallet tomt og det andre 
dermed bare én kortere enn a[v:h]. Det gjør at kvikksortering i verste fall blir 
av orden n2. Men i gjennomsnitt blir hvert av de to intervallene a[v : p - 1] og 
a[?p + 1 : h] ikke så langt fra å være halvparten så lange som a[v:h]. Det gjør 
at kvikksortering i gjennomsnitt er av orden n?log2(n). Mer om dette senere. 

Flg. eksempel viser hvordan vi kan sjekke at kvikksortering virker. Men da må 
metodene i Programkode 1.3.2 c) være lagt inn i samleklassen Tabell: 

  int[] a = Tabell.randPerm(20);
  Tabell.kvikksortering(a);
  Tabell.skriv(a);

  // Utskrift: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

              Programkode 1.3.2 d) 

Vi kan også bruke partisjonering til å finne den k-te minste verdien i en tabell, 
dvs. den verdien som ville ha kommet på plass nr k hvis vi hadde sortert 
tabellen. F.eks. er den 0-te minste verdien det samme som den minste og den 1-te 
minste verdien det samme som den nest minste verdien. Den største verdien svarer 
til den (a.length-1)-te verdien. 

Kvikksøk bruker idéen i kvikksortering. En partisjonering med f.eks. verdien på 
midten som skilleverdi, gjør at den havner på rett sortert plass (posisjon p). 
Hvis det er lik posisjon k, er vi ferdige. Hvis ikke må vi lete videre på 
venstre side hvis k < p og på høyre side hvis k > p: 

  public static int kvikksøk(int[] a, int k)
  {
    if (k < 0 || k >= a.length)
      throw new IllegalArgumentException("k(" + k + ") er ulovlig!");

    int v = 0, h = a.length - 1;

    while (true)
    {
      int p = sParter(a,v,h,(v + h)/2);   // se Programkode 1.3.2 a)
      if (k < p) h = p - 1;
      else if (k > p) v = p + 1;
      else return a[p];
    }
  }
              Programkode 1.3.2 e) 

Vi har tidligere funnet algoritmer som finner den største og den nest største 
verdien. Metoden kvikksøk er effektiv og dekker alle k-er, men er ikke fullt så 
god som våre tidligere metoder når det gjelder størst og nest størst (eller 
minst og nest minst). 

Flg. eksempel viser hvordan vi bruker kvikksøk: 

  int[] a = {9,15,3,22,13,5,18,10,7,11,8,17,12};
  int k = 2;   // den 3-dje minste verdien
  System.out.println(Tabell.kvikksøk(a,k));

  // Utskrift: 7 

Oppgaver til Avsnitt 1.3.2 
1. Legg tallene 7,3,10,5,4,6,9,2,8,1 i tabellen a i Programkode 1.3.2 b). Finn 
resultatet (utskriften) ved hjelp av «papir og penn» og lag så en fasit ved å 
kjøre programmet. Husk at da må de aktuelle metodene ha blitt lagt inn i 
samleklassen Tabell.  
2. La randPerm generere permutasjoner og bruk dem i Programkode 1.3.2 b). 
3. Anvend kvikksortering på noen tilfeldige tabeller og sjekk at den sorterer 
korrekt. 
4. Sammenlign tidsforbruket til kvikksortering (se Avsnitt 1.1.10 i Delkapittel 
1.1) med tidsforbruket til metoden sort i class Arrays i java.util.  
5. Lag en metode double median(int[] a) som bruker kvikksøk til å finne medianen 
til a. La n være antall verdier i a. Hvis n er odde, er medianen den verdien som 
havner på midten etter en sortering av a. Hvis n er et partall, finnes det 
egentlig ikke noen midterste verdi. Men da sier vi at medianen er gjennomsnittet 
av de to verdiene som havner på hver sin side av midten etter en sortering. Men 
poenget er å finne dette uten å sortere tabellen.  

1.3.3 Permutasjoner
Vi må bruke tilfeldige inputverdier hvis målet er å avgjøre hva som er en 
algoritmes gjennomsnittlige effektivitet. Hvis algoritmen arbeider i en 
heltallstabell, kan vi bruke tilfeldige permutasjoner av tallene fra 1 til n som 
testverdier. I noen tilfeller kan det være aktuelt å utføre algoritmen på alle 
mulige permutasjoner, dvs. på alle de n! forskjellige. Dette er imidlertid bare 
aktuelt for små verdier av n siden antallet permutasjoner vokser sterkt når n 
vokser. Allerede for n lik 10 vil det bli hele 3.628.800 stykker. 

Vi skal nå utvikle en teknikk som genererer alle de n! permutasjonene og da i 
det som kalles den leksikografiske (eng: lexicographic) rekkefølgen. Dette 
begrepet defineres slik: 

Definisjon 1.3.3 a) Gitt to permutasjoner p og q av tallene fra 1 til n 

p = p0 p1 p2 . . . pn?1
q = q0 q1 q2 . . . qn?1 

Vi sier at p og q like hvis pi = qi for alle i = 0?, 1?, . . n?1. Hvis ikke, la 
k være den minste indeksen slik at pk er forskjellig fra qk?. Vi sier at p < q 
leksikografisk hvis pk < qk og at p > q leksikografisk hvis pk > qk . 

Eksempel 1.3.3 a): Gitt flg. to permutasjoner p og q av tallene fra 1 til 10: 

p = 3 1 7 9 4 10 8 6 5 2 q = 3 1 7 9 5 2 6 8 4 10 

De fire første tallene er like i p og q. Det femte tallet i p er mindre enn det 
femte i q. Dermed er p mindre enn q leksikografisk. Spesielt får vi at 1 2 3 4 5 
6 7 8 9 10 er leksikografisk sett den første (minste) og at 10 9 8 7 6 5 4 3 2 1 
er den siste (største) blant permutasjonene av tallene fra 1 til 10. 

Hvis en permutasjon er gitt, hva blir da den neste i den leksikografiske 
rekkefølgen? Hvis det siste tallet er større enn det neste siste, får vi den 
neste i rekkefølgen ved å bytte de to siste tallene. La f.eks. p = 2 4 6 1 3 5 
være en permutasjon av tallene fra 1 til 6. Det siste tallet 5 er større enn det 
nest siste tallet 3. Når disse byttes får vi q = 2 4 6 1 5 3. Vi ser at q er den 
permutasjonen som kommer rett etter p leksikografisk. 

Hvis den siste er mindre enn den nest siste, kan vi ikke bytte de to siste. Da 
ser vi isteden på det tredje siste tallet. La nå p = 2 4 6 1 5 3. De tre siste 
tallene 1, 5 og 3 kan omorganiseres fordi det finnes en rekkefølge av disse tre 
som kommer rett etter 1 5 3 leksikografisk. Det er 3 1 5. Gjør vi dette i p får 
vi at q = 2 4 6 3 1 5 blir den som kommer rett etter p leksikografisk. 

Det vi generelt må gjøre er å starte bakerst i permutasjonen. La p = 3 1 7 9 4 
10 8 6 5 2. Vi går forover (mot venstre) så lenge som tallene kommer i voksende 
rekkefølge. I p blir det 2, 5, 6, 8 og 10. Det neste tallet 4 er det første 
tallet som ikke er større enn tallet rett til høyre for seg. Så bytter vi 4 med 
det tallet til høyre for 4 som er både større enn 4 og er nærmest 4 i verdi. Det 
er her tallet 5. Den ombyttingen gir oss 3 1 7 9 5 10 8 6 4 2. Siste skritt er å 
snu rekkefølgen på alle tallene til høyre for 5. Da får vi q = 3 1 7 9 5 2 4 6 8 
10 og det er den som kommer rett etter p leksikografisk. 

Flg. metode gir, for en gitt permutasjon av tallene fra 1 til n, den neste i 
leksikografisk rekkefølge. Den gitte permutasjonen, som ligger i tabellen a, er 
parameter til metoden. Metoden hører hjemme i samleklassen Tabell: 

  public static boolean nestePermutasjon(int[] a)
  {
    int n = a.length, i = n - 2;  // i starter nest bakerst i a
    while (i >= 0 && a[i] > a[i+1]) i--;  // går forover i a

    // hvis i nå er lik -1, må a = {n,n-1, . . . , 2,1}
    if (i < 0) return false;  // a er den siste

    int j = n - 1;  // j starter bakerst i a
    for (int x = a[i]; a[j] < x; j--);     // den første større enn x
    bytt(a,i,j);    // bytter om

    for (j = n; ++i < --j; ) bytt(a,i,j);  // snur det til høyre for i
    return true;    // a inneholder en ny permutasjon
  }
              Programkode 1.3.3 a) 

Flg. eksempel viser hvordan metoden nestePermutasjon kan brukes: 

  int[] a = {3,1,7,9,4,10,8,6,5,2};  // en permutasjon av 1 til 10

  Tabell.nestePermutasjon(a);
  Tabell.skrivln(a);   // metode laget i Oppgave 5 fra Avsnitt 1.2.2

  // Utskrift: 3 1 7 9 5 2 4 6 8 10 

Koden i nest siste programsetning i Programkode 1.3.3 a) snur verdiene i et 
tabellintervall. Det burde kanskje lages en hjelpemetode for det behovet. Se 
Oppgave 3. 

Anvendelse 1 Setning 1.3.1 b) sier at det i gjennomsnitt utføres (n2 ? 1)/6n 
ombyttinger i partisjoneringsmetoden i Programkode 1.3.1 a). Gjennomsnittet er 
over alle permutasjoner av tallene fra 1 til n og over alle skilleverdier s fra 
1 til n. Vi kan nå sjekke om dette stemmer for små verdier av n. Setning 1.3.1 a) 
sier at antall ombyttinger for en permutasjon med s som skilleverdi, er det 
samme som antallet blant de s ? 1 første som er større enn eller lik s. Vi 
bruker nestePermutasjon til å generere alle de n?! forskjellige permutasjonene 
og metoden antallBytt i Programkode 1.3.1 e) til å telle opp ombyttingene for 
hvert valg s av skilleverdi. Metoden antallBytt må være tilgjengelig for at flg. 
kode skal virke: 

  int[] a = {1,2,3,4,5,6,7,8,9,10};      // første permutasjon
  boolean flerePermutasjoner = true;     // flere permutasjoner?
  int sum = 0;                           // antall ombyttinger

  while (flerePermutasjoner)
  {
    for (int s = 1; s <= a.length; s++) sum += antallBytt(a,s);
    flerePermutasjoner = Tabell.nestePermutasjon(a);
  }

  System.out.println(sum);    // Utskrift: 59875200

              Programkode 1.3.3 b) 

Påstanden er at (n2 ? 1)/6n er gjennomsnittet. Med n?! permutasjoner og n 
skilleverdier for hver permutasjon blir det sammenlagte antallet lik n?!?n?(n2 ? 
1)/6n = n?!?(n2 ? 1)/6. Med n = 10 blir dette lik 59875200 og det er nettopp det 
vi fikk i utskriften over. Se Oppgave 4. 

Anvendelse 2 Setning 1.1.6 i Avsnitt 1.1.6 sier at i en tilfeldig permutasjon av 
tallene fra 1 til n, vil det gjennomsnittlig være 1/2 + 1/3 + . . + 1/n av dem 
som er større enn det største av tallene foran. Oppgave 1 i det avsnittet gikk 
ut på å verifisere dette for n = 5. Vi har at 1/2 + . . + 1/5 = 154/120. Hvis vi 
i hver av de 5! = 120 permutasjonene teller opp de tall som er større enn det 
største av de foran, skal vi sammenlagt få 154. Dette kan sjekkes ved å la 
metoden nestePermutasjon generere alle permutasjonene og så la metoden i 
antallMaks fra Programkode 1.1.9 a) telle opp. Se også Oppgave 5. 

  int[] a = {1,2,3,4,5};                // første permutasjon
  int sum = 0;                          // hjelpevariabel

  do { sum += antallMaks(a); }          // se Programkode 1.1.9 a)
  while (Tabell.nestePermutasjon(a));   // lager neste permutasjon

  System.out.println(sum);              // Utskrift: 154

                Programkode 1.3.3 c) 

Anvendelse 3 ? dronninger på et sjakkbrett Et vanlig sjakkbrett har 8 × 8 ruter. 
En dronning kan slå vertikalt, horisontalt og på skrå. Er det mulig å stille opp 
dronninger på 8 forskjellige ruter på brettet slik at ingen av dem slår 
hverandre?  
Figur 1.3.3 a) : En oppstilling 
Figur 1.3.3 b) : En permutasjon 
Figur 1.3.3 c) : En ny oppstilling 

Figur 1.3.3 a) viser et 8 × 8 brett. Bokstaven D brukes som symbol for en 
dronning. Vi ser fort at hver av de 8 radene og hver av de 8 kolonnene 
inneholder nøyaktig én dronning. En diagonal går nedover mot høyre (eller 
oppover mot venstre). Ingen av de 15 diagonalene har mer enn én dronning. En 
bidiagonal går nedover mot venstre (eller oppover mot høyre). Heller ingen av de 
15 bidiagonalene inneholder mer enn én dronning. Dette betyr at i 
dronningoppstillingen på dette brettet er det ingen dronninger som slår 
hverandre. Vi kaller det en lovlig dronningoppstilling. 

I Figur 1.3.3 a) er både radene og kolonnene indeksert fra 0 til 7. Posisjonen 
til en rute er gitt ved et tallpar (?r?,?k?) der r er rad- og k kolonneindeks. 
Ramser vi opp posisjonene radvis, ovenfra og nedover, til de rutene som 
inneholder dronninger, får vi (0,3), (1,5), (2,0), (3,4), (4,1), (5,7), (6,2) og 
(7,6). Ser vi på første tall i hvert tallpar som en indeks, gir de andre tallene 
permutasjonen i Figur 1.3.3 b). 

Tabellen i Figur 1.3.3 b) har en permutasjon av tallene fra 0 til 7. Vi kan gå 
motsatt vei. En vilkårlig permutasjon av tallene fra 0 til 7, f.eks. 5, 2, 6, 3, 
1, 4, 0, 7, kan tolkes som en oppstilling der hver rad og kolonne inneholder 
nøyaktig én dronning. For hvert tall brukes tallets posisjon som radindeks og 
tallet selv som kolonneindeks. Det gir rutene (0,5), (1,2), (2,6), (3,3), (4,1), 
(5,4), (6,0) og (7,7). I Figur 1.3.3 c) står det en D i hver av disse rutene. 

Det er 8! = 40320 permutasjoner av tallene fra 0 til 7. Det er selvfølgelig ikke 
alle som gir en lovlig oppstilling. Vi fant at den i Figur 1.3.3 a) er lovlig. 
Men den i Figur 1.3.3 c) er ulovlig. Starter vi i øverste rad og går nedover ser 
vi at ingen av de fire første dronningene slår hverandre. Men den femte, den i 
rute (4,1), blir slått av dronningen i (0,5). På Figur 1.3.3 c) er diagonalen og 
bidiagonalen som dronningen i rute (0,5) behersker, markert med små røde prikker. 
Dronningen i rute (4,1) ligger på bidiagonalen. Vi ser også at dronningene i 
rute (6,0) og (7,7) står ulovlig. Begge kan begge slås av den i rute (3,3). 

Vi har generelt at enhver lovlig dronningoppstilling representerer en 
permutasjon av tallene fra 0 til 7, men at det motsatte ikke er sant. For å 
avgjøre om en permutasjon representerer en lovlig, holder det å sjekke 
diagonalene og bidiagonalene. utasjon av tallene fra 0 til 7. I Figur 1.3.3 c) 
består diagonalen gjennom rute (0,5) av rutene (0,5), (1,6) og (2,7). 
Differensen mellom radindeks og kolonneindeks er lik ?5 for alle disse rutene. 
Bidiagonalen gjennom rute (0,5) består av rutene (0,5), (1,4), (2,3), (3,2), (4,1) 
og (5,0). For disse er summen av radindeks og kolonneindeks lik 5. Disse 
observasjonen gir oss flg. setning: 

Setning 1.3.3 a) - Diagonal og bidiagonal To ruter (a?,?b) og (c?,?d) ligger på 
samme diagonal hvis og bare hvis a ? b = c ? d. To ruter (a?,?b) og (c?,?d) 
ligger på samme bidiagonal hvis og bare hvis a + b = c + d. 

Anta at en permutasjon p er gitt og at dronningene er plassert på brettet i 
henhold til den. For hver dronning må vi sjekke om det er en dronning høyere opp 
på brettet (til venstre i p) som slår «vår» dronning på skrå. Til dette trengs 
to for-løkker - en yttre og en indre. Den yttre går nedover brettet (mot høyre i 
p) og den indre oppover brettet (til venstre i p) for å sjekke diagonalen og 
bidiagonalen (se Setning 1.3.3 a). Dette kan kodes slik: 

  public static boolean lovligOppstilling(int[] p)  // p er en permutasjon
  {
    for (int r = 1; r < p.length; r++)  // r radindeks, p[r] kolonneindeks
    {
      int diff = r - p[r], sum  = r + p[r];  // differens og sum

      for (int i = r - 1; i >= 0; i--)   // ser på radene oppover fra r
        if (sum == i + p[i] || diff == i - p[i]) return false;
    }
    return true;   // vi har en lovlig oppstilling
  }
              Programkode 1.3.3 d) 

Flg. eksempel viser hvordan vi ved hjelp av metodene nestePermutasjon og 
lovligOppstilling kan finne alle lovlige dronningoppstillinger på et 8 × 8 brett: 

  int[] p = {0,1,2,3,4,5,6,7};                // første permutasjon
  int antall = 0;                             // hjelpevariabel

  do { if (lovligOppstilling(p)) antall++; }  // sjekker permutasjonen
  while (Tabell.nestePermutasjon(p));         // lager neste permutasjon

  System.out.println(antall);                 // Utskrift: 92

              Programkode 1.3.3 e) 

Programkode 1.3.3 e) er ikke spesielt effektiv. Hvis en permutasjon er «ulovlig», 
er det normalt ikke nødvendig å prøve den neste. Vi kan hoppe over mange av dem 
før vi tester en ny en. Denne mulige effektiviseringen tas opp i Oppgave 6 - 9. 
Se også Avsnitt 1.3.17. 

Anvendelse 4 ? en permutasjonsiterator Metoden nestePermutasjon er ikke robust. 
En tabellendring mellom to metodekall, vil endre rekkefølgen. Hvis permutasjonen 
«ødelegges», blir metoden uforutsigbar. Vi kan eventuelt kopiere hver 
permutasjon over i en hjelpetabell og gjøre endringene der. Dette kan 
systematiseres gjennom en permutasjonsiterator. 

En iterator et spesielt objekt laget for å kunne traversere en datastruktur. 
Traversere (eng: traverse) betyr å gå gjennom. Logisk sett kunne vi tenke oss at 
alle permutasjonene ligger i en datastruktur, og at vi kan hente én og én 
gjennom å traversere. Grensesnittet (eng: interface) for dette er Iterator<E> (E 
er typeparameter). Grensesnittet har tre metoder: 

public boolean hasNext() 

public E next() 

public void remove() 

Vår klasse PermIterator må ha kode for disse tre metodene og i tillegg ha 
konstruktører. Permutasjonene lages i en intern tabell og det er en kopi som 
blir sendt til oss. 

  private static class PermIterator implements Iterator<int[]>
  {
    private int[] a;                 // tabell for permutasjoner
    private boolean flere = true;    // flere permutasjoner?

    private PermIterator(int n)      // privat konstruktør
    {
      a = naturligeTall(n);          // a = {1,2,3, . . ,n}
    }

    private PermIterator(int[] p)    // privat konstruktør
    {
      a = p.clone();                 // a blir en kopi av p
    }

    public int[] next()
    {
      int[] b = a.clone();           // b blir en kopi av a
      flere = nestePermutasjon(a);   // bruker Programkode 1.3.3 a)
      return b;
    }

    public boolean hasNext() { return flere; }

    public void remove() { throw new UnsupportedOperationException(); }

  }  // class PermIterator

  public static Iterator<int[]> permiterator(int n)
  {
    return new PermIterator(n);
  }

  public static Iterator<int[]> permiterator(int[] a)
  {
    return new PermIterator(a);
  }
              Programkode 1.3.3 f) 

Flg. eksempel viser hvordan en iterator kan brukes til å lage de 6 
permutasjonene av tallene fra 1 til 3. Først må vi imidlertid kopiere 
Programkode 1.3.3 f) over i samleklassen Tabell. I tillegg må Tabell ha metoden 
naturligetall. Se Oppgave 7 i Avsnitt 1.2.2. 

  for (Iterator<int[]> i = Tabell.permiterator(3); i.hasNext(); )
  {
      System.out.print(Arrays.toString(i.next()) + " ");
  }

  // Utskrift:  [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1]

              Programkode 1.3.3 g) 

Legg merke til syntaksen: Iterator<int[]> i = Tabell.permiterator(3); oppretter 
en iterator med int[] som parametertype. Metoden hasNext() gir sann hvis det er 
flere permutasjoner igjen. En for-løkke har normalt en oppdatering av en 
tellevariabel. Men her blir «oppdateringen» utført i metodekallet i.next(). 
Metoden next() returnerer en kopi av gjeldende permutasjon og genererer samtidig 
neste permutasjon internt i iteratoren. 

Oppgaver til Avsnitt 1.3.3 
1. Gitt flg. permutasjoner av tallene fra 1 til 6: a) 2 3 6 1 4 5, b) 2 3 6 1 5 
4,
c) 2 3 1 6 5 4, d) 2 3 6 5 4 1 og e) 2 6 5 4 3 1. Finn, for hver av dem, den 
neste i leksikografisk rekkefølge. Bruk så metoden nestePermutasjon som fasit. 
2. Skriv opp de 10 første permutasjonene som kommer etter 3 1 7 9 4 10 8 6 5 2 
leksikografisk. Bruk metoden nestePermutasjon som fasit. 
3. I nest siste setning i metoden nestePermutasjon i Programkode 1.3.3 a) snus 
rekkefølgen på verdiene i en del av tabellen. Lag egne metoder for dette, dvs. 
lag de tre metodene snu(int[] a, int v, int h), snu(int[] a, int v) og snu(int[] 
a). Alle skal være av typen public static void. Den første skal snu innholdet i 
intervallet a[v:h], den andre verdiene fra og med indeks v og ut tabellen og den 
tredje skal snu hele tabellen. Legg dem i klassen Tabell og bruk en av dem i 
metoden nestePermutasjon. 
4. Lag et program som kjører Programkode 1.3.3 b). Sjekk at kjøringen stemmer 
med teorien også for andre verdier av n enn 10. 
5. Kjør Programkode 1.3.3 c). Gjenta kjøringen med n = 6. Da skal resultatet bli 
1044. Sjekk at det er lik (1/2 + 1/3 + . . + 1/6)*6! Gjenta dette med n = 7. 
6. Kjør Programkode 1.3.3 e). Gjenta dette med andre brett, f.eks. 9 × 9 og 10 × 
10. 
7. Lag kode som finner og skriver ut den første permutasjonen i leksikografisk 
rekkefølge som gir en lovlig dronningoppstilling. 
8. Vi setter én og én dronning på brettet på grunnlag av en permutasjon. Hvis en 
dronning slås av en høyre opp, kan vi stoppe. Vi kan så hoppe over alle de 
permutasjonene som er lik den frem til den «ulovlige dronningen». Gjør de 
endringene i Programkode 1.3.3 e) som trengs. Da vil koden bli vesentlig mer 
effektiv. Gjør testkjøringer!  
9. En lovlig oppstilling kan speiles om en vertikal midtlinje og det gir en til 
som er lovlig. Dvs. vi kan halvere antallet permutasjoner som skal undersøkes. 
Lag kode for dette. 
10. Legg Programkode 1.3.3 f) i samleklassen Tabell. Der må også metoden 
naturligeTall ligge. Se Oppgave 7 i Avsnitt 1.2.2. Kjør så Programkode 1.3.3 g). 
11. Bruk iteratorteknikk i både Programkode 1.3.3 b) og i Programkode 1.3.3 c). 


1.3.4 Tredelt partisjonering
Hollands flagg 
I Eksempel 1.3.1 c) var det en tabell som kun inneholdt tre forskjellige verdier. 
Det var bokstavene R, H og B. Ønsket var å få tabellen omorganisert slik at R-ene 
kommer først, så H-ene og til slutt B-ene. Problemet har (av E. W. Dijkstra) 
fått navnet «Det hollandske flaggproblemet» (eng: The Dutch National Flag 
Problem). Bokstavene R, H og B står da for fargene i det hollandske flagget, dvs. 
fargene rød, hvit og blå. Målet er å få tabellen «lik» flagget, dvs. alt det «røde» 
først, så alt det «hvite» og alt det «blå» til slutt. Dette er det ikke 
vanskelig å få til, men poenget er å få det til med færrest mulig 
sammenligninger og ombyttinger. 

Tabellen fra Eksempel 1.3.1 c) ser slik ut: 
H B R B H H R B R H B R H R R B H B H R 

Vi ønsker (med minst mulig innsats) at den skal bli slik: 
R R R R R R R H H H H H H H B B B B B B 

Et første forsøk kan være å bruke vanlig partisjonering to ganger. Første gang 
separeres R-ene fra resten av bokstavene og legges først. Andre gang deles 
resten av tabellen opp i H-er og B-er. For eksempel slik: 

  public static void omorganiser(char[] c)
  {
    int v = 0, h = c.length-1;

    while (v <= h) if (c[v] == 'R') v++; else  Tabell.bytt(c,v,h--);

    h = c.length-1;  // nå ligger R-ene først

    while (v <= h) if (c[v] == 'H') v++; else  Tabell.bytt(c,v,h--);
  }
                 Programkode 1.3.4 a) 

Flg. eksempel viser hvordan metoden kan brukes: 

  char[] c = "HBRBHHRBRHBRHRRBHBHR".toCharArray();
  omorganiser(c);
  Tabell.skriv(c);

  // Utskrift: RRRRRRRHHHHHHHBBBBBB 

La tabellen c ha n verdier. Hver av de n verdiene kan enten være en R, en H 
eller en B. Dermed blir det 3n mulige tabeller med i gjennomsnitt 1/3 R-er, 1/3 
H-er og 1/3 B-er. I den første while-løkken i Programkode 1.3.4 a) blir det 
alltid n sammenligninger. I den andre while-løkken blir det like mange som det 
er H-er og B-er, dvs. i gjennomsnitt 2n/3 stykker. Sammenlagt blir det 5n/3 
sammenligninger i gjennomsnitt. I den første while-løkken blir det én ombytting 
hver gang c[v] er ulik R. Dvs. i gjennomsnitt 2n/3 ganger. I den andre løkken 
blir det en hver gang c[v] er ulik H, dvs. n/3 ganger. Sammenlagt n ombyttinger 
i gjennomsnitt. 

Det er ikke mulig å lage en algoritme som har færre sammenligninger i 
gjennomsnitt enn den i Programkode 1.3.4 a). Hvert tabellelement må undersøkes 
minst én gang. Da trengs én sammenligning for å avgjøre om verdien er en R. Hvis 
ikke trengs ytterligere én for å avgjøre om det er en H eller B. I gjennomsnitt 
(1?·?1/3 + 2?·?2/3)n = 5n/3 sammenligninger. Men det er mulig å lage en 
algoritme som utfører færre ombyttinger. 

Vi kan tenke på samme måte som i Avsnitt 1.3.1. Men denne gangen lar vi tabellen 
være delt i fire deler under algoritmens gang. Første del skal bestå av R-er, 
andre del av ukjente verdier, dvs. de som ennå ikke er undersøkt, tredje del av 
H-er og siste del av B-er. Tegningen viser hvordan det kan se ut etter en del 
iterasjoner: 
R R R R ? ? ? ? ? ? ? ? H H H H H B B B 
v  h  k  

Indeksene v og h står forrest og sist i den «ukjente» delen og k sist i H-delen 
(h = k hvis det ikke er noen H-er). Vi har tre muligheter for tabellelementet c[h]. 
Hvis c[h] er lik R bytter vi innhold i c[h] og c[v]. Da har R-området fått en 
mer og vi må øke v med 1. Hvis c[h] er lik H flytter vi h en mot venstre. Hvis c[h] 
er lik B bytter vi innhold i c[h] og c[k], og reduserer både h og k med 1. 
Algoritmen går så lenge som v <= h: 

  public static void omorganiser(char[] c)  // ny versjon
  {
    int v = 0, h = c.length-1, k = h;  // v forrest, h og k bakerst

    while (v <= h)
    {
      if (c[h] == 'R') Tabell.bytt(c,v++,h);
      else if (c[h] == 'H') h--;
      else  Tabell.bytt(c,h--,k--);
    }
  }
                 Programkode 1.3.4 b) 

Det er ikke vanskelig å se at det utføres nøyaktig 5n/3 sammenligninger i 
gjennomsnitt i Programkode 1.3.4 b). I hver iterasjon vil det bli én ombytting 
hvis c[h] er lik R, ingen hvis den er lik H og én hvis den er lik B. Det gir 2n/3 
ombyttinger i gjennomsnitt. Med andre ord er dette en del bedre enn i 
Programkode 1.3.4 a). 

Det er mulig å redusere antallet ombyttinger ytterligere. Hvis c[h] er lik R 
eller H samtidig som v er lik h, er ombyttingen unødvendig. Den kan fjernes ved 
å la while-løkken gå så lenge som v < h og så behandle v lik h som et 
spesialtilfelle. Det er også unødvendig å bytte om hvis c[h] er lik B og h er 
lik k. En test på om h er lik k vil imidlertid koste mer enn det vi tjener ved å 
spare en ombytting. Men hvis vi ønsker kan Programkode 1.3.4 b) endres slik at 
det gjennomsnittlige antallet ombyttinger blir: 

(*)   2n/3 - 4/3 + (2/3)n 

Det finnes 3n forskjellige tabeller c med lengde n og med R, H eller B som 
elementer. Hver av dem utgjør en n-permutasjon av R, H og B med repetisjon. Her 
definerer vi, med tanke på leksikografisk ordning, at R kommer foran H som igjen 
kommer foran B. Flg. metode gir den neste n-permutasjonen med repetisjon: 

  public static boolean nestePermutasjon(char[] c)
  {
    int n = c.length, i = n - 1;  // i starter bakerst i c

    while (i >= 0 && c[i] == 'B') i--;
    if (i < 0) return false; // tabellen c har kun B-er

    c[i] = (c[i] == 'R' ? 'H' : 'B');
    for (int j = i+1; j < n; j++) c[j] = 'R';

    return true;  // c inneholder en ny permutasjon
  }
                   Programkode 1.3.4 c) 

Hvis vi f.eks. starter med R, R, R vil neste permutasjon bli R, R, H, så kommer 
R, R, B, så R, H, R, osv. Vi kan lage en programbit som skriver ut alle de 33 = 
27 3-permutasjonene: 

  char[] c = "RRR".toCharArray();
  boolean flere = true;

  while (flere)
  {
    Tabell.skriv(c);
    flere =  nestePermutasjon(c);
  }

  // Utskrift:

  // R R R
  // R R H
  // R R B
  // R H R
  // R H H
  // osv. - tilsammen 27 permutasjoner

                Programkode 1.3.4 d) 

Vi kan finne det gjennomsnittlige antallet ombyttinger som utføres i Programkode 
1.3.4 b) ved å bruke Programkode 1.3.4 d) til å generere alle mulige n-permutasjoner 
(med repetisjon). Vi må imidlertid lage en omorganiser-metode der ombyttingene 
telles opp: 

  public static int antallOmorganiser(char[] c)
  {
    int v = 0, h = c.length-1, k = h;  // v forrest, h og k bakerst

    int antallOmbyttinger = 0;  // hjelpevariabel

    while (v <= h)
    {
      if (c[h] == 'R') { Tabell.bytt(c,v++,h); antallOmbyttinger++; }
      else if (c[h] == 'H') h--;
      else  { Tabell.bytt(c,h--,k--); antallOmbyttinger++; }
    }
    return antallOmbyttinger;
  }
                 Programkode 1.3.4 e) 

Vi kan finne det totale antallet ombyttinger som utføres ved å bruke Programkode 
1.3.4 d) til å generere alle mulige permutasjoner og så bruke Programkode 1.3.4 
e) til å telle dem opp for hver permutasjon. Vi fant at det gjennomsnittlige 
antallet ombyttinger i Programkode 1.3.4 b) var 2n/3. Hvis n = 3 får vi totalt 33 
= 27 permutasjoner og dermed 27*2*3/3 = 54 ombyttinger tilsammen. Flg. 
programbit bør derfor gi 54 som utskrift: 

  char[] c = "RRR".toCharArray();
  boolean flere = true;
  int antallOmbyttinger = 0;
  char[] d = new char[c.length];  // hjeleptabell

  while (flere)
  {
    System.arraycopy(c,0,d,0,c.length);  // kopierer c over i d
    antallOmbyttinger += antallOmorganiser(d);  // omorganiserer d
    flere =  nestePermutasjon(c);
  }

  System.out.println(antallOmbyttinger);  // Utskrift: 54

                 Programkode 1.3.4 f) 

Diskusjonen over og de metodene som er laget, bruker at tegntabellen kun 
inneholder tegnene R, H og B. Dette kan generaliseres til at den kun inneholder 
tre forskjellige tegn. De aktuelle tegnene oppgis da ved hjelp av 
parameterverdier. Se Oppgave 2. 

Oppgaver til Avsnitt 1.3.4 
1. Det gjennomsnittlige antallet ombyttinger som metoden omorganiser() fra 
Programkode 1.3.4 b) gjør for de 3n forskjellige n-permutasjonene, er 2n/3. Hva 
blir da det totale antallet ombyttinger for de 3n n-permutasjonene hvis n er 
henholdsvis 4, 5 og 6? Test svarene dine ved å kjøre Programkode 1.3.4 f). Da må 
du øke antallet R-er starttabellen. 
2. Lag generaliserte versjon av Programkode 1.3.4 b) og 1.3.4 c) der de tre 
aktuelle tegnene oppgis som parameterverdier. 
3. Som nevnt over er ombytting unødvendig hvis c[h] er lik R eller H samtidig 
som v er lik h. Det er også unødvendig å bytte om hvis c[h] er lik B samtidig 
som h er lik k. Lag en ny versjon av metoden antallOmorganiser() i Programkode 1.3.4 
e) der de unøvendige ombyttingene ikke utføres. Hvis Programkode 1.3.4 f) kjøres 
med denne nye versjonen av antallOmorganiser(), vil utskriften være det vi får 
ved å ta formelen i (*) og gange med 3n. Sjekk at det stemmer for noen verdier 
av n.  
4. Bruk samme idé som i Programkode 1.3.4 b) til å lage en parter-metode som 
partisjonerer en heltallstabell med hensyn på to skilleverdier s1 og s2 der s1 
<= s2. Første del skal inneholde de som er mindre enn s1, andre del de som er 
mindre enn s2 (men ikke mindre enn s1) og siste del av de som ikke er mindre enn 
s2.  
5. Flagget til Mauritius har fargene rød, blå, gul og grønn. Men siden  
Mauritius 
gul og grønn har samme forbokstav, bruker vi engelsk: red, blue, yellow and 
green. Anta at vi har en tabell som inneholder tegnene R, B, Y og G. Lag en 
algoritme som gjør om tabellen slik at R-ene kommer først, så B-ene, så Y-ene og 
til slutt G-ene. Bruk så få sammenligninger og ombyttinger som mulig. Vi kaller 
dette for «Det mauritiske flaggproblemet».  

1.3.5 Sorterte tabeller
En sortering er stigende (eng: ascending) eller avtagende (eng: descending). 
Kalles også voksende (eng: increasing) eller synkende (eng: decreasing). En 
tabell a (eller et intervall) er sortert stigende hvis tabellverdiene kommer i 
stigende rekkefølge. Eller mer presist: 

Definisjon 1.3.5 La intervallet I i tabellen a ha sammenlignbare verdier:

1. I er sortert stigende hvis a[i] <= a[j] for alle indekser i og j med i < j .
2. I er sortert avtagende hvis a[i] >= a[j] for alle indekser i og j med i < j .
3. Har I ett element (eller er tomt), er I sortert både stigende og avtagende. 

Flg. tabell inneholder heltall og heltall kan sammenlignes og ordnes etter 
størrelse: 
9 2 7 5 1 3 4 8 10 6 13 11 15 20 17 14 16 18 12 19 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 
Figur 1.3.5 a) : En tabell med sorterte intervaller 

I Figur 1.3.5 a) består intervallet a[4:8] av tallene 1, 3, 4, 8, 10 og er 
dermed sortert stigende. Intervallet a[4:8] er også det lengste av de sorterte 
intervallene. Men det er mange flere sorterte intervaller der. Et sortert 
intervall kalles maksimalt hvis et ekstra element til venstre eller til høyre 
gjør at det ikke lenger er sortert. Se Oppgave 7. 

En hel tabell kan ses på som et tabellintervall, dvs. intervallet fra 0 til a.length 
? 1. Derfor dekker Definisjon 1.3.5 også en hel tabell. For å kunne avgjøre om 
noe er sortert må vi kunne sammenligne og i en sammenligning inngår to verdier. 
Siste del av Definisjon 1.3.5 virker derfor litt kunstig. Men det har praktiske 
fordeler å kunne si at et tomt intervall og et intervall med bare én verdi, er 
sortert både stigende og avtagende. 

I noen situasjoner er det et krav at verdiene i en tabell er sortert strengt 
stigende (eller eventuelt strengt avtagende). Et tabellintervall (med minst to 
verdier) sies å være sortert strengt stigende hvis a[i] < a[j] for alle indekser 
i og j med i < j . Dette er det kun mulig å få til for intervaller som ikke har 
like verdier. 

Definisjon 1.3.5 er vanskelig å kode direkte. Men vi ser fort at hvis hvert 
element i en tabell er mindre enn eller lik det neste i rekkefølgen, så er 
Definisjon 1.3.5 oppfylt. Dvs. det holder å sjekke at a[0] <= a[1] , a[1] <= a[2] 
, . . , osv. 

  public static boolean erSortertStigende(int[] a)
  {
    for (int i = 1; i < a.length; i++)
      if (a[i-1] > a[i]) return false;  // ikke sortert stigende

    return true;  // a er sortert stigende
  }
                Programkode 1.3.5 a) 

Metoden returnerer true hvis tabellen er tom eller har kun ett element. Hvis a 
er null kastes en NullPointerException. Metoden kan optimaliseres noe. Se 
Oppgave 4 - 6. 

La x og y være to tabellverdier slik at x ligger til venstre for y. Hvis x > y, 
kalles paret (x,y) en inversjon. Det betyr at de to verdiene er i utakt med 
hensyn på sorteringen. Hvis tabellen er sortert stigende, er det ingen 
inversjoner. Antall inversjoner brukes ofte som et mål på hvor sortert tabellen 
er. Jo flere, jo dårligere sortering. Mer om dette i Avsnitt 1.3.14. 

I en tabell med like verdier vil ikke antallet forskjellige verdier være det 
samme som dens lengde. Hvis den er sortert, kan vi, ved å bruke samme idé som i 
Programkode 1.3.5 a), lett finne hvor mange som er forskjellige. Ulikheten a[i-1] 
< a[i] kan brukes til å avgjøre at a[i-1] er forskjellig fra a[i]. Metoden 
legges i klassen Tabell: 

  public static int antallForskjellige(int[] a)  // a må være sortert
  {
    if (a.length <= 1) return a.length;  // én eller ingen verdier

    int antall = 1;
    for (int i = 1; i < a.length; i++) if (a[i-1] < a[i]) antall++;
    return antall;
  }
                Programkode 1.3.5 b) 

Oppgaver til Avsnitt 1.3.5 
1. Lag metoden public static boolean erSortertAvtagende(int[] a). Den skal 
avgjøre om tabellen a er sortert avtagende eller ikke. 
2. Lag metoden public static boolean erSortertStigende(int[] a, int fra, int til). 
Den skal avgjøre om delintervallet a[fra:til> er sortert stigende eller ikke. 
Intervallgrensene skal sjekkes. Se Avsnitt 1.2.3. 
3. Metoden kvikksortering i Programkode 1.3.1 d) sorterer en tabell i stigende 
rekkefølge. Bruk metoden erSortertStigende til til å sjekke at kvikksortering 
sorterer korrekt. Bruk f.eks. metoden randPerm til å lage tilfeldige tabeller. 
4. I Programkode 1.3.5 a) sammenlignes først a[0] med a[1], så a[1] med a[2], 
osv. Vi kan isteden mellomlagre a[1] i en hjelpevariabel og så bruke den både i 
første og andre sammenligning. Tilsvarende med a[2], osv. Dette vil halvere 
antallet tabelloperasjoner. Lag en versjon av erSortertStigende der denne idéen 
brukes. 
5. Vi kan også, ved å bruke en vaktpost (se Avsnitt 1.1.5), fjerne 
sammenligningen
i < a.length-1 i for-løkken i Programkode 1.3.5 a). Lag en versjon av 
erSortertStigende der denne idéen brukes.  
6. Lag en versjon av erSortertStigende som bruker idéene fra både Oppgave 4 og 5. 
7. En heltallstabell som ikke er sortert stigende kan likevel inneholde 
delintervall som er sortert. La f.eks. a = {13, 8, 11, 9, 15, 17, 21, 10, 12, 18}. 
Da er a[1:2] = {8,11}, a[3:6] = {9, 15, 17 og 21} og a[7:9] = {10, 12 og 18} 
sortert stigende. Formelt sett er også a[0:0] = {13} sortert.
i) Lag en metode public static int maksSortertSekvens(int[] a). Den skal 
returnere lengden på det lengste stigende sorterte delintervallet i a. Hvis 
metoden blir brukt på eksemplet over skal den returnere 4. Pass på at svaret 
blir rett også hvis det lengste sorterte delintervallet ligger bakerst.
ii) Utvid metoden fra pkt i) slik at den returnerer en tabell med to verdier der 
første verdi er som i pkt i) og andre verdi er posisjonen til den første verdien 
i det lengste sorterte delintervallet. Hvis lengste sorterte delintervall ikke 
er entydig skal det som ligger lengst til venstre av dem velges.
iii) Utvid metoden fra pkt ii) slik at returtabellem forteller om alle maksimalt 
sorterte delintervaller. For hvert slikt delintervall vil vi ha startindeks og 
antall.  

1.3.6 Utvalgssortering
Det er utviklet dusinvis av ulike sorteringsalgoritmer. Her skal vi se på en 
enkel algoritme som går under navnet utvalgssortering (eng: selection sort). 

En mulig sorteringsidé er å flytte én og én tabellverdi til sin rett sorterte 
plass. En tabellverdi står på rett sortert plass hvis alle verdiene til venstre 
er mindre enn eller lik og alle til høyre er større enn eller lik verdien - se 
Definisjon 1.3.2 a). Utvalgssortering kan ses på som en spesiell anvendelse av 
denne idéen. Vi kan også se på utvalgssortering som en systematisk anvendelse av 
det å finne den største verdien i et tabellintervall. 

Algoritmen starter med en usortert tabell ? markert ved at hele tabellen har grå 
bakgrunn: 
15 8 21 16 5 19 7 23 10 14 3 11 6 17 4 
Figur 1.3.6 a) : Algoritmen starter med en (usortert) tabell. 

Vi starter med å finne den største verdien. Rett sortert plass for den er sist i 
tabellen. Ved å bytte den største verdien (tallet 23) med den som nå ligger sist 
(tallet 4), får vi flyttet den til sin rett sorterte plass: 
15 8 21 16 5 19 7 4 10 14 3 11 6 17 23 
Figur 1.3.6 b) : Den største ligger på rett sortert plass, dvs. sist. 

Neste skritt er å finne den nest største verdien (dvs. tallet 21). Men den 
finner vi som den største verdien i den usorterte (grå) delen. Den rett sorterte 
plassen for den er sist i den grå delen. Vi flytter den dit ved en ombytting, 
dvs. 21 og 17 bytter plass. Dermed vil den sorterte (hvite) delen få én verdi 
til: 
15 8 17 16 5 19 7 4 10 14 3 11 6 21 23 
Figur 1.3.6 c) : Det har blitt en verdi mer i den sorterte (hvite) delen. 

Under algoritmens gang vil tabellen være todelt - venstre del er den usorterte (grå) 
delen og resten den sorterte (hvite) delen. I den sorterte delen ligger alle 
verdiene på sine rette sorterte plasser. Så lenge som den grå delen inneholder 
minst to verdier vil neste skritt være å finne den største i den grå delen og så, 
ved en ombytting, flytte den sist (i den grå delen). Dermed øker den hvite delen 
med en (og den grå avtar med en). Figuren under viser resultatet ved å gjøre 
dette enda en gang: 
15 8 17 16 5 6 7 4 10 14 3 11 19 21 23 
Figur 1.3.6 d) : Resultatet etter tre iterasjoner. 

Vi kan stoppe algoritmen når den grå delen består av nøyaktig én verdi. Alle i 
den hvite delen ligger da på sine rette sorterte plasser og dermed må også den 
første (den ene i den grå delen) ligge på rett sortert plass. Metoden kalles 
vanligvis utvalgssortering (eng: selection sort) fordi vi hele tiden velger den 
største i den usorterte delen. Metoden kalles også av og til maksimumssortering 
(eng: max sort). 

Vi kan bruke metodene maks og bytt fra samleklassen Tabell som en del av koden 
for denne algoritmen. Husk syntaksen: int maks(int[] a, int fra, int til). Når 
vi skal finne den største i den grå delen må fra være 0 og til posisjonen til 
den første i den hvite delen. Vi trenger derfor en hjelpevariabel k som hele 
tiden holder på posisjonen til den første i den hvite delen. Den settes til a.length 
før algoritmen starter. Flg. metode legges i samleklassen Tabell: 

  public static void utvalgssortering(int[] a)
  {
    for (int k = a.length; k > 1; k--)
    {
      // bytter om: største tall i a[0:k> flyttes til plass k-1
      bytt(a,maks(a,0,k),k-1);   // maks ? se Programkode 1.2.1 b)
    }
  }
                Programkode 1.3.6 a) 

Programkode 1.3.6 a) sorterer i stigende rekkefølge. Men hva hvis vi ønsker å 
sortere a avtagende? Vi kan selvfølgelig lage en separat algoritme for det 
formålet. Da kan vi bruke den omvendte idéen: Finn den største og bytt om slik 
at den kommer helt først. Finn så den største av resten, dvs. den nest største, 
og bytt om slik at den kommer nest først, osv. 

Det ville imidlertid være dumt om vi alltid måtte lage to versjoner av hver 
sorteringsmetode - en stigende og en avtagende. Senere, når vi skal lage 
generiske metoder, vil vi lage bare én versjon av hver metode. Isteden vil vi 
styre ordningen ved hjelp parameterverdier. 

Hvis en tabell allerede er sortert, er det lite arbeid som skal til for å få den 
sortert omvendt vei. Vi kan «snu» tabellen, dvs. rotere den om midten slik at 
første verdi kommer sist og siste verdi først, osv. Det er lett å lage en metode 
for det (se også Oppgave 1.3.3.3): 

  public static void snu(int[] a)   // legges i klassen Tabell
  {
    for (int v = 0, h = a.length - 1; v < h; bytt(a,v++,h--));
  }
                Programkode 1.3.6 b) 

Hvis Programkode 1.3.6 b) er lagt i samleklassen Tabell, vil flg. kode virke: 

  int[] a = {7,5,9,2,10,4,1,8,6,3};     // en usortert heltallstabell
  Tabell.utvalgssortering(a);           // stigende sortering
  Tabell.snu(a);                        // tabellen snus
  Tabell.skriv(a);                      // 10 9 8 7 6 5 4 3 2 1

                Programkode 1.3.6 c) 

Hvor effektiv er utvalgssortering? La n være tabellens lengde. I hvert kall maks(a,0,k) 
utføres k ? 1 sammenligninger. Det sammenlagte antallet blir dermed: 

     n ? 1  +  n ? 2 + ?·? ?·? ?·? ?·? + 3 + 2 + 1   =  n(n ? 1)/2 

Resultatet n(n ? 1)/2 er summen av en aritmetisk rekke. Hvis f.eks. n = 1000 
blir det totalt ca. 500.000 sammenligninger. Antallet kan også skrives som n2/2 
? n/2, dvs. et kvadratisk uttrykk i n. Algoritmen er derfor av kvadratisk orden 
eller av orden n2. Det betyr at hvis vi dobler antall verdier som skal sorteres, 
vil antall sammenligninger bli fire ganger så stort. 

Utvalgssortering er ineffektiv ? i hvert fall hvis vi skal sortere mange verdier. 
Men metoden har idéer som kan være nyttige i andre sammenhenger. 

Metoden i Programkode 1.3.5 b) finner antallet forskjellige verdier i en tabell 
gitt at den er sortert. Hvis den er usortert og inneholder mange like verdier, 
kan det være mer effektivt å flytte om på verdiene med en teknikk av samme type 
som i utvalgssortering. Flyttingen gjøres da slik at de som er forskjellige 
kommer i første del, dvs. i a[0:n> der n er antallet forskjellige verdier. Flg. 
metode gjør dette og returnerer n: 

  public static int antallForskjelligeUsortert(int[] a)
  {
    int n = a.length;
    for (int i = 0; i < n; i++)
    {
      int verdi = a[i];              // a[0:i] har forskjellige verdier
      for (int j = i + 1; j < n; )   // a[i+1:n> er leteområdet
        if (a[j] == verdi)           // a[j] er en duplikatverdi
          Tabell.bytt(a,j,--n);      // a[n:a.length> er duplikatområdet
        else  j++;
    }
    return n;      // a[0:n> inneholder de forskjellige verdiene
  }
                Programkode 1.3.6 d) 

Oppgaver til Avsnitt 1.3.6 
1. Figur 1.3.6 d) viser resultatet etter tre iterasjoner. Lag en tegning som 
viser resultatet etter i) seks og etter ii) ni iterasjoner. 
2. Lag metoden public static void utvalgssortering(int[] a, int fra, int til). 
Den skal sortere intervallet a[fra:til>. 
3. En kan implementere utvalgssortering ved å bruke utvalgsidéen omvendt vei (da 
kalles det minimumssortering): Finn den minste verdien. Flytt den først ved 
hjelp av en ombytting. Finn så den minste av de øvrige (dvs. den nest minste). 
Flytt den (ved hjelp av en ombytting) nest først, osv. Lag en metode som gjør 
dette. Her skal du lage all koden selv, dvs. ikke bruke hjelpemetoder. 
4. Hvor mange tilordninger er det i gjennomsnitt i versjonen i Oppgave 3?  
5. En sorteringsalgoritme kalles stabil hvis like verdier har samme innbyrdes 
rekkefølge etter sorteringen som de hadde før. Er utvalgssortering stabil? Hva 
med den i Oppgave 3? 
6. Lag en versjon av utvalgssortering som sorterer tabellen i avtagende 
rekkefølge. 
7. Test at snu-metoden virker som den skal. Dvs. lag en programbit der du snur 
en tabell etter først å ha sortert den stigende. Skriv ut tabellens innhold 
etterpå. 
8. Lag en tilfeldig tabell med n verdier ved hjelp av metoden randPerm fra 
samleklassen Tabell. Mål den tiden som utvalgssortering bruker på å sortere 
tabellen. Finn med prøving og feiling hvor stor n må være for at tidsforbruket 
skal bli ca. 1 sekund. 
9. Lag en versjon av metoden antallForskjellige fra Programkode 1.3.5 b) som 
bytter om verdier i a slik at de som er forskjellige kommer (i sortert 
rekkefølge) først i tabellen og duplikatene (i sortert rekkefølge) bakerst. 
Metoden skal som før returnere antallet forskjellige verdier. 

1.3.7 Søking i en tabell
Vi har tidligere søkt etter den største og den nest største verdien i en tabell. 
En mer vanlig oppgave er å søke etter en bestemt verdi. Hvis tabellen ikke er 
sortert, er vi nødt til å se på én og én verdi inntil vi finner den vi søker, 
eller til vi har sett på alle og kan si at den verdien vi søker ikke er der. 

Vår søkemetode (som ikke krever at tabellen er sortert) returnerer posisjonen 
til den søkte verdien hvis den ligger i tabellen, og returnerer ?1 hvis den ikke 
er der. Hvis det finnes flere forekomster av søkeverdien, returneres posisjonen 
til den første av dem fra venstre. Tabellen og søkeverdien inngår som parametere: 

  public static int søkUsortert(int[] a, int verdi)
  {
    for (int i = 0; i < a.length; i++)
      if (verdi == a[i]) return i;    // verdi funnet

    return -1;   // verdi ikke funnet
  }
               Programkode 1.3.7 a) 

Koden kan optimaliseres. Her, som i tidligere tilfeller, kan sammenligningen i < 
a.length i for-løkken fjernes hvis vi bruker den søkte verdien verdi som 
vaktpost. Se Oppgave 1. 

La n = a.length. I for-løkken i programkode 1.3.7 a) sammenlignes verdi og a[i] 
til sammen n ganger hvis den søkte verdien ikke ligger i tabellen. Men hvor 
mange sammenligninger blir det hvis den søkte verdien ligger der? Vi forenkler 
problemet ved å anta at alle tabellverdiene er forskjellige og at alle har samme 
sannsynlighet for å bli etterspurt. Hvis verdi ligger først holder det med 1 
sammenligning, hvis den ligger nest først trenger vi 2, o.s.v. Tilsammen 1 + 2 + 
?·? ?·? ?·? + n = n(n + 1)/2 sammenligninger og dermed n(n + 1)/2n = (n + 1)/2 
som gjennomsnitt. Søkemetoden er derfor av orden n. 

Hvis tabellen er sortert kan vi forbedre søkealgoritmen. Vi antar at den er 
sortert stigende. Også nå vil vi se på ett og ett tabellelement og returnere 
posisjonen så fort vi finner den søkte verdien. Men, hvis vi under letingen 
passerer forbi der verdien skulle ha ligget, kan vi avbryte. Men hva skal vi da 
returnere? Her er det vanlig å kombinere to ønsker. Vi ønsker for det første å 
returnere et negativt tall for å signalisere at den søkte verdien ikke ligger i 
tabellen. Men vi ønsker også å fortelle hvilken posisjon/indeks verdien ville ha 
hatt dersom den hadde ligget der. Denne indeksen eller posisjonen kalles 
innsettingspunktet. Hvis vi etterpå vil sette inn verdien i tabellen slik at 
sorteringen bevares, må verdien settes inn på denne posisjonen. 

Definisjon 1.3.7 Gitt en verdi som ikke ligger i en (stigende) sortert tabell. 
Hvis den hadde ligget der, ville den hatt en bestemt posisjon p. Denne 
posisjonen kalles verdiens innsettingspunkt (eng: insertion point). 

La p være innsettingspunktet for en verdi som ikke er i tabellen. Hvis verdien 
er mindre enn den minste, dvs. mindre enn den som ligger lengst til venstre i 
tabellen, blir p lik 0. Det betyr at vi ikke kan bruke ?p som returverdi siden ?0 
og 0 er det samme. Kravet er jo at det skal returneres et negativt tall når den 
søkte verdien ikke ligger i tabellen. Metoden skal isteden returnere ?(p + 1). 
Dermed vil returverdien alltid bli negativ (også hvis p er 0). La videre k = ?(p 
+ 1). Da vil ?(k + 1) = p. Dvs. vi kan bruke metodens returverdi, hvis den søkte 
verdien ikke ligger i tabellen, til å beregne innsettingspunktet. 

Flg. metode, som vi kaller lineærsøk fordi vi ser på én og én tabellverdi, gjør 
som beskrevet over. Her vil tabellens siste (og dermed største) verdi fungere 
som en vaktpost. En verdi som er større enn den vil ha k lik a.length som 
innsettingspunkt og for alle andre søkeverdier vil den bli en stoppverdi. Legg 
metoden i samleklassen Tabell. 

  public static int lineærsøk(int[] a, int verdi) // legges i class Tabell
  {
    if (a.length == 0 || verdi > a[a.length-1])
      return -(a.length + 1);  // verdi er større enn den største

    int i = 0; for( ; a[i] < verdi; i++);  // siste verdi er vaktpost

    return verdi == a[i] ? i : -(i + 1);   // sjekker innholdet i a[i]
  }
                Programkode 1.3.7 b) 

Flg. eksempel viser hvordan metoden lineærsøk kan brukes: 

  int[] a = {3,6,7,11,13,14,19,23,25}; // en sortert tabell

  System.out.println(Tabell.lineærsøk(a,19));   // utskrift: 6

  System.out.println(Tabell.lineærsøk(a,22));   // utskrift: -8

               Programkode 1.3.7 c) 

I Programkode 1.3.7 c) returnerer metoden 6 når det søkes etter verdien 19, og 
det stemmer siden 19 ligger på indeks/posisjon 6. Returverdien blir ?8 når det 
søkes etter 22. En negativ returverdi forteller at den søkte verdien ikke ligger 
i tabellen. Tallet 22 hører hjemme mellom 19 og 23 og innsettingspunktet blir 
derfor lik posisjonen til 23, dvs. 7. Men vi kan beregne oss frem til det ved 
hjelp av returverdien. Generelt gjelder at hvis m er en negativ returverdi blir 
innsettingspunktetlik ?(m + 1). I eksemplet: ?(?8 + 1) = 7. 

Er metoden lineærsøk mer effektiv enn søkUsortert? De er like hvis den søkte 
verdien ligger i tabellen. Men de er forskjellige hvis den søkte verdien ikke 
ligger der. En slik verdi kan høre hjemme foran den første, mellom to, eller 
etter den siste verdien. Tilsammen blir det n + 1 mulige innsettingspunkter. 
Hvis alle er like sannsynlige, får vi et gjennomsnitt på n/2 + 2 ? 1/(n+1) ? n/2 
+ 2. Dvs. kun halvparten så mange sammenligninger som i søkUsortert. 

Det finnes vesentlig mer effektive søkemetoder for en sortert tabell enn 
lineærsøk. F.eks. binærsøk som vi skal se på i Avsnitt 1.3.8. Men idéen i 
lineærsøk er viktig. Den vil også virke i situasjoner der verdiene kun kan «leses» 
én vei. Men lineærsøk for tabeller kan forbedres, f.eks. ved å gjøre en serie «hopp» 
under søkingen. La tabellen a inneholde 100 verdier. Da kan vi f.eks. se på hver 
10-ende verdi. Når vi passerer stedet der søkeverdien hører hjemme, vet vi at 
den vil måtte befinne seg blant de 10 siste vi hoppet over. Dermed kan vi lete 
etter søkeverdien blant dem. Bruker vi en «hopplengde» lik kvadratroten av 
tabellens lengde, vil algoritmen bli av orden kvadratrot. Da kalles algoritmen 
for kvadratrotsøk. Se Oppgave 4. 

I lineærsøk i Programkode 1.3.7 c) søkes det etter én bestemt verdi. Men hva 
hvis vi ikke vet nøyaktig hvilken verdi vi søke etter, men kun at den befinner 
seg mellom to skranker fraverdi og tilverdi. De er det aktuelt å få tak i alle 
verdiene mellom skrankene, dvs. alle verdier fra tabellen som et større enn 
eller lik fraverdi og som er mindre enn tilverdi. Dette kalles et intervallsøk 
siden vi søker etter de som befinner seg innenfor et intervall. Eksempel: 
3 8 10 14 14 16 21 24 27 30 32 33 34 37 40 
Figur 1.3.7 a) : Et sortert tabell med 15 verdier 

Hvis vi skal finne alle verdier fra og med f.eks. 20 og til (men ikke med) 30, 
kan det være gunstig å ha en metode som returnerer en tabell som innholder de 
søkte verdiene. I eksemplet i Figur 1.3.7 a) blir det verdiene 21, 24 og 27. Da 
søker vi først etter den første verdien (dvs. 20), og så videre derfra etter den 
andre verdien: 

  public static int[] lineærIntervallsøk(int[] a, int fraverdi, int tilverdi)
  {
    if (a.length == 0 || fraverdi > a[a.length - 1])
      return new int[0]; // returnerer en tom tabell

    int fra = 0;
    while (a[fra] < fraverdi) fra++;

    int til = a.length;

    if (tilverdi <= a[a.length - 1])
    {
      til = fra;
      while (a[til] < tilverdi) til++;
    }

    // intervallet a[fra:til> inneholder de søkte verdiene
    return Arrays.copyOfRange(a, fra, til);
  }
                Programkode 1.3.7 d) 

Hvis tabellen a er tom eller hvis det ikke finnes noen verdier i a som hører 
hjemme i intervallet [fraverdi,tilverdi>, returnerer metoden en tom tabell. 

Flg. eksempel viser hvordan lineærIntervallsøk kan brukes: 

  // Tabellen i Figur 1.3.7 a)
  int[] a = {3,8,10,14,14,16,21,24,27,30,32,33,34,37,40};

  int[] b = lineærIntervallsøk(a,20,30);
  Tabell.skriv(b);

  // Utskrift: 21 24 27

                Programkode 1.3.7 e) 

Epilog: I neste avsnitt skal vi se på metoden binærsøk som er langt bedre enn 
lineærsøk når tabellen er sortert. Men det vi har gjort er ikke dermed 
bortkastet. Det vil vise seg at når vi skal søke i lineære strukturer der det 
kun er mulig å bevege seg i én retning (f.eks. pekerkjeder), vil idéen som 
brukes i lineærsøk være den eneste mulige. Dessuten er lineærsøk best for små 
tabeller, f.eks. opp til 8-10 verdier. Det kommer av at det er få ekstra 
omkostninger knyttet til hver sammenligning. Det er også mulig å forbedre 
lineærsøk ved å bruke «hopplengder» - se Oppgave 4. 

I lineærsøk (og i binærsøk i neste avsnitt) sammelignes to og to verdier. Det 
betyr at den kan brukes for andre datatyper enn heltall. Den vil virke for 
enhver datatype der verdiene kan sammenlignes, f.eks. tegn (char) og 
tegnstrenger (String). Men hvis tabellen inneholder tall, er det mulig å gjøre 
søkingen vesentlig mer effektiv. Da er det mulig å søke seg direkte til det 
området der den søkte verdien ligger. Ta utgangspunkt i flg. tabell: 
3 8 10 14 16 19 21 24 27 30 32 33 34 37 40 43 45 46 48 50 
Figur 1.3.7 b) : Et sortert tabell med 20 verdier 

Lag et koordinatsystem med indeksene på x-aksen og verdiene på y-aksen. Hvis vi 
da f.eks. skal søke etter verdien 14, ser vi at vi må lete begynnelsen av 
tabellen. Vi kan starte søket i posisjon (14 - 3)*(20 - 1)/(50 - 3) = 4. Vi går 
mot høyre hvis a[4] er for liten og mot venstre hvis den er for stor. En slik 
teknikk kalles interpolasjonssøk: 

  public static int interpolasjonssøk(int[] a, int verdi)
  {
    if (a.length == 0 || verdi < a[0]) return -1;
    else if (verdi > a[a.length - 1]) return -(a.length + 1);
    else if (a[0] == a[a.length - 1]) return 0;

    int k = (verdi - a[0])*(a.length-1)/(a[a.length-1] - a[0]);

    if (a[k] < verdi) while (a[k] < verdi) k++;
    else while (a[k] > verdi) k--;

    return a[k] == verdi ? k : (a[k] > verdi ? -(k + 1) : -(k + 2));
  }
                Programkode 1.3.7 f) 

Oppgaver til Avsnitt 1.3.7 
1. Bruk en «vaktpost» (den søkte verdien) i Programkode 1.3.7 a). Pass på 
spesialtilfellet at det er den bakerste verdien vi søker etter. 
2. La tabellen a være som i Programkode 1.3.7 c). Hva vil lineærsøk returnere 
hvis vi søker etter verdiene i) 0, ii) 2, iii) 8, vi) 11 og v) 26? 
3. Hvis den søkte verdien forekommer flere ganger i tabellen a, vil posisjonen 
til den første av dem (fra venstre) bli returnert. Lag en versjon av lineærsøk 
der det er posisjonen til den siste av dem som returneres. 
4. I metoden lineærsøk (Programkode 1.3.7 b) sammenligner vi én og én verdi i 
tabellen inntil vi passerer verdien eller passerer det stedet der den skulle ha 
ligget. Dette kan forbedres hvis vi «hopper» bortover i tabellen. La oss si at 
tabellen a har 100 verdier. Da kan vi f.eks. se på hver 10-ende verdi inntil vi 
har kommet langt nok (eller eventuelt havnet utenfor tabellen). Den søkte 
verdien må da, hvis den er i tabellen, ligge blant de 10 siste verdiene.  
a) Lag metoden public static int lineærsøk(int[] a, int k, int verdi). Der skal 
a og verdi være som i vanlig lineærsøk. Parameter int k (et positivt heltall) er 
«hopplengden». I beskrivelsen over var k lik 10. Metoden skal returnere nøyaktig 
det samme som vanlig lineærsøk, også i det tilfellet den søkte verdien ikke 
finnes. 
b) Test metoden fra i) med ulike verdier på k (k = 1 gir vanlig lineærsøk). 
c) Hvis «hopplengden» k settes lik heltallsdelen av kvadratroten til tabellens 
lengde, får vi den beste utnyttelsen av metodens idé. Hvilken orden vil metoden 
da få? Obs. I Java kan vi bruke koden (int)Math.sqrt(n) til å finne 
heltallsdelen til kvadratroten til n.  
5 Sjekk at Programkode 1.3.7 f) virker. Hvis tabellen har like verdier, vil ikke 
metoden nødvendigvis returnere posisjonen til den første av dem. Lag koden slik 
at det skjer. 


1.3.8 Binærsøk
Keiser Augustus 
I maktpolitikk og krig brukes splitt og hersk (eng: divide and conquer). Det har 
romersk opprinnelse. På latin heter det divide et impera. Det handler om å gjøre 
motstanderne innbyrdes uenige for så å overvinne dem enkeltvis. Den idéen kan vi 
bruke. Hvis et problem skal løses, kan det ofte lønne seg å dele problemet i to 
eller flere mindre problemer, løse hvert av dem for seg og så sette det sammen 
til en løsning for hele problemet. Idéen er at det er enklere å løse en mindre 
versjon av et problem enn å løse en stor versjon av det samme problemet. 

Vi prøver flg. idé: Det går raskere å søke i halvparten enn i hele tabellen. I 
en sortert tabell kan vi hoppe inn på midten. Hvis søkeverdien ikke ligger der, 
kan vi avgjøre på hvilken side av midten vi skal lete videre. Dermed får vi 
halvert søkeområdet. Idéen kalles binærsøk. Den omtales ofte som en splitt og 
hersk-metode, men et mer korrekt navn er forminsk og hersk (eng: decrease and 
conquer). 

Vi skal generelt søke i et lukket intervall a[v:h] der v står for venstre og h 
for høyre. Midten m er gitt ved m = (v + h)/2. Vi kan tenke på én av to måter: 

?1.?Den søkte verdien ligger enten på midten (a[m]) eller på en av sidene (?a[v:m?1] 
eller a[m+1:h]?). Søkeområdet blir delt i tre - et punkt og to lukkede 
delintervaller. 

?2.?Alternativt kan vi nøye oss med å dele søkeområdet i to deler. Dvs. vi 
avgjør om den søkte verdien ligger i a[v:m] eller i a[m+1:h]. 

Vi starter med 1. måte. Flg. tabellintervall a[v:h] med 15 verdier er gitt. Anta 
at vi skal finne verdien 30. Fra starten av er hele søkeområdet markert med grå 
bakgrunn: 
3 8 10 14 14 16 21 24 27 30 32 33 34 37 40 
v  m  h 
Figur 1.3.8 a) : Et sortert tabellintervall med 15 verdier 

Midten er gitt ved m = (v + h)/2. Figuren viser at a[m] er lik 24. Vår søkeverdi 
30 er er større enn a[m]. Den må da eventuelt ligge til høyre for m. Vi setter v 
= m+1 og fortsetter: 
3 8 10 14 14 16 21 24 27 30 32 33 34 37 40 
v  m  h 
Figur 1.3.8 b) : Søkeområdet (den grå delen) er halvert 

På nytt er m satt lik (v + h)/2. Søkeverdien 30 er heller ikke nå lik a[m] (dvs. 
33), men derimot mindre. Dermed må den eventuelt ligge til venstre for m. Nå 
settes h = m ? 1: 
3 8 10 14 14 16 21 24 27 30 32 33 34 37 40 
v m h  
Figur 1.3.8 c) : Søkeverdien 30 ligger midt i søkeområdet 

Nå ser vi at søkeverdien 30 er lik a[m]. Vi kan avslutte søkingen og returnere 
posisjonen. 

Vi får flg. algoritme: Del a[v:h] i tre deler: a[v:m?1], a[m] og a[m+1:h]. Hvis 
søkeverdien er lik a[m], er vi ferdige. Hvis ikke, avgjør om den ligger i a[v:m?1] 
eller i a[m+1:h]. Halveringene fortsetter inntil søkeverdien er lik a[m] eller 
at v > h, dvs. a[v:h] er tomt. Hvis v > h, blir v lik søkeverdiens 
innsettingspunkt (se Definisjon 1.3.7). Dermed kan vi returnere (som for 
lineærsøk i Programkode 1.3.7 b?) det negative tallet ?(v?+?1). 

Obs. Hvis vi søker i et intervall etter en verdi som ligger utenfor intervallet, 
vil returverdien gi oss et relativt innsettingspunkt. Eksempel: La a = {3,7,8,10,12,15,20}. 
Hvis vi f.eks. søker etter 2 i intervallet {10,12,15}, vil vi få returnert 
tallet ?4. Det betyr at ?(?4 + 1) = 3 er innsettingspunkt for 2 relativt til 
delintervallet {10,12,15}, dvs. 2 hører hjemme rett foran 10. Men relativt til 
hele a er innsettingspunktet til 2 helt først, dvs. posisjon 0. Dette må en være 
oppmerksom på hvis algoritmen skal brukes på delintervaller: 

  public static int binærsøk(int[] a, int fra, int til, int verdi)
  {
    Tabell.fratilKontroll(a.length,fra,til);  // se Programkode 1.2.3 a)

    int v = fra, h = til - 1;  // v og h er intervallets endepunkter

    while (v <= h)    // fortsetter så lenge som a[v:h] ikke er tom
    {
      int m = (v + h)/2;      // heltallsdivisjon - finner midten
      int midtverdi = a[m];   // hjelpevariabel for midtverdien

      if (verdi == midtverdi) return m;          // funnet
      else if (verdi > midtverdi) v = m + 1;     // verdi i a[m+1:h]
      else  h = m - 1;                           // verdi i a[v:m-1]
    }

    return -(v + 1);    // ikke funnet, v er relativt innsettingspunkt
  }
                Programkode 1.3.8 a) 

  public static int binærsøk(int[] a, int verdi)  // søker i hele a
  {
    return binærsøk(a,0,a.length,verdi);  // bruker metoden over
  }
                Programkode 1.3.8 b) 

Inne i while-løkken i Programkode 1.3.8 a) tester vi først om søkeverdien verdi 
er lik midtverdien. Er dette den beste måten? Et alternativ er først å teste om 
om verdi f.eks. er større enn midtverdien. Når flere tester skal utføres etter 
hverandre er det normalt ikke uvesentlig i hvilken rekkefølge dette foregår: 

Viktig programmeringsregel: Hvis man i en valgsituasjon har mer enn to utfall, 
skal man alltid teste i rekkefølge etter synkende sannsynlighet. Dvs. først 
teste på det som har størst sannsynlighet for å inntreffe, dernest det som har 
nest størst sannsynlighet, osv. 

I noen situasjoner der det er flere utfall, kan det være vanskelig å vite 
hvilken sannsynlighet de forskjellige utfallene har. I valgsituasjonen i while-løkken 
i Programkode 1.3.8 a) er det imidlertid enkelt. Det er tre muligheter eller 
utfall: 1) den søkte verdien ligger på midten, 2) den ligger til høyre for 
midten eller 3) den ligger til venstre for midten. Det er bare én verdi på 
midten, men normalt mange på hver side. Det betyr at det er langt mer sannsynlig 
at den søkte verdien ligger på en av sidene enn at den ligger på midten. Hvis a[v:h] 
inneholder et odde antall verdier (dvs. h???v+1 er odd), vil høyre og venstre 
side av midten ha nøyaktig like mange verdier. Men hvis a[v:h] har et like 
antall verdier, vil området til høyre for midten m = (v + h)/2 (obs. 
heltallsdivisjon) inneholde én verdi mer enn området til venstre. 

Vi burde derfor få en mer effektiv implementasjon av binærsøk hvis vi endrer på 
rekkefølgen av testene. Endringene i forhold til Programkode 1.3.8 a) er uthevet: 

  // 2. versjon av binærsøk - returverdier som for Programkode 1.3.8 a)
  public static int binærsøk(int[] a, int fra, int til, int verdi)
  {
    Tabell.fratilKontroll(a.length,fra,til);  // se Programkode 1.2.3 a)
    int v = fra, h = til - 1;    // v og h er intervallets endepunkter

    while (v <= h)  // fortsetter så lenge som a[v:h] ikke er tom
    {
      int m = (v + h)/2;     // heltallsdivisjon - finner midten
      int midtverdi = a[m];  // hjelpevariabel for  midtverdien

      if (verdi > midtverdi) v = m + 1;        // verdi i a[m+1:h]
      else if (verdi < midtverdi) h = m - 1;   // verdi i a[v:m-1]
      else return m;                           // funnet
    }

    return -(v + 1);   // ikke funnet, v er relativt innsettingspunkt
  }
                Programkode 1.3.8 c) 

I while-løkken i Programkode 1.3.8 a) utføres sammenligningen if (verdi == 
midtverdi) først. Men den vil sjelden være sann fordi det som sagt er langt mer 
sannynlig at den søkte verdien ligger på én av sidene. Det betyr at det nesten 
alltid må utføres enda en sammenligning. Dvs. i gjennomsnitt ca. 2 
sammenligninger i hver runde. I Programkode 1.3.8 c) starter det med if (verdi > 
midtverdi). Den vil være sann ca. annenhver gang. Dermed vil det bli utført 
omtrent i gjennomsnitt 1,5 sammenligninger i hver runde. En forbedring på 25 
prosent! 

Den tredje versjonen av binærsøk tar utgangspunkt i alt. 2 fra avsnittets 
innledning. Søkeområdet deles kun i de to delene a[v:m] og a[m+1:h]. Dermed er 
det nok å utføre én sammenligning i hver runde. Det må imidlertid sjekkes helt 
til slutt om den verdien som algoritmen stopper på, er den søkte verdien eller 
ikke. Koden blir slik: 

  // 3. versjon av binærsøk - returverdier som for Programkode 1.3.8 a)
  public static int binærsøk(int[] a, int fra, int til, int verdi)
  {
    Tabell.fratilKontroll(a.length,fra,til);  // se Programkode 1.2.3 a)
    int v = fra, h = til - 1;  // v og h er intervallets endepunkter

    while (v < h)  // obs. må ha v < h her og ikke v <= h
    {
      int m = (v + h)/2;  // heltallsdivisjon - finner midten

      if (verdi > a[m]) v = m + 1;   // verdi må ligge i a[m+1:h]
      else  h = m;                   // verdi må ligge i a[v:m]
    }
    if (h < v || verdi < a[v]) return -(v + 1);  // ikke funnet
    else if (verdi == a[v]) return v;            // funnet
    else  return -(v + 2);                       // ikke funnet
  }
                Programkode 1.3.8 d) 

Denne 3. versjonen av binærsøk har i tillegg til å være litt mer effektiv enn de 
to andre, også en fordel når tabellintervallet vi søker i har like verdier. Anta 
at søkeverdien forekommer to eller flere ganger. Da vil vi ikke kunne vite hvem 
av dem som versjon 1 (eller versjon 2) returnerer posisjonen til. Men med 3. 
versjon av binærsøk er det annerledes. Gitt flg. tabell: 
2 5 6 9 10 12 15 17 19 19 19 19 22 23 25 
0  7  14 
Figur 1.3.8 d) : Et sortert intervall der verdien 19 forekommer fire ganger 

Vi skal finne 19 og den forekommer fire ganger i tabellintervallet. Når while-løkken 
i Programkode 1.3.8 d) starter har vi tabellintervallet a[0:14]. Midten er (0 + 
14)/2 = 7. Nå er 19 større enn a[7] og dermed blir v satt lik 8. Nytt søkeområde 
blir a[8:14]: 
2 5 6 9 10 12 15 17 19 19 19 19 22 23 25 
8  11  14 
Figur 1.3.8 e) : Søkeområdet (grå bakgrunn) har blitt halvert 

Midten i søkeområdet (grå bakgrunn) er nå lik (8 + 14)/2 = 11. Nå er søkeverdien 
19 ikke større enn a[11]. Dermed settes h lik 11. Nytt søkeområde blir a[8:11]: 
2 5 6 9 10 12 15 17 19 19 19 19 22 23 25 
8 9  11  
Figur 1.3.8 f) : Søkeområdet (grå bakgrunn) har blitt halvert igjen 

Nå består søkemrådet av de fire forekomstee av 19, men algoritmen fortsetter 
likevel inntil søkeområdet består av kun én verdi, dvs. til v er lik h. Først 
blir området lik a[8:9] siden midten er (8 + 11)/2 = 9. Til slutt blir 
søkeområdet lik a[8:8] = a[8]: 
2 5 6 9 10 12 15 17 19 19 19 19 22 23 25 
8 9  
2 5 6 9 10 12 15 17 19 19 19 19 22 23 25 
8  
Figur 1.3.8 g) : while-løkken stppper når v er lik h 

Vi ser at v (her lik 8) stopper på den lengst til venstre av de fire 
forekomstene av 19. Dette er ikke tilfeldig! Det er kun setningen if (verdi > a[m]) 
v = m + 1; som «flytter» på v. Det betyr at når while-løkken stopper er enten v 
uforandret eller så er verdien rett til venstre for v mindre enn søkeverdien 
verdi. Dermed må a[v] inneholde første forekomst fra venstre av søkeverdien hvis 
den forekommer flere ganger. 

Hvis vi søker etter en verdi som ikke ligger i tabellen vil v, med ett unntak, 
stoppe på verdiens innsettingspunkt (se Definisjon 1.3.7). Hvis vi søker etter 
en verdi som er større enn den siste i tabellen, vil v stoppe på den siste 
posisjonen. Men da er innsettingspunktet en videre til høyre. Eksempel: Vi skal 
finne 26. Da får vi denne sekvensen av delintervaller: a[0:14], a[8:14], a[12:14] 
og til slutt a[14:14]. Men innsettingspunktet er 15. Derfor må metoden returnere 
?(v + 2) i dette tilfellet. 

Konklusjon: Vi har sett på flere algoritmer for å søke i en sortert tabell. Ved 
å gjøre noen enkle forutsetninger er det mulig å finne formler for det 
gjennomsnittlige antallet sammenligninger som trengs for å finne en verdi i en 
tabell. Det er: Tabellen skal være sortert stigende, alle verdiene skal være 
forskjellige og alle skal ha samme sannsynlighet for å bli etterspurt. I 
tilfellet lineærsøk med kvadratroten til tabellens lengde n som hopplengde (se 
Oppgave 1.3.7.4), må n være et kvadrattall. I binærsøk må n være på formen 2k ? 
1 for 1. og 2. versjon og på formen 2k for 3. versjon. Tabellengden n kan heller 
ikke være liten. Under disse forutsetningene får vi følgende formler (se Avsnitt 
1.3.9) og tilnærmingsverdier for tilfellene n = 10, n = 100, n = 10.000 og n = 1.000.000: 
Søkealgoritme Det gjennomsnittlige antallet sammenligninger 
Navn Formel n = 10 n = 100 n = 10.000 n = 1.000.000 
Lineærsøk, vanlig (n + 1)/2 + 2 7,5 52,5 5002,5 500.002,5 
Kvadratrotsøk n1/2 + 2 5,2 12 102 1002 
Binærsøk, 1. versjon 2?·?log2(n+1) - 3 4,8 10,3 23,6 36,9 
Binærsøk, 2. versjon 1,5?·?log2(n+1) - 1 4,8 9,0 18,9 28,9 
Binærsøk, 3. versjon log2(n) + 1 4,4 7,7 14,3 20,9 
Tabell 1.3.8 : Formler for gjennomsnittlig antall sammenligninger i 
søkealgoritmer.
Verdiene for binærsøk med n = 10 er funnet direkte, uten bruk av formlene. 

Det liten forskjell på algoritmene hvis tabellen har få verdier. Det ser ut som 
om vanlig lineærsøk er litt dårligere enn de andre for n = 10. Men i 
virkeligheten er den best for såpass få verdier. Det kommer av at det der er 
færre omkostninger knyttet til hver sammenligning. Men når n blir stor ser vi at 
de forskjellige versjonene av binærsøk er overlegent best Hvis f.eks. n er lik 1 
million vil vanlig lineærsøk kreve 500.000 sammenligninger, mens de tre 
versjonene av binærsøk krever i gjennomsnitt henholdsvis 37, 29 og 21 
sammenligninger. 

Alle de tre versjonene av binærsøk er svært effektive (av orden log2(n)). En 
ekstra fordel med 3. versjon er at hvis søkeverdien forekommer flere ganger, vil 
den alltid returnere posisjonen til den første av dem fra venstre. Det kan være 
en nyttig. Derfor bør det være 3. versjon som legges inn i samleklassen Tabell. 
De som har laget klassebiblioteket java.util har forøvrig valgt 2. versjon. Se 
int binarySearch(int[] a, int key) i class Arrays. 

Binærsøk kan også brukes til å lage en effektiv versjon av intervallsøk, dvs. få 
tak i alle verdiene mellom to skranker fraverdi og tilverdi. Intervallsøk er 
spesielt nyttig når vi skal søke blant ord. Hvis vi f.eks. skal ha tak i alle 
ordene som starter med "Ha", kan vi bruke "Ha" som fraverdi og "Hb" som tilverdi. 
Søking i tabeller med ord (tegnstrenger) servi nærmere på i Delkapittel 1.4 om 
Generiske algoritmer. 

Til intervallsøk i en heltallstabell bruker vi 3. versjon av binærsøk. Et søk 
etter fraverdi, vil gi posisjonen til den første forekomsten hvis det er flere 
forekomster, eller eventuelt innsettingspunktet hvis den ikke finnes. De øvrige 
aktuelle verdiene finner vi fra og med denne og videre. Hvis det er få av dem 
som er mindre enn tilverdi, kan det være mest lønnsomt å hente ut én og én (se 
Oppgave 6). Hvis det er mange, vil det være mest effektivt å la binærsøk gi oss 
posisjonen (eller eventuelt innsettingspunktet) til tilverdi. Vi kaller metoden 
binærIntervallsøk: 

  public static int[] binærIntervallsøk(int[] a, int fraverdi, int tilverdi)
  {
    int fra = binærsøk(a,0,a.length,fraverdi);  // 3. versjon av binærsøk

    if (fra < 0) fra = -(fra + 1);  // posisjon eller innsettingspunkt

    // Søker i a[fra:a.length>
    int til = binærsøk(a,fra,a.length,tilverdi);  // 3. versjon av binærsøk

    if (til < 0) til = -(til + 1);  // posisjon eller innsettingspunkt

    // Intervallet a[fra:til> inneholder de aktuelle verdiene
    return Arrays.copyOfRange(a, fra, til);
  }
                Programkode 1.3.8 e) 

Flg. eksempel viser hvordan binærIntervallsøk kan brukes: 

  int[] a = {3,8,10,14,14,16,21,24,27,30,32,33,34,37,40};

  int[] b = Tabell.binærIntervallsøk(a,20,30);
  Tabell.skriv(b);

  // Utskrift: 21 24 27

                Programkode 1.3.8 f) 

Oppgaver til Avsnitt 1.3.8 
1. Sjekk at alle de tre binærsøk-versjonene gir rett resultat. Hvis du vil bruke 
alle i samme program kan de f.eks. omdøpes til binærsøk1, binærsøk2 og binærsøk3. 
2. Hvis vi bruker 1. eller 2. versjon av binærsøk til å søke etter en verdi som 
forekommer flere ganger, vil vi ikke kunne vite hvem av dem som den returnerte 
posisjonen hører til. Gitt verdiene: 1, 3, 4, 4, 5, 7, 7, 7, 7, 8, 9, 10, 10, 12, 
15, 15, 15. Anta at vi bruker 1. versjon av binærsøk til å søke etter i) 4, ii) 
7, iii)10 og iv)15. Hvilken av verdiene hører da den returnerte posisjonen til? 
Obs. Det er det samme om vi bruker 1. eller 2. versjon. De gir alltid de samme 
returposisjonene. 
3. Versjon 3 av binærsøk returnerer alltid posisjonen til den første av dem hvis 
verdien det søkes etter forekommer flere ganger. Sjekk at det stemmer for 
tallene i oppgave 2. 
4. Vanligvis brukes m = (v+h)/2 som midtpunkt. Det blir korrekt når intervallet 
har et odde antall verdier. Hvis antallet er et partall, vil m bli posisjonen 
rett til venstre for den egentlige midten. Vis at hvis vi setter m = (v+h+1)/2 
vil m være det korrekte midtpunktet for et odde antall verdier og være 
posisjonen rett til høyre for den egentlige midten når antallet er et partall. 
5. Lag en 4. versjon av binærsøk. Den skal som 3. versjon dele intervallet i to 
deler i hver runde, men den skal returnere posisjonen til den siste av dem hvis 
verdien det søkes etter forekommer flere ganger. Hint: Oppgave 4 kan være til 
hjelp. 
6. I metoden binærIntervallsøk i Programkode 1.3.8 e) brukes binærsøk til å 
finne posisjonene til både fraverdi og tilverdi. Hvis det normale er at metoden 
anvendes på tilfeller der det er få verdier mellom fraverdi og tilverdi, kan det 
være litt mer effektivt å bruke binærsøk til å finne fraverdi og så søke videre 
lineært etter tilverdi. Lag en versjon av binærIntervallsøk som gjør dette. Pass 
på at den virker som den skal i spesialtilfellene, f.eks. når tabellen a er tom 
eller når tilverdi <= fraverdi.  

1.3.9 Analyse av binærsøk
Tabell 1.3.8 i Avsnitt 1.3.8 (forrige avsnitt) inneholder formler for det 
gjennomsnittlige antallet sammenligninger som utføres i de tre versjonene av 
binærsøk. Slike formler kan vi finne ved å tegne beslutningstrær (eng: decision 
tree). Gitt flg. tabell: 
2 5 6 9 10 12 15 17 19 22 25 30 31 
0 1 2 3 4 5 6 7 8 9 10 11 12 
Figur 1.3.9 a) : En tabell med 13 sorterte verdier 

Vi ser på 1. versjon av binærsøk (Programkode 1.3.8 a). I Figur 1.3.9 a) vil v = 
0 og h = 12. I while-løkken er midten m = (v + h)/2 = (0 + 12)/2 = 6. Tilhørende 
midtverdi a[6] = 15. Hvis den er lik søkeverdien, avslutter vi etter å ha gjort 
kun én sammenligning. Hvis ikke avgjør vi om vi skal lete på høyre eller venstre 
side av midten. Til det trengs én sammenligning til. I neste runde/iterasjon 
kommer vi inn på midten av enten høyre eller eller venstre side. Det blir til m 
= (0 + 5)/2 = 2 eller m = (7 + 12)/2 = 9 med tilhørende verdier lik 6 eller 22. 
Hvis det er en av disse to (6 eller 22) vi søker etter, kan vi avslutte etter å 
ha gjort tilsammen 3 sammenligninger. Hvis ikke må vi halvere igjen og kommer 
til m = 0, 4, 7 eller 11. Osv. 

Dette kan tegnes i et beslutningstre med like mange noder som tabellen har 
verdier. Midtverdien a[6] = 15 legges i rotnoden, midtverdiene på hver side (a[2] 
= 6 og a[9] =22) legges i de to nodene på nivået under, osv.  
Figur 1.3.9 b) : Et beslutningstre 
Treet er verken perfekt eller komplett, men alle nivåene i treet, bortsett fra 
det siste, er fulle av noder. Treet er også ordnet. For hver node gjelder at 
nodeverdien ligger mellom verdiene i dens venstre og dens høyre subtre. Et 
ordnet binærtre eller binært søketre som det kalles, er en viktig datastruktur 
og vi vil arbeide med slike trær i flere kapitler utover. 

I Figur 1.3.9 b) er det et heltall ved hver node. Tallet angir hvor mange 
sammenligninger som skal til i while-løkken i binærsøk, versjon 1, for å finne 
verdien i noden. Hvis vi søker etter verdien i roten (nivå 0) holder det med 1 
sammenligning. Hvis det er en av de to verdiene i neste rad (nivå 1) holder det 
med 3 sammenligninger, for de fire i neste rad (nivå 2) 5 sammenligninger, osv. 
Med andre ord trengs det 2k + 1 sammenligninger for å finne en verdi som ligger 
på nivå k i beslutningstreet. 

Anta at alle de 13 verdiene har samme sannsynlighet for å bli etterspurt og at 
den vi leter etter finnes i tabellen. Det gjennomsnittlige antallet 
sammenligninger blir da 

(1?·?1 + 3?·?2 + 5?·?4 + 7?·?6)/13 = 69/13 = 5,3. 

Treet i Figur 1.3.9 b) mangler to noder på nederste rad for å kunne være perfekt. 
Med andre ord måtte tabellen vi starter med ha hatt 15 verdier for at det skal 
bli 8 noder på nederste rad. Vi ser dermed at et beslutningstre vil bli perfekt 
hvis tabellen har en lengde på 1, 3, 7, 15, 31, 63, osv, eller generelt en 
lengde på 2k ? 1 der k er et posistivt heltall. Formen på et beslutningstre er 
kun bestemt av antall verdier i tabellen. 

Som et nytt eksempel tar vi en tabell med lengde 25 - 1 = 31: 
5 7 10 11 12 15 18 19 20 25 26 29 31 33 36 42 43 48 49 52 53 55 58 62 65 66 68 
69 70 75 77 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 
30 
Figur 1.3.9 c) : En tabell med 31 sorterte verdier 

Figur 1.3.9 d) : Et beslutningstre for 31 verdier basert på Programkode 1.3.8 a) 

Midtverdien a[15] = 42 havner i rotnoden (nivå 0), midtverdiene på hver side (a[7] 
= 19 og a[23] = 62) havner i rotnodens to barn (venstre og høyre barn) på nivå 1, 
osv. Tallet ved siden av hver node er som før det antallet sammenligninger som 
trengs i while-løkken i Programkode 1.3.8 a) for å finne verdien i noden. Vi 
antar at alle de 31 verdiene har like stor sannsynlighet for å bli etterspurt (og 
at alle verdiene er forskjellige). Det gjennomsnittlige antallet sammenligninger 
blir da: 

(1?·?1 + 3?·?2 + 5?·?4 + 7?·?8 + 9?·?16)/31 = 227/31 = 7,3. 

Summen kan også skrives ved hjelp av potenser: 

1?·?20 + 3?·?21 + 5?·?22 + 7?·?23 + 9?·?24 

La antall verdier være n = 2k ? 1 istedenfor 31 (dvs. k = 5) og la Ak være 
summen 

Ak = 1?·?20 + 3?·?21 + 5?·?22 + ?·? ?·? ?·? + (2?·?k ? 1)?·?2k?1 

Summen av denne potensrekken (se Formel 1.9.1.12 i Delkapittel 1.9?) blir: 

Ak = (2?·?k ? 3)?·?2k + 3 

Eksempel: k = 5 gir A5 = (2?·?5 ? 3)?·?25 + 3 = 7?·?32 + 3 = 227. Det passer med 
tegningen. 

Når n = 2k ? 1 blir 2k = n + 1 og k = log2(n+1), og gjennomsnittet for de n 
verdiene: 

[(2?·?k - 3)?·?2k + 3]/n = [(2?·?log2(n+1) - 3)?·?(n+1) + 3]/n 

For store n (1/n liten) blir dette tilnærmet lik 2?·?log2(n+1) ? 3. Hvis n ikke 
er lik 2k ? 1, vil formelen gi (for n stor) en god tilnærming for det 
gjennomsnittlige antallet sammenligninger. 

Beslutningstreet i Figur 1.3.9 d) viser at i det mest ugunstige tilfellet (søkeverdien 
ligger nederst) trengs 2?·?log2(32) ? 1 = 9 sammenligniger, eller generelt 2?·?log2(n+1) 
? 1 stykker. Hvis søkeverdien ikke finnes, går algoritmen til bunns i treet og 
et hakk videre. Dvs. 2?·?log2(32) = 10 eller generelt 2?·?log2(n+1) 
sammenligninger. 

Konklusjon: I 1. versjon av binærsøk trengs kun én sammenligning i det mest 
gunstige tilfellet (søkeverdien ligger på midten av tabellen), 2?·?log2(n+1) ? 3 
sammenligninger i gjennomsnitt, 2?·?log2(n+1) ? 1 i det mest ugunstige tilfellet 
og 2?·?log2(n+1) stykker for å avgjøre at en verdi ikke finnes. 1. versjon er 
dermed av orden log2(n+1) dvs. logaritmisk orden, både i gjennomsnitt og i de 
mest ugunstige tilfellene. 

I 2. versjon av binærsøk (se Programkode 1.3.8 c) ble det gjort flg. endring i 
sammenligningenes rekkefølge i forhold til 1. versjon: 

  if (verdi > midtverdi)
    v = m + 1;                    // verdi må ligge i a[m+1:h]
  else if (verdi < midtverdi)
    h = m - 1;                    // verdi må ligge i a[v:m-1]
  else  return m;                 // funnet 

Denne endringen i koden gir en vesentlig effektivitetsforbedring. Ta tallene i 
Figur 1.3.9 c) som eksempel. Nå trengs to sammenligninger for å finne 
midtverdien 42, dvs. én for å avgjøre at vi ikke skal til høyre og én til for å 
avgjøre at vi ikke skal til venstre. Vi trenger 3 sammenligninger for å finne 62, 
dvs. én sammenligning for å avgjøre at 62 er til høyre for 42 og så to til for å 
avgjøre at vi verken skal til høyre eller til venstre for 62. Vi må imidlertid 
ha 4 sammenligninger for å finne 19. Vi trenger to for å avgjøre at 19 ligger 
til venstre for 42 og så to til for å avgjøre at vi verken skal til høyre eller 
venstre for 19. Osv. 

I Figur 1.3.9 e) står det et heltall ved siden av hver node. Tallet angir hvor 
mange sammenligninger som skal til i while-løkken i binærsøk, versjon 2, for å 
finne den verdien.  
Figur 1.3.9 e) : Et beslutningstre for 31 verdier basert på Programkode 1.3.8 c 

Hvis vi summerer tallene som står ved siden av nodene og deler med 31, vil vi få 
det gjenomsnittlige antallet sammenligninger. Det blir 209/31 = 6,7. Treet i 
Figur 1.3.9 d) gav resultatet 7,3. Dermed har vi fått en forbedring. 

La antall verdier være på formen n = 2k ? 1 istedenfor 31 (som svarer til k = 5) 
og la Ak være det sammenlagte antallet sammenligninger. Kan vi finne en formel 
for Ak? 

Det er lett å finne et gjennomsnitt for hver rad i treet i Figur 1.3.9 e). Ta f.eks. 
4. rad (nivå 3). Der er summen av tallene ved første og siste node lik 8 + 5 = 
13. Den samme summen får vi for andre og nest siste node, dvs. 7 + 6 = 13. Osv. 
Gjennomsnittet for nodene på raden blir dermed 13/2 = 6,5. På samme måte ser vi 
at rad 5 har et gjennomsnitt på 8 og rad 3 et gjennomsnitt på 5. Dermed får vi: 

Ak = 2?·?20 + 3,5?·?21 + 5?·?22 + 6,5?·?23 + ?·? ?·? ?·? + (1,5?·?k + 0,5)?·?2k?1 

Setter vi inn k = 5 blir siste ledd lik (1,5?·?5 + 0,5)?·?24 = 8?·?24. 

Ak er en potensrekke og summen (se Avsnitt 1.3.18.2) blir: 

Ak = (1,5?·?k ? 1)?·?2k + 1 

Eksempel: Hvis k = 5 blir A5 = (1,2?·?5 - 1)?·?25 + 1 = 6,5?·?32 + 1 = 209. 
Dette stemmer med treet i Figur 1.3.9 e). OBS: Ak kan finnes på flere måter. Se 
Avsnitt 1.3.18.2. 

Når n = 2k ? 1 blir k = log2(n?+?1). Gjennomsnittet for de n verdiene blir: 

[(1,5?·?k ? 1)?·?2k + 1]/n = (1 + 1/n)?·?1,5?·?log2(n + 1) - 1 

For store n (dvs. når 1/n er liten) blir dette tilnærmet lik 1,5?·?log2(n?+?1) ? 
1. Hvis n ikke er på formen 2k - 1, gir likevel formelen en god tilnærmingsverdi. 

Det trengs 1,5?·?log2(n?+?1) sammenligninger i gjennomsnitt for å avgjøre at en 
søkeverdi ikke er der. Det kreves flest sammenligninger hvis søkeverdien er lik 
tabellens minste verdi, dvs. 2?·?log2(n?+?1) sammenligninger. 

Konklusjon: I 2. versjon av binærsøk trengs to sammenligninger i det mest 
gunstige tilfellet (søkeverdien ligger på midten av tabellen), 1,5?·?log2(n?+?1) 
? 1 sammenligninger i gjennomsnitt, 2?·?log2(n?+?1) i det mest ugunstige 
tilfellet og gjennomsnittlig 1,5?·?log2(n?+?1) stykker for å avgjøre at en verdi 
ikke finnes. Det betyr at 1. og 2. versjon er av samme orden, men 2. versjon er 
i gjennomsnitt 25% mer effektiv enn 1. versjon. 

I 3. versjon av binærsøk (se Programkode 1.3.8 d) blir analysen mye enklere enn 
for de to første versjonene. Anta at tabellen har en lengde n på formen 2k, dvs. 
n = 2, 4, 8, 16, 32, 64, osv. I denne versjonen av binærsøk ser while-løkken 
slik ut: 

  while (v < h)
  {
    int m = (v + h)/2;
    if (verdi > a[m]) v = m + 1;
    else  h = m;
  } 

Hvis antall verdier i tabellintervallet a[v:h] er på formen 2k vil divisjonen m 
= (v + h)/2 gjøre at intervallene a[v:m] og a[m+1:h] blir eksakt like store, 
begge med 2k?1 verdier. Dvs. at for hver sammenligning if (verdi > a[m]) i while-løkken 
blir søkeområdet a[v:h] nøyaktig halvert. 

Vi ser på et enkelt eksempel med bare 8 verdier, dvs. verdiene 2, 5, 6, 9, 10, 
12, 15,17. Gangen i algoritmen kan illustreres på flg. måte:  
Figur 1.3.9 f) : Tabellintervallene halveres hver gang 

While-løkken går så lenge som v < h, dvs. den stopper når v = h. I eksemplet i 
Figur 1.3.9 f) starter det med 8 = 23 verdier og vi kommer ned til ett 
tabellelement etter 3 iterasjoner eller sammenligninger. Generelt, hvis vi 
starter med n = 2k verdier, vil vi trenge k iterasjoner eller sammenligninger. I 
tilegg trengs en ekstra sammenligning (se Programkode 1.3.8 d?) for å avgjøre om 
den søkte verdien ligger i dettte tabellelementet eller ikke. Til sammen k + 1 
sammenligninger. Men vi kan, siden n = 2k, sette k = log2(n). Dermed blir det 
log2(n) + 1 sammenligninger enten den søkte verdien ligger i tabellen eller ikke. 

Hvis n ikke er på formen 2k, så må det finnes en k slik at 2k < n < 2k+1. Dermed 
vil det gjennomsnittlige antallet sammenligninger ligge mellom log2(n) og log2(n) 
+ 2. 

Konklusjon: Alle de tre versjonene av binærsøk er av logaritmisk orden. Den 3. 
versjonen er noe bedre (33%) enn 2. versjon, og 2. versjon er noe bedre (25%) 
enn 1. versjon. Dermed er det 3. versjon som bør inngå i vårt arsenal av 
søkemetoder for sorterte tabeller, dvs. ligge i samleklassen class Tabell. 

Oppgaver til Avsnitt 1.3.9 
1. Gitt den sorterte tallsekvensen 3, 5, 6, 9, 10, 13, 14, 15, 18, 19, 20, 21.
a) Tegn det beslutningstreet som 1. (eller 2.) versjon av binærsøk gir.
b) Ta utgangspunkt i 1. versjon av binærsøk. Sett opp ved hver node det antallet 
sammenligninger som trengs for å finne nodeverdien. Finn gjennomsnittet.
c) Gjør det samme som i punkt b), men ta nå utgangspunkt i 2. versjon av 
binærsøk.  
2. Gjør som i oppgave 1, men bruk nå den sorterte tallsekvensen 5, 11, 13, 17, 
18, 19, 20, 25, 26, 29, 30, 31, 32, 35, 36.  
3. Gjør som i oppgave 1, men bruk den sorterte tallsekvensen 2, 4, 5, 8, 13, 14, 
15, 18, 19, 22, 23, 24, 28, 29, 33, 35, 36, 37.  
4. Sjekk at formelen Ak = (1,5?·?k ? 1)?·?2k + 1 stemmer for k = 1, 2, 3, 4 og 5. 
Trær med færre nivåer enn det i Figur 1.3.9 e) lages ved fortløpende å fjerne 
nederste rad.  
5. Sjekk at formelen 1,5?·?log2(n+1) - 1 gir en god tilnærmingsverdi for 
gjennomsnittet også når tabellens lengde n ikke er på formen 2k ? 1. Lag et 
testprogram! For en gitt n, la en tabell inneholde tallene fra 1 til n i sortert 
rekkefølge. Bruk så 2. versjon av binærsøk til å søke etter hvert tall fra 1 til 
n. Tell opp antall sammenligninger som utføres hver gang, legg sammen disse og 
finn gjennomsnittet. Sammenlign med formelverdien.  

1.3.10 Innsetting i en tabell
I Java kan en tabell opprettes ved at dens innhold ramses opp. F.eks. slik: 

  int[] a = {3,6,7,11,13,14,19,20,23,25}; 

Men en tabell kan også opprettes ved at det reserveres plass til et bestemt 
antall verdier. I flg. kode får tabellen a plass til 10 heltall og den «nulles» 
(0 legges inn på hver plass): 

  int[] a = new int[10]; 

De to teknikkene kan kombineres. Det kan være nyttig hvis en metode returnerer 
en tabell: 

  int[] a = new int[] {3,6,7,11,13,14,19,20,23,25}; 

Det er knyttet en heltallskonstant med navn length til enhver tabell. Dens verdi 
settes når tabellen opprettes og er lik antall plasser i tabellen, dvs. 
tabellens fysiske lengde eller størrelse. Lengden er konstant og et forsøk på å 
endre den vil gi syntaksfeil: 

  int n = a.length;     // ok setning, n får verdien 10
  a.length = 5;         // syntaksfeil, a.length er konstant 

Vi kan bruke begrepene logisk og fysisk tabell. Setningen int[] a = new int[10]; 
oppretter en fysisk tabell. Den reserveres plass til 10 tall i datamaskinens 
minne. Men a er tom logisk sett siden vi ikke har lagt inn noen verdier ennå (bortsett 
fra start 0-ene). 

En fysisk tabell kan deles i to. Den første (venstre) delen (den som er i bruk) 
inneholder de verdiene vi har lagt inn, og den andre (høyre) delen er ledig. En 
variabel antall kan brukes til å skille mellom de to delene. La den inneholde 
antallet verdier som er lagt inn. Da vil det være den første delen, dvs. fra og 
med posisjon 0 opp til posisjon antall (dvs. a[0:antall>) som utgjør den logiske 
tabellen. Variablen antall fyller to formål: 1) den angir antallet verdier i den 
logiske tabellen og 2) den gir posisjonen til første ledige plass (i den fysiske 
tabellen). 

I flg. eksempel settes de fire tallene 13, 27, 5 og 24 fortløpende inn i en 
tabell: 

  int[] a = new int[10];    // plass til 10
  int antall = 0;           // antall som er lagt inn

  // I utgangspunktet er hele tabellen ledig. Variablen antall angir
  // både antallet verdier og posisjonen til første ledige plass

  a[antall++] = 13;    // 13 legges inn på posisjon 0, antall øker med 1
  a[antall++] = 27;    // 27 legges inn på posisjon 1, antall øker med 1
  a[antall++] =  5;    // 5 legges inn på posisjon 2, antall øker med 1
  a[antall++] = 24;    // 24 legges inn på posisjon 3, antall øker med 1

              Programkode 1.3.10 a) 

Figuren under viser hva den «fysiske» tabellen fra Programkode 1.3.10 a) nå 
inneholder: 
13 27 5 24       
0 1 2 3 4 5 6 7 8 9 
Figur 1.3.10 a): Tabellens innhold 

Det er lagt inn 4 verdier i tabellen, variablen antall har dermed blitt lik 4 og 
den logiske tabellen er lik a[0:4> (eller a[0:3] ). Dvs. slik: 
13 27 5 24 
0 1 2 3 

Programkode 1.3.10 a) viser at det er enkelt å legge inn verdier bakerst i den 
logiske delen. Men skal den inn i en posisjon som allerede er i bruk, må vi vite 
om det er en oppdatering (eng: set) eller en innlegging (eng: add). Oppdatering 
betyr at verdien i posisjonen erstattes med den nye. Innlegging betyr at den nye 
verdien skal komme i tillegg til de som allerede ligger i tabellen. Da flytter 
vi én og én verdi mot høyre slik at posisjonen blir ledig. 

Flg. kode legger inn verdien 18 i posisjon 2 (tabellen a er som over): 

  a[4] = a[3];     // flytter verdien i posisjon 3 til posisjon 4
  a[3] = a[2];     // flytter verdien i posisjon 2 til posisjon 3 

Posisjon 2 er nå ledig og 18 kan legges inn: 
13 27 5 5 24 
0 1 2 3 4 

  a[2] = 18;       // 18 legges inn
  antall++;        // antall økes med 1 

Den logiske tabellen ser nå slik ut: 
13 27 18 5 24 
0 1 2 3 4 

Vi bør ha en mer generell teknikk for å legge inn en ny verdi i en bestemt 
posisjon: 

  int nyverdi = 18, pos = 2;     // ny verdi i posisjon 2

  // flytter en og en verdi mot høyre
  for (int i = antall; i > pos; i--) a[i] = a[i-1];
  a[pos] = nyverdi;     // pos er ledig, ny verdi kan legges inn
  antall++;             // øker antall med 1

              Programkode 1.3.10 b) 

Hva hvis tabellen er full, dvs. antall = a.length?? En mulighet er å «utvide» 
den. En tabell okkuperer et sammenhengende område i maskinens minne. Men den 
delen av minnet som kommer rett etter, kan være i bruk til andre formål. Vi «utvider» 
derfor ved å opprette en ny og større tabell et annet sted i maskinens minne. 
Den gamle kopieres over i den nye, og den gamle går til resirkulering (eng: 
garbage collector). Java har en metode for dette: 

  public static int[] copyOf(int[] a, int nylengde)  // ligger i Arrays
  {
    int[] b = new int[nylengde];            // lager ny og større tabell
    System.arraycopy(a,0,b,0,Math.min(a.length,nylengde));   // kopierer
    return b;
  }
              Programkode 1.3.10 c) 

Metoden copyOf i Programkode 1.3.10 c) hører til klassen Arrays. Den oppretter 
først en ny tabell med lengde lik nylengde. Hvis nylengde er større enn lengden 
til a, kopieres innholdet av a over i den første delen av den nye tabellen, mens 
resten er ledig for vårt bruk. Hvis derimot nylengde er mindre enn lengden til a, 
blir kun den delen av a som får plass, kopiert. Hvis nylengde er negativ, kastes 
et unntak. Den kan f.eks. brukes slik: 

  a = Arrays.copyOf(a,2*a.length);   // a dobles

              Programkode 1.3.10 d) 

En verdi tas ut (fjernes) (eng: remove) fra en tabell ved å gjøre operasjoner av 
samme type som ved en innlegging, men i omvendt rekkefølge. Først tar vi vare på 
verdien i den oppgitte posisjonen, og så flyttes én og én verdi i tabellen mot 
venstre slik at «hullet» tettes igjen. Anta at verdien i posisjon 1 (dvs. 27) 
skal tas ut fra tabellen a ovenfor: 

  int pos = 1;            // verdien på posisjon 1 skal tas ut
  int verdi = a[pos];     // tar vare på verdien i pos

  antall--;               // reduserer antall med 1

  // flytter en og en verdi mot venstre
  for (int i = pos; i < antall; i++)  a[i] = a[i+1];

              Programkode 1.3.10 e) 

Tabellen a kan vi nå tegne slik: 
13 18 5 24 24      
0 1 2 3 4 5 6 7 8 9 
13 18 5 24 
0 1 2 3 
Figur 1.3.10 b): Fysisk tabell til venstre (plass til 10 tall) og logisk tabell 
til høyre 

Legg merke til at verdien 24 ligger på to steder i den fysiske tabellen. En 
flytting av verdier er egentlig en fortløpende kopiering, og for-løkken i 
Programkode 1.3.10 d) avsluttes med at verdien i posisjon 4 kopieres inn i 
posisjon 3. Men variablen antall har fått verdi 4 og dermed består vår logiske 
tabell av kun de 4 første verdiene. Med andre ord spiller det ingen rolle hva 
som befinner seg av verdier i den fysiske tabellen fra og med posisjon antall og 
utover. 

Obs: I Java er det også mulig å lage en tom fysisk tabell. Se på flg. kode: 

  int[] a = null;
  int[] b = new int[0];
  int[] c = {};
  int[] d = new int[]{}; 

Den første setningen gjør at a blir en null-tabell eller en ikke eksisterende 
tabell. Tabellene b, c og d i de tre neste setningene eksisterer, men de er 
tomme eller har lengde 0. Med andre ord er en null-tabell og en tom tabell helt 
forskjellige begreper. 

Oppgaver til Avsnitt 1.3.10 
1. Lag en programbit som tester metoden copyOf i Programkode 1.3.10 c). Opprett 
først en (fysisk) tom heltallstabell og en variabel antall som settes til 0. Lag 
så en for-løkke som fyller tabellen med tallene fra 1 til 100. Hver gang 
tabellen er full skal den «utvides» med 10 plasser, dvs. 10 «utvidelser» til 
sammen. Skriv ut tabellen til slutt. 
2. Lag metoden public static int[] naturligeTall(int n). Den skal returnere en 
heltallstabell som inneholder tallene 1, 2, . . , n. Legg metoden i samleklassen 
Tabell. 

1.3.11 Ordnet innsetting
Hvis en tabell skal holdes sortert kan vi ikke legge inn nye verdier på 
vilkårlige plasser. De må legges inn på rett sortert plass. Hvis en verdi ikke 
ligger i tabellen fra før, har den et veldefinert innsettingspunkt. Se 
Definisjon 1.3.7. 

Men hvis en verdi ligger i tabellen fra før (et duplikat) blir det annerledes. I 
Figur 1.3.11 a) under kommer 18 to ganger. Hvis 18 skal inn en gang til, har vi 
tre mulige posisjoner: Foran den første av de to, mellom de to eller etter den 
andre. Dvs. i posisjonene 2, 3 eller 4: 
5 10 13 15 18 18 24 30 33 
0 1 2 3 4 5 6 7 8 
Figur 1.3.11 a) : En sortert tabell med duplikater 

Vanligvis er det likegyldig hvor et duplikat legges så sant sorteringen bevares. 
Men i noen tilfeller kan det kreves at et duplikat må legges på et bestemt sted 
i forhold til de andre. 

Flg. metode legger inn, gitt at a er sortert og har plass (antall er mindre enn 
a.length), en ny verdi på rett sortert plass. Det er tillatt med like verdier: 

  public static void leggInnSortert(int[] a, int antall, int verdi)
  {
    if (antall >= a.length)
      throw new IllegalStateException("Tabellen a er full!");

    int pos = Tabell.binærsøk(a,0,antall,verdi);

    // fortegnet til pos forteller om verdi finnes fra før eller ikke.
    if (pos < 0) pos = -(pos + 1);  // pos er nå innsettingspunkt

    // flytter verdier mot høyre for å gjøre plass
    for (int i = antall; i > pos; i--) a[i] = a[i-1];
    a[pos] = verdi;  // setter inn verdien
  }
              Programkode 1.3.11 a) 

Flg. eksempel viser hvordan leggInnSortert kan brukes: 

  int[] a = {5,10,13,15,18,18,24,30,33};    // Figur 1.3 11 a)
  int antall = a.length;                    // inneholder 9 verdier

  // hvis a er full, lager vi den dobbelt så stor
  if (antall == a.length) a = Arrays.copyOf(a,2*a.length);

  leggInnSortert(a,antall++,10);   // legger inn 10 og øker deretter antall
  leggInnSortert(a,antall++,18);   // legger inn 18 og øker deretter antall

  Tabell.skriv(a,0,antall);  // metode fra Oppgave 4 i Avsnitt 1.2.2

  // Utskrift: 5 10 10 13 15 18 18 18 24 30 33

              Programkode 1.3.11 b) 

Utskriften i Programkode 1.3.11 b) viser at sorteringen er bevart. Tallene 10 og 
18 er duplikatverdier og i dette tilfellet spiller det ingen rolle hvor de 
havner så sant sorteringen bevares. Hvis vi bruker 1. eller 2. versjon av 
binærsøk i Programkode 1.3.11 a), vil vi ikke kunne vite hvor en duplikatverdi 
blir satt inn i forhold til de forekomstene som måtte ligge der fra før. Men, 
hvis vi bruker 3. versjon av binærsøk eller bruker lineærsøk, vil verdien alltid 
bli satt inn foran de som er der fra før. Vi skal se senere, når vi skal arbeide 
med generiske tabeller, at plasseringen av duplikatverdier vil kunne være av 
betydning. 

Oppgaver til Avsnitt 1.3.11 
1. Lag en versjon av leggInnSortert der et duplikat blir lagt bak de som er der 
fra før.  
2. Lag en forbedret versjon av leggInnSortert med returtype boolean og med en 
ekstra parameter boolean duplikatOk. Hvis duplikatOk settes til sann (true) skal 
verdi settes inn på rett sortert plass på vanlig måte enten den er duplikat 
eller ikke og metoden skal returnere true. Hvis derimot duplikatOk settes til 
usann (false), er det ikke tillatt med duplikatverdier. I så fall skal metoden 
returnere false. Hvis verdi i dette tilfelle ikke er duplikat, skal den settes 
inn på vanlig måte og metoden skal returnere true. Sørg for at metoden kaster en 
feilmelding hvis det ikke er plass i tabellen.  

1.3.12 Innsettingssortering
I innsettingssortering, under algoritmens gang, er tabellen delt i to. Den 
første delen inneholder sorterte og den andre delen usorterte verdier. 
Algoritmen går ut på at den første verdien i den usorterte delen settes inn på 
rett sortert plass i den sorterte delen. Dermed blir det én verdi mer i den 
sorterte delen for hver iterasjon. Det starter ved at den første verdien utgjør 
den sorterte delen og dermed resten den usorterte delen. 

La som eksempel tabellen inneholde verdiene 15, 8, 21, 16, 5, 19, 7, 23, 10, 14, 
3, 11, 6, 17, 4. Nå vi starter er det 15 som utgjør den sorterte delen (den 
hvite delen på figuren under) og resten den usorterte (den grå) delen: 
15 8 21 16 5 19 7 23 10 14 3 11 6 17 4 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
Figur 1.3.12 a) : En tabell med 15 verdier - sortert del inneholder én verdi 

Den første verdien i den usorterte (grå) delen (tallet 8) skal settes inn på 
rett sortert plass i den sorterte (hvite delen). Først flyttes dette tallet til 
en hjelpevariabel slik at den hvite delen får plass til en ekstra verdi: 
8 
15  21 16 5 19 7 23 10 14 3 11 6 17 4 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
Figur 1.3.12 b) : Første verdi i den usorterte delen er flyttet til en 
hjelpevariabel 

Den hvite delen har nå plass til en ekstra verdi. Verdien i hjelpevariablen 
settes inn på rett sortert plass ved at verdier flyttes. Resultatet blir 8 først 
og så 15:  
8 15 21 16 5 19 7 23 10 14 3 11 6 17 4 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
Figur 1.3.12 c) : Den hvite delen inneholder to sorterte verdier 

Vi fortsetter: Den første verdien i den grå delen (tallet 21) flyttes til 
hjelpevariabelen. Dermed får den hvite delen en ekstra plass: 
21 
8 15  16 5 19 7 23 10 14 3 11 6 17 4 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
Figur 1.3.12 d) : Første verdi i den usorterte delen er flyttet til en 
hjelpevariabel 

Verdien i hjelpevariabelen settes så inn på rett sortert plass. I dette 
tilfellet er det nettopp den plassen verdien hadde før vi flyttet den:  
8 15 21 16 5 19 7 23 10 14 3 11 6 17 4 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
Figur 1.3.12 e) : Den hvite delen inneholder tre sorterte verdier 

Bruk av binærsøk er mest effektivt for å finne rett sortert plass. Men vi må 
likevel flytte på verdier for å få satt inn noe på denne plassen. Dermed er det 
flyttingen som blir den kostbare delen av algoritmen. Derfor kan vi like gjerne 
sammenligne og flytte parallelt. 

I mange situasjoner er det aktuelt å kunne sortere et tabellintervall ? for 
eksempel et fra-til-intervall. Det sorteres på samme måte som en hel tabell. Vi 
må imidlertid passe på å starte i posisjon fra istedenfor i 0 og ha posisjon til 
som grense. En metode som sorterer en hel tabell lages ved hjelp av den ved at 
fra settes lik 0 og til = a.length. Flg. metoder legges i samleklassen Tabell: 

  public static void innsettingssortering(int[] a, int fra, int til)
  {
    fratilKontroll(a.length,fra,til);  // se Programkode 1.2.3 a)

    for (int i = fra + 1; i < til; i++)  // a[fra] er første verdi
    {
      int temp = a[i];  // flytter a[i] til en hjelpevariabel

      // verdier flyttes inntil rett sortert plass i a[fra:i> er funnet
      int j = i-1; for (; j >= fra && temp < a[j]; j--) a[j+1] = a[j];

      a[j+1] = temp;  // verdien settes inn på rett sortert plass
    }
  }

  public static void innsettingssortering(int[] a)
  {
    innsettingssortering(a,0,a.length);   // sorterer hele tabellen
  }
              Programkode 1.3.12 a) 

Flg. eksempel viser hvordan metoden kan brukes: 

  int[] a = {15,8,21,16,5,19,7,23,10,14,3,11,6,17,4};
  Tabell.innsettingssortering(a);
  Tabell.skriv(a);

  // Utskrift: 3 4 5 6 7 8 10 11 14 15 16 17 19 21 23

              Programkode 1.3.12 b) 

Hvor effektiv er innsettingssorteringen i Programkode 1.3.12 a)? Vi skal som 
vanlig finne ut hvor mange sammenligninger som utføres. Vi antar at vi skal 
sortere en hel tabell og at den inneholder en tilfeldig samling av n 
forskjellige verdier. Anta at de første i verdiene er sortert, dvs. at verdiene 
a[0]?, a[1]?, ?·? ?·? ?·? , a[i???1] er sortert. Blant disse skal så verdien i 
hjelpevariabelen temp (dvs. a[i]) settes inn og da på rett sortert plass. Det er 
i + 1 forskjellige muligheter. Det er aller først, det er mellom a[0] og a[1], 
mellom a[1] og a[2] osv, eller eventuelt bakerst, dvs. etter a[i???1]. Alle 
plasseringer er like sannsynlige siden verdiene er tilfeldige. 

Vi trenger én sammenligning for å avgjøre om temp skal komme etter a[i???1], to 
sammenligninger for å avgjøre om den skal ligge foran a[i???1], men etter a[i???2], 
osv. Det trengs i sammenligninger både for å avgjøre om temp skal være foran a[0] 
og om den skal ligge mellom a[0] og a[1]. Gjennomsnittet blir (1 + 2 + ?·? ?·? + 
i + i )/(i??+?1) sammenligninger. Det er det samme som i?/?2 + 1 ? 1/(i??+?1). 
Vi summerer fra 1 til n ? 1 og får 

n(n???1)/4 + n ? Hn = n(n?+?3)/4 ? Hn 

Det verste tilfellet får vi hvis tabellen allerede er sortert avtagende. Da er 
sammenligningen temp < a[j] sann for hver eneste j. Dermed blir det i 
sammenligninger i indre løkke, og totalt 1 + 2 + ?·? ?·? + n ? 1 = n(n???1)/2 
sammenligninger. Det beste tilfellet er når tabellen allerede er sortert 
stigende. Da er temp < a[j] aldri sann og antallet blir 1 + 1 + ?·? ?·? ?·? + 1 
= n ? 1. 

Gjennomsnittlig antall sammneligninger i innsettingssortering, gitt at vi har n 
forskjellige verdier, er n(n?+?3)/4 ? Hn sammenligninger. I det verste tilfellet 
vil det være n(n???1)/2 og i det beste tilfellet n ? 1 sammenligninger. 

Innsettingssortering bruker (n2 + 3n)/4 ? Hn sammenligninger i gjennomsnitt for 
en tabell med n forskjellige verdier. Det betyr at algoritmen er av kvadratisk 
orden eller av orden n2. I tabellen under blir den sammenlignet med 
utvalgssortering fra Avsnitt 1.3.6: 
Sorteringsalgoritme Antall sammenligninger 
Navn Gjennomsnittlig Verste tilfelle Beste tilfelle 
Utvalgssortering n(n???1)/2 n(n???1)/2 n(n???1)/2 
Innsettingssortering n(n?+?3)/4 ? Hn n(n???1)/2 n ? 1 
Tabell 1.3.12 a) : Innsettingssortering og utvalgssortering 

Effektiviteten til innsettingssortering varierer med hensyn på hvordan verdiene 
i tabellen er fordelt, men er vesentlig bedre enn utvalgssortering både i 
gjennomsnitt og i det beste tilfellet (dvs. når tabellen er sortert stigende). 
Det finnes langt mer effektive algoritmer enn innsettingssortering, men den 
brukes likevel ganske ofte. Alle algoritmer, og ikke minst sorteringsalgoritmer, 
har faste og variable kostnader. De faste kostnadene er alt det som må gjøres 
uavhengig av antallet verdier som skal behandles. Ulempen med flere av de svært 
effektive algoritmene er at de har høye faste kostnader. Innsettingssortering 
derimot har lave faste kostnader. Derfor er innsettingssortering normalt det 
beste valget for små tabeller eller tabellintervaller, f.eks. hvis antall 
verdier ikke er større enn 10. Den er også gunstig å bruke hvis tabellen på 
forhånd er delvis sortert stigende. 

I sort?metodene i klassen arrays i biblioteket java.util brukes kvikksortering (eng: 
quick sort) for heltallstabeller og flettesortering (eng: merge sort) for objekt-tabeller. 
I begge metodene går man over til å bruke innsettingssortering for små 
delintervaller. Der opereres det med konstanten INSERTIONSORT_THRESHOLD som er 
satt til 7. Dvs. innsettingssortering brukes på tabellintervaller som er kortere 
enn 7. 

Oppgaver til Avsnitt 1.3.12 
1. Figur 1.3.12 e) viser resultatet etter to iterasjoner eller runder. Vis hva 
resultatet blir hvis det utføres fire iterasjoner til, dvs. etter totalt seks 
iterasjoner. 
2. Hvor mange sammenligninger vil det bli i gjennomsnitt hvis 
innsettingssortering brukes på en tabell med 1000 forskjellige tall? Hvor mange 
blir det hvis en isteden bruker utvalgssortering? Se Tabell 1.3.12 a).  
3. En sorteringsmetode kalles stabil hvis like verdier har samme innbyrdes 
rekkefølge etter sorteringen som før. Er innsettingssorteringen i Programkode 1.3.12 
a) stabil? 
4. Programkode 1.3.12 a) kan effektiviseres litt ved hjelp av en "vaktpost". Den 
innerste for-løkken inneholder sammenligningen j >= fra. Den trengs for at vi 
ikke skal havne utenfor tabellintervallet til venstre. Hvis verdien som skal 
settes inn på rett sortert plass er mindre enn den minste, dvs. mindre enn a[fra], 
vet vi at den skal plasseres først i intervallet, dvs. i posisjon fra. Hvis 
verdien ikke er mindre enn a[fra] vil a[fra] fungere som en stoppverdi og da 
trengs ikke sammenligningen j >= fra. Lag en versjon av innsettingssortering som 
bruker denne idéen.  
5. Lag en versjon av innsettingssortering der søkingen etter rett sortert plass 
i a[fra:i> gjøres ved hjelp av binærsøk. Deretter flyttes verdier slik at 
plassen blir ledig. Se f.eks. Programkode 1.3.11 a). 
6. I Programkode 1.3.12 a) settes én og én verdi inn på rett sortert plass. 
Dette kan effektiviseres hvis vi tar to verdier om gangen. De to neste verdiene 
som står for tur sorteres innbyrdes. Så finner vi først rett plass for den 
største av dem. Deretter leter vi videre derfra mot venstre etter rett plass for 
den minste. Lag en metode som bruker denne idéen. Lag først en metode som 
sorterer en hel tabell. Lag så, ved å bearbeide den som sorterer en hel tabell, 
en som sorterer et intervall a[fra:til>. 
7. Idéen fra oppgave 6 kan forbedres. Bruk k verdier der k <= 1. Sortér de k 
første verdiene vha vanlig innsettingssortering. Sortér de neste k verdiene på 
samme måte, flett dem sammen med de k første verdiene. Sortér så de neste k 
verdiene, flett dem sammen med de som nå er sortert. Osv. Lag metoder for dette 
som i oppgave 6.  
8. Lag en metode der metoden fra oppgave 7 kalles opp med k lik heltallsverdien 
til kvadratroten til tabellens størrelse n. Da får vi en sorteringsmetode av 
orden n3/2.  
9. Lag kode som måler tidsforbruket til innsettingssorteringen i Programkode 1.3.12 
a) når den brukes på tilfeldige tabeller. Velg en tabellstørrelse slik at 
tidsforbruket blir på ca. 1 sekund. Gjenta dette for de versjonene du lager i 
oppgave 4, 5, 6, 7 og 8. Sammenlign også med utvalgssortering fra Programkode 1.3.6 
a).  

1.3.13 Fletting av sorterte verdier
Anta at vi har to tabeller som begge er sortert. En viktig oppgave er da å kunne 
slå tabellene sammen, dvs. lage en tabell som inneholder verdiene fra begge to i 
sortert rekkefølge. Da er det mest effektivt å «flette» dem sammen. 
a  1 3 4 6 9 9 11 
i  
b  2 3 5 6 7 8 9 10 12 14 
j  
c                   
k  
Figur 1.3.13 a) : To sorterte tabeller a og b skal flettes sammen i c 

I Figur 1.3.13 a) er det to sorterte tabeller, a med 7 og b med 10 verdier. 
Verdiene skal flettes sammen og legges i en tredje tabell c. Tabellen c har 
plass til de 7 + 10 = 17 sammenflettdede verdiene. Første posisjon (posisjon 0) 
i a, b og c er markert med henholdsvis i, j og k. 

Gangen i dette blir: Sammenlign verdiene a[i] og b[j]. Hvis a[i] er mindre enn 
eller lik b[j] kopieres den over i posisjon k i c og både i og k økes med 1. 
Hvis ikke, dvs. at b[j] er minst, kopieres b[j] over i posisjon k i c og både j 
og k økes med 1. Hvis dette utføres f.eks. fem ganger, får vi flg. tabeller: 
a  1 3 4 6 9 9 11 
i  
b  2 3 5 6 7 8 9 10 12 14 
j  
c  1 2 3 3 4             
k  
Figur 1.3.13 b) : Fem verdier er flettet sammen. 

I mange tilfeller er det aktuelt å kunne flette sammen deler av to tabeller, f.eks. 
tabellintervallene a[0:m> og b[0:n>. Da er det en forutsetning at de to er 
sortert stigende hver for seg. Flg. metode utfører sammenflettingen, legger 
resultatet i tabellen c og returnerer antallet sammenflettede verdier. Tabellen 
c må være stor nok, dvs. ha plass til minst m + n verdier. Metoden legges i 
samleklassen class Tabell: 

  public static int flett(int[] a, int m, int[] b, int n, int[] c)
  {
    int i = 0, j = 0, k = 0;

    while (i < m && j < n)
      c[k++] = a[i] <= b[j] ? a[i++] : b[j++];

    while (i < m) c[k++] = a[i++];   // tar med resten av a
    while (j < n) c[k++] = b[j++];   // tar med resten av b

    return k;   // antallet verdier som er lagt inn i c
  }
              Programkode 1.3.13 a) 

I Programkode 1.3.13 a) blir a[i] < b[j] utført m + n ? 1 ganger hvis tallene i 
a og b er slik at a[i] < b[j] blir sann/usann annenhver gang. F.eks. hvis a = {1,3,5,7,9} 
og b = {2,4,6,8,10}. Hvis siste verdi i a er mindre enn første i b, vil a[i] < b[j] 
bli utført m ganger, og hvis omvendt n ganger. I gjennomsnitt blir det et sted 
mellom min(?m?,?n?) og m + n ? 1 ganger. Det betyr at algoritmen har orden m + n 
i gjennomsnitt. 

Det er praktisk å ha en metode som fletter sammen hele tabeller. En slik metode 
kodes enkelt ved hjelp av flett-metoden i Programkode 1.3.13 a): 

  public static int flett(int[] a, int[] b, int[] c)
  {
    return flett(a,a.length,b,b.length,c);
  }
              Programkode 1.3.13 b) 

Flg. eksempel viser hvordan flett-metoden kan brukes: 

  int[] a = {1,3,4,6,9,9,11};               // sortert tabell
  int[] b = {2,3,5,6,7,8,9,10,12,14};       // sortert tabell
  int[] c = new int[a.length + b.length];   // nå er c stor nok
  Tabell.flett(a,b,c);

  Tabell.skriv(c);

  // Utskrift: 1 2 3 3 4 5 6 6 7 8 9 9 9 10 11 12 14

              Programkode 1.3.13 c) 

Fletting er en viktig teknikk. For eksempel er fletting den essensielle delen i 
flettesortering (eng: merge sort). Idéen er at en tabell kan sorteres ved at 
dens to halvdeler sorteres hver for seg og at de så flettes sammen. Dette 
gjentas rekursivt for hver av de to delene. I flettesortering er det 
nabointervaller som flettes sammen. Se på flg. eksempel:  
Figur 1.3.13 c) : Nabointervallene a[fra:m> og a[m:til> skal flettes sammen. 

Det sorterte intervallet a[fra:m> (den hvite delen) skal flettes sammen med det 
sorterte intervallet a[m:til> (den grå delen). Først kopieres a[fra:m> over i en 
hjelpetabell b. Den må være stor nok til at tallene får plass, dvs. minst ha 
plass til n verdier der n = m ? fra:  
Figur 1.3.13 d) : Delintervallet a[fra:m> er kopiert over i b[0:n>.  

Nå kan b[0:n> og a[m:til> flettes sammen og resultatet kan legges tilbake i a[fra:til>. 
Flg. private hjelpemetode gjør dette: 

  private static void flett(int[] a, int[] b, int fra, int m, int til)
  {
    int n = m - fra;   // antall elementer i a[fra:m>
    System.arraycopy(a,fra,b,0,n); // kopierer a[fra:m> over i b[0:n>

    int i = 0, j = m, k = fra;     // løkkevariabler og indekser

    while (i < n && j < til)  // fletter b[0:n> og a[m:til>, legger
      a[k++] = b[i] <= a[j] ? b[i++] : a[j++];  // resultatet i a[fra:til>

    while (i < n) a[k++] = b[i++];  // tar med resten av b[0:n>
  }
              Programkode 1.3.13 d) 

Det er nå rett frem å lage en rekursiv flettesortering ved hjelp av 
flettemetoden fra Programkode 1.3.13 d). Det er mulig å lage en mer effektiv 
implementasjon enn den nedenfor. Det ser vi nærmere på i et senere kapittel. Se 
også Oppgave 4. 

  private static void flettesortering(int[] a, int[] b, int fra, int til)
  {
    if (til - fra <= 1) return;   // a[fra:til> har maks ett element

    int m = (fra + til)/2;        // midt mellom fra og til

    flettesortering(a,b,fra,m);   // sorterer a[fra:m>
    flettesortering(a,b,m,til);   // sorterer a[m:til>

    flett(a,b,fra,m,til);         // fletter a[fra:m> og a[m:til>
  }

  public static void flettesortering(int[] a)
  {
    int[] b = new int[a.length/2];    // en hjelpetabell for flettingen
    flettesortering(a,b,0,a.length);  // kaller metoden over
  }
              Programkode 1.3.13 e) 

Eksempel på bruk av flettesortering (det forutsettes at metodene ligger i class 
Tabell ): 

  int[] a = {14,22,17,8,20,30,23,14,25,10,27,13,15,20,18};
  Tabell.flettesortering(a);

  Tabell.skriv(a);

  // Utskrift: 8 10 13 14 14 15 17 18 20 20 22 23 25 27 30 

Det vil være situasjoner der tabellene våre ikke inneholder like verdier. Det 
gjelder for eksempel hvis en tabell representerer elementene i en mengde. Vi kan 
slå sammen mengder ved å ta unionen av dem. Det er også en mengde og kan dermed 
ikke inneholde like verdier. Anta at de to tabellintervallene a[0:m> og b[0:n> 
hver for seg ikke inneholder like verdier og at de er sortert stigende. En union-metode 
kan lages på samme måte som flettemetoden i Programkode 1.3.13 a). Hvis en og 
samme verdi ligger både i a og i b, skal den tas med bare én gang, f.eks. ved at 
vi tar med den som ligger i a. Resultatet, dvs. unionen, av de to tabellene, 
legges i c. Metoden som skal ligge i samleklassen class Tabell, skal returnere 
antallet elementer i unionen: 

  public static int union(int[] a, int m, int[] b, int n, int[] c)
  {
    int i = 0, j = 0, k = 0;

    while (i < m && j < n)
    {
      if (a[i] < b[j]) c[k++] = a[i++];
      else if (a[i] == b[j])            // a[i] og b[j] er like
      {
        c[k++] = a[i++];                // tar med a[i]
        j++;                            // hopper over b[j]
      }
      else  c[k++] = b[j++];
    }

    while (i < m) c[k++] = a[i++];      // tar med resten av a[0:m>
    while (j < n) c[k++] = b[j++];      // tar med resten av b[0:n>

    return k;    // antall verdier lagt inn i c
  }
              Programkode 1.3.13 f) 

Metoden union returnerer antallet verdier som blir lagt inn i tabellen c. Dette 
antallet vil bli mindre enn m + n hvis a og b har felles verdier. 

Det kan være praktisk å ha en metode som danner unionen av hele tabeller: 

  public static int union(int[] a, int[] b, int[] c)
  {
    return union(a,a.length,b,b.length,c);
  }
              Programkode 1.3.13 g) 

Flg. eksempel viser hvordan union-metoden kan brukes: 

  int[] a = {1,3,4,6,9,11,13};               // ingen like verdier
  int[] b = {2,3,5,6,7,8,9,10,11,12};        // ingen like verdier
  int[] c = new int[a.length + b.length];    // c er nå stor nok
  int n = Tabell.union(a,b,c);

  Tabell.skriv(c,0,n);   // metode fra oppgave 4 i Avsnitt 1.2.2

  // Utskrift: 1 2 3 4 5 6 7 8 9 10 11 12 13

              Programkode 1.3.13 h) 

Det er en forutsetning at hver av tabellene a og b er sortert stigende og har 
forskjellige verdier for at metoden union skal virke korrekt. Hvis a eller b har 
duplikater, vil også resultattabellen c få duplikater. Hvis f.eks. a = {2,4,4,6} 
og b = {1,3,5}, vil c få innholdet 1,2,3,4,4,5,6. Sjekk i Programkode 1.3.13 f) 
at det blir slik. 

Det har også av interesse å finne de verdiene som er felles for to tabeller. Det 
kaller vi snittet. Metoden snitt legger det som er felles for a[0:m> og b[0:n> 
over i c og antallet verdier i snittet returneres. Det er imidlertid en 
forutsetning at både a[0:m> og b[0:n> er sortert og at ingen av dem har 
duplikater. Flg. metoder skal legges i samleklassen Tabell: 

  public static int snitt(int[] a, int m, int[] b, int n, int[] c)
  {
    int i = 0, j = 0, k = 0;

    while (i < m && j < n)
    {
      if (a[i] < b[j]) i++;      // hopper over a[i]
      else if (a[i] == b[j])
      {
        c[k++] = a[i++];         // a[i] == b[j], tar med a[i]
        j++;
      }
      else  j++;                 // hopper over b[j]
    }

    return k;    // antall verdier i snittet
  }

  // En metode som finner snittet av to hele tabeller:

  public static int snitt(int[] a, int[] b, int[] c)
  {
    return snitt(a,a.length,b,b.length,c);
  }

              Programkode 1.3.13 i) 

Flg. eksempel viser hvordan snitt-metoden kan brukes. Obs. et snitt kan aldri 
inneholde flere verdier enn det som det minste av de to intervallene inneholder: 

  int[] a = {1,3,4,6,9,11,13};                     // ingen like verdier
  int[] b = {2,3,5,6,7,8,9,10,11,12};              // ingen like verdier
  int[] c = new int[Math.min(a.length,b.length)];  // c er nå stor nok

  Tabell.skriv(c,0,Tabell.snitt(a,b,c));

  // Utskrift:  3 6 9 11

              Programkode 1.3.13 j) 

For mengder gitt som sorterte tabellintervaller uten duplikater, er det i 
tillegg til union og snitt også aktuelt å ha metoder som likhet, differans, 
xunion (eksklusiv union) og inklusjon. Differansen A ? B mellom to mengder A og 
B er definert som mengden av de elementene i A som ikke er i B. Vi kan lage en 
differans-metode for tabellintervaller på samme måte som union og snitt, dvs. 
ved å bruke en fletteteknikk. Også xunion (eksklusiv union) og inklusjon kan 
lages slik. Den ekslusive unionen (kalles også den symmetriske differansen) til 
A og B består av de elementene som er i A eller i B, men ikke i begge. Se flg. 
oppgaver: 

Oppgaver til Avsnitt 1.3.13 
1. Figur 1.3.13 b) viser resultatet av flettealgoritmen etter at 5 verdier er 
kopiert over i c. Tegn resultatet etter at henholdsbvis 7, 9 og 11 verdier er 
kopiert over. 
2. La a inneholde tallene 1, 2, 3 og b tallene 4, 5, 6, 7, 8. Hvor mange ganger 
vil sammenligningen a[i] < b[j] i Programkode 1.3.13 a) bli utført hvis metoden 
anvendes på a og b? Hva hvis a og b isteden inneholder 1, 3, 5, 7 og 2, 4, 6, 8? 
3. Test effektiviteten til flettesorteringen i Programkode 1.3.13 e. Lag 
tabeller med tilfeldige heltall (bruk randPerm-metoden) og mål hvor lang tid 
sorteringen tar. Velg så store tabeller at det tar ca. 1 sekund. Sammenlign med 
hvor lang tid metoden sort i class Arrays i java.util bruker på å sortere 
tabeller med samme størrelse. 
4. Flettesorteringen kan gjøres mer effektiv for delvis sorterte tabeller. Det 
er unødvendig å flette sammen a[fra:m> og a[m:til> hvis a[fra:til> allerede er 
sortert, dvs. hvis a[m-1] <= a[m]. Gjør de endringene som trengs i Programkode 1.3.13 
e). Test så om dette effektiviserer flettesortering. Bruk både sorterte og 
usorterte tabeller, og bruk tabeller som er like store som de i Oppgave 3. 
5. Vi sier at a[0:m> tom hvis m = 0 og ulovlig hvis m < 0. Tilsvarende for b[0:n>. 
Hva vil skje i metodene flett, union og snitt hvis både a[0:m> og b[0:n>, eller 
eventuelt bare en av dem, er tomme? Hva hvis en eller begge er ulovlige? 
6. Lag metoden public static int forskjellige(int[] a) der a er sortert, men kan 
ha like verdier. Den skal omorganisere a slik at de forskjellige verdiene kommer 
sortert først og duplikatene sortert bakerst, og returnere antallet forskjellige 
verdier. 
7. Medianen til en samling heltall er den verdien som havner på midten når 
samlingen sorteres. Gitt to sorterte heltallstabeller a og b. Finn en teknikk av 
logaritmisk orden som finner medianen for a og b. Hint: Finn midtverdiene i a og 
b, sammenlign, osv.  
I resten av oppgavene skal vi anta at a[0:m> ikke har like verdier og at b[0:n> 
ikke har like verdier. I tillegg antar vi at begge er sortert stigende. Videre 
sier vi at a[0:m> er tom hvis m = 0 og ulovlig hvis m < 0. Tilsvarende for b[0:n>. 
Legg alle metodene i samleklassen Tabell. I oppgavene til Avsnitt 1.3.16 vil vi 
få bruk for disse metodene, og da forventes det at de ligger i class Tabell.  
8. Lag metoden public static boolean erLik(int[] a, int m, int[] b, int n). Den 
skal avgjøre om a[0:m> og b[0:n> er like, dvs. har nøyaktig samme innhold. Her 
kan det være lurt å bruke at de er ulike hvis de inneholder forskjellige antall 
verdier. Lag også en versjon som arbeider med hele tabeller.  
9. Lag metoden public static int differans(int[] a, int m, int[] b, int n, int[] 
c). Den skal legge, i sortert rekkefølge, de verdiene som er i a[0:m>, men som 
ikke er i b[0:n>, over i c. Dette svarer til begrepet mengdedifferans fra 
mengdelæren. Metoden skal returnere antallet verdier som er lagt i c. Bruk idéen 
fra flett-metoden. Lag også en versjon som arbeider med hele tabeller.  
10. Lag metoden public static boolean inklusjon(int[] a, int m, int[] b, int n). 
Den skal avgjøre om b[0:n> er inneholdt i a[0:m>. Dette svarer til begrepet 
inklusjon (dvs. være en delmengde) fra mengdelæren. Metoden skal returnere true 
eller false. Bruk idéen fra flett-metoden. Lag også en versjon som arbeider med 
hele tabeller.  
11. Lag metoden public static int xunion(int[] a, int m, int[] b, int n, int[] c). 
Den skal legge, i sortert rekkefølge, de verdiene som er i a[0:m> eller i b[0:n>, 
men som ikke er i begge, over i c. Dette svarer til begrepet eksklusiv union (eller 
symmetrisk differans) fra mengdelæren. Den skal returnere antallet verdier som 
er lagt i c. Bruk idéen fra flett-metoden. Lag også en versjon som arbeider med 
hele tabeller. 

1.3.14 Inversjoner
La a være en tabell som inneholder sorterbare verdier. I Avsnitt 1.3.5 definerte 
vi at en slik tabell er sortert stigende hvis a[i] <= a[j] for alle indekser i 
og j der i < j. Det betyr spesielt at a ikke er sortert stigende hvis det finnes 
et eller flere par av indekser i og j med i < i slik at a[i] > a[j]. To verdier 
a[i] og a[j] med den egenskapen kalles en inversjon (eng: inversion). Det er med 
andre ord to tabellverdier som er i utakt med hensyn på en sortering. Begrepet 
inversjon kan defineres litt mer generelt: 

Definisjon 1.3.14 Gitt en rekkefølge med (minst to) sorterbare verdier. Hvis en 
verdi x ligger til venstre for en verdi y i rekkefølgen og x > y, så kalles 
verdiparet (x,y) en inversjon. 

I Figur 1.3.14 a) under har vi en tabell med mange inversjoner: 
4 3 17 10 6 20 1 11 15 8 18 9 2 7 19 13 5 14 16 12 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 
Figur 1.3.14 a) : En tabell med mange inversjoner 

Paret (4,3) er en inversjon siden 4 ligger til venstre for 3. Også (4,1) og (4,2) 
er inversjoner. Men det er mange flere. Hvor mange inversjoner er det til sammen 
i Figur 1.3.14 a)? 

Det kan vi finne ut ved å starte med første verdi, dvs. 4 og så finne hvor mange 
verdier det er som er mindre enn 4 til høyre for 4. Det er tallene 3, 1 og 2. 
Dermed 3 inversjoner som starter med 4. Så tar vi neste tall i tabellen, dvs. 3. 
Til høyre for 3 er det 2 tall som er mindre enn 3. Så tar vi tredje tall, dvs. 
17. Til høyre for 17 finner vi 14 tall som er mindre enn 17. Osv. Vi får denne 
tallrekken: 

(*) 3 + 2 + 14 + 7 + 3 + 14 + 0 + 5 + 8 + 3 + 8 + 3 + 0 + 1 + 5 + 2 + 0 + 1 + 1 

Summen blir 80. Det betyr at det er 80 inversjoner i tabellen i Figur 1.3.14 a). 

Idéen over kan lett oversettes til programkode. Flg. metode finner antallet 
inversjoner i en heltallstabell a: 

  public static int inversjoner(int[] a)
  {
    int antall = 0;
    for (int i = 0; i < a.length - 1; i++)
    {
      int verdi = a[i]; // sjekker verdiene til høyre for i

      for (int j = i + 1; j < a.length; j++)
        if (verdi > a[j]) antall++;  // en ny inversjon
    }
    return antall;
  }
              Programkode 1.3.14 a) 

Flg. eksempel viser hvordan metoden kan brukes: 

  int[] a = {4,3,17,10,6,20,1,11,15,8,18,9,2,7,19,13,5,14,16,12};

  System.out.println(inversjoner(a));  // Utskrift: 80 

Anta at det i Programkode 1.3.14 a) brukes en tabell med n verdier. Først settes 
i = 0. Da vil j gå fra 1 til n og sammenligningen verdi > a[j] blir utført n - 1 
ganger. Neste gang settes i = 1 og da vil den bli utført n - 2 ganger. Osv. Det 
gir en aritmetisk rekke med sum lik n(n - 1)/2. Dvs. metoden er av kvadratisk 
orden. Det betyr at metoden kan brukes for små verdier på n, men for store 
verdier av n bør vi ha en bedre metode. Det skal vi få til ved å bruke en 
flettesorteringsteknikk. Se slutten av dette avsnittet. 

Hvis verdiene våre er sortert i stigende rekkefølge, vil vi ikke ha noen 
inversjoner. Men hvor mange inversjoner kan en rekkefølge av verdier ha? Alle 
par av verdier (x,y) der x liggger til venstre for y i rekkefølgen, må 
undersøkes. Analysen av metoden i Programkode 1.3.14 a) viste at det er n(n - 1)/2 
mulige slike par. Hvis alle verdiene er forskjellige og de er sortert avtagende, 
vil alle slik par være inversjoner. Med andre ord kan en rekkefølge på n verdier 
ha opp til og med n(n - 1)/2 inversjoner: 
20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 
Figur 1.3.14 b) : En tabell med et maksimalt antall inversjoner 

Tabellen i Figur 1.3.14 b) innholder tallene fra 1 til 20 i sortert rekkefølge, 
men sorteringen er avtagende. Dermed vil det være 20*19/2 = 190 inversjoner. 

Det gjennomsnittlige antallet inversjoner blir et sted mellom 0 og n(n-1)/2 - 
faktisk lik
n(n-1)/4 hvis alle verdiene er forskjellige. Hvis alle er forskjellige og vi 
snur rekkefølgen, vil alle par (x,y) som ikke er inversjoner, bli inversjoner, 
og omvendt. Gjennomsnittet for en slik rekkefølge p og for den vi får ved å snu 
p, blir dermed n(n-1)/4. Men dette blir lik det totale gjennomsnittet siden 
enhver slik rekkefølge kan snus. 

Antall inversjoner i en permutasjon kan brukes som en målestokk for hvor sortert 
(sortert stigende) permutasjonen er. Jo færre inversjoner, jo nærmere er den det 
å være sortert stigende. Hvis det er ingen inversjoner, så er den sortert 
stigende. Omvendt gjelder at jo flere inversjoner det er, jo nærmere er den det 
å være sortert avtagende. Hvis den har n(n-1)/2 inversjoner, så er permutasjonen 
sortert avtagende. 

En enkel anvendelse: Per og Kari skal tippe resultatet i en konkurranse. 
Konkurransen har A, B, C, D og E som deltagere. Kari tipper at D blir nr. 1, B 
nr. 2, E nr. 3, A nr. 4 og C nr. 5. Per tipper at B blir nr. 1, A nr. 2, D nr. 3, 
E nr. 4 og C nr. 5. 

Konkurransen endte imidlertid med at D vant, A ble nr. 2, C nr. 3, B nr. 4 og E 
sist. Hverken Per eller Kari tippet rett. Men hvem var best? Spørsmålet kan ikke 
besvares før det er bestemt en regel for hvordan tipperesultater skal rangeres. 
F.eks. har Kari tippet vinneren riktig. Da kan man si at Kari har laget det 
beste tipperesultatet siden det er viktigst å tippe rett vinner. Men her skal vi 
bruke en rangering som gjør det like viktig å tippe rett på alle plassene. Vi 
skal si at det resultatet som inneholder færrest inversjoner er best. 
Kari tipper  Per tipper  Resulatet 
1. D 1. B 1. D 
2. B 2. A 2. A 
3. E 3. D 3. C 
4. A 4. E 4. B 
5. C 5. C 5. E 
Kari har færrest inversjoner i sin «tipping» 

I forhold til det riktige resulatet gir tipset til Kari permutasjonen 1, 4, 5, 2, 
3. Det kommer av at hun tippet D riktig på 1. plass, B (som ble nr. 4) på 2.plass, 
E (som ble nr. 5) på 3. plass, osv. Tilsvarende gir tipset til Per permutasjonen 
4, 2, 1, 5, 3. Vi ser fort at tallene til Kari inneholder 4 inversjoner og 
tallene til Per 5 inversjoner. Dermed har Kari det beste tipperesultatet ut fra 
regelen om færrest inversjoner. 

Ved å bruke idéen i flettsortering er det mulig å lage en n?·?log(n)-metode som 
finner antallet inversjoner. Husk at et verdipar (x,y) er en inversjon hvis x 
ligger til venstre for y i rekkefølgen og at x er større enn y. Idéen baserer 
seg på flg. observasjon: 

Observasjon Gitt en rekkefølge med sorterbare verdier. Hvis vi deler rekkefølgen 
i to (på midten eller et annet sted), vil en eventuell inversjon (x,y) enten 1) 
ha både x og y i den venstre delen, 2) ha både x og y i den høyre delen eller 3) 
ha x i den venstre delen og y i den høyre delen. 

Figur 1.3.14 c) under inneholder 20 tall. Midten av tabellen er markert med en 
tykk strek: 
4 3 17 10 6 20 1 11 15 8 18 9 2 7 19 13 5 14 16 12 
Figur 1.3.14 c) : Midten av tabellen er markert med en tykk strek  

Vi vet fra før at tabellen i Figur 1.3.14 c) inneholder 80 inversjoner. Den 
delen som ligger til venstre for midten kaller vi venstre del og resten høyre 
del. Vi kan plukke ut inversjoner av hver av de tre typene, f.eks. (17,11), (7,5) 
og (10,9). I (17,11) ligger begge tallene i venstre del, i (7,5) ligger begge i 
høyre del og i (10,9) ligger 10 i venstre og 9 i høyre del. 

Ved hjelp av observasjonen kan vi sette opp flg. utkast for en algoritme: 

?1.?Del tabellen i to deler - venstre og høyre del. 

?2.?Finn antall inversjoner (x,y) i venstre del. 

?3.?Finn antall inversjoner (x,y) i høyre del. 

?4.?Finn antall inversjoner (x,y) der x ligger i venstre del og y i høyre del. 

?5.?Summen av disse antallene er antallet inversjoner i hele tabellen. 

Vi kan finne de inversjonene (x,y) der x ligger i venstre del og y i høyre del, 
på en effektiv måte hvis de to delene er sortert hver for seg slik som det er i 
flettesortering: 
1 3 4 6 8 10 11 15 17 20 2 5 7 9 12 13 14 16 18 19 
i  j  
Figur 1.3.14 d) : De to halvdelene er sortert hver for seg  

La tabellen over hete a. Vi starter med å sammenligne a[i] og a[j], dvs. vi 
sammenligner 1 og 2. Siden 1 < 2 vil 1 (dvs. a[i]) bli flyttet til en 
hjelpetabell og i økes med 1:  
3 4 6 8 10 11 15 17 20 2 5 7 9 12 13 14 16 18 19 
i  j  
Figur 1.3.14 e) : 1-tallet er flyttet til en hjelpetabell og i har økt med 1  

Vi sammenligner a[i] og a[j] på nytt, dvs. 3 og 2. Det gir en inversjon siden 3 
> 2. Men alle tallene til høyre for 3 i den venstre tabelldelen er større enn 3. 
Dermed får vi like mange inversjoner som antallet verdier i a fra og med 
posisjon i og ut den venstre tabelldelen. Det blir 9 stykker. Så flytter vi 2 (dvs. 
a[j]) til hjelpetabellen og j økes med 1:  
3 4 6 8 10 11 15 17 20  5 7 9 12 13 14 16 18 19 
i   j  
Figur 1.3.14 f) : 2-tallet er flyttet til en hjelpetabell og j har økt med 1  

Neste skritt er å sammenligne 3 og 5. Resultatet blir at 3 flyttes til 
hjelpetabellen siden 3 er minst. Så sammenlignes 4 og 5, og 4 flyttes til 
hjelpetabellen. Så sammenlignes 6 og 5. Det gir 7 nye inversjoner siden både 6 
og alle tallene til høyre for 6 i den venstre tabelldelen er større enn 5. Osv. 
På denne måten finner vi alle inversjonene (x,y) der x ligger i den venstre 
delen og y i den høyre delen ved kun én gjennomgang av tabellen. 

Metoden inv nedenfor fletter og teller opp. Flettingen er litt annerledes enn 
slik som beskrevet i figurene 1.3.14 c) - d). Først kopieres intervallet a[fra:m> 
over i hjelpetabellen b, og så flettes det som er kopiert over i b sammen med a[m:til> 
og resultatet legges i a. Dermed reduseres antallet tabelloperasjoner: 

  private static int inv(int[] a, int[] b, int fra, int m, int til)
  {
    int n = m - fra;                // antall elementer i a[fra:m>
    System.arraycopy(a,fra,b,0,n);  // kopierer a[fra:m> over i b[0:n>

    int i = 0, j = m, k = fra;      // løkkevariabler og indekser
    int antall = 0;                 // antall inversjoner

    while (i < n && j < til)
    {
      if (b[i] <= a[j]) a[k++] = b[i++];   // teller opp og fletter
      else
      {
        antall += (n - i);                 // antallet i b[i:n>
        a[k++] = a[j++];
      }
    }
    while (i < n) a[k++] = b[i++];  // tar med resten av b[0:n>

    return antall;   // returnerer antall inversjoner
  }

  private static int inversjoner(int[] a, int[] b, int fra, int til)
  {
    if (til - fra <= 1) return 0;   // maks ett element - 0 inversjoner

    int m = (fra + til)/2;          // midt mellom fra og til

    return inversjoner(a,b,fra,m)   // teller og sorterer a[fra:m>
         + inversjoner(a,b,m,til)   // teller og sorterer a[m:til>
         + inv(a,b,fra,m,til);      // fletter a[fra:m> og a[m:til>
  }

  public static int inversjoner(int[] a)
  {
    int[] b = new int[a.length/2];       // hjelpetabell for fletting
    return inversjoner(a,b,0,a.length);  // kaller metoden over
  }
              Programkode 1.3.14 b) 

Metoden i Programkode 1.3.14 a) har samme navn som den i Programkode 1.3.14 b). 
Den må fjernes eller få et annet navn for at dette eksemplet skal virke: 

  int[] a = {4,3,17,10,6,20,1,11,15,8,18,9,2,7,19,13,5,14,16,12};
  System.out.println(inversjoner(a));  // Utskrift: 80

              Programkode 1.3.14 c) 

En vilkårlig permutasjon av tallene fra 1 til n vil kunne inneholde fra 0 til m 
forskjellige permutasjoner der m = n(n ? 1)/2. La k være et heltall i 
intervallet [0,m] og la I(n,k) være antallet permutasjoner som inneholder 
nøyaktig k inversjoner. 

La n = 3. Det er 3! = 6 permutasjoner av tallene fra 1 til 3, og det er (1,2,3) 
, (1,3,2) , (2,1,3) , (2,3,1) , (3,1,2) og (3,2,1). Permutasjonen (1,2,3) har 0 
og permutasjonene (1,3,2) og (2,1,3) har begge én inversjon, (2,3,1) og (3,1,2) 
har begge to inversjoner og (3,2,1) har tre inversjoner. Dermed får vi: 

I(3,0) = 0, I(3,1) = 2, I(3,2) = 2, I(3,3) = 1 

Gitt permutasjonen (3,5,2,1,4) av tallene fra 1 til 5. Snur vi den får vi 
permutasjonen (4,1,2,5,3). I den første har vi paret (5,2) som er en inversjon, 
men i den omvendte permutasjonen går det over til å bli paret (2,5) som ikke er 
en permutasjon. Omvendt er paret (2,4) ikke en inversjon i den første 
permutasjonen, men (4,2) blir en inversjon i den andre. Det betyr generelt at 
hvis en permutasjon har k inversjoner, vil den omvendte permutasjonen ha m ? k 
inversjoner der m som før er lik n(n ? 1)/2. Det gir oss en symmetriegenskap for 
I(n,k). Flg. differensligninger gjelder for I(n,k): 

(1.3.14.0) I(n,0) = 1 , n > 1 

(1.3.14.1) I(n,k) = I(n,k-1) + I(n-1,k) , 0 < k < n 

(1.3.14.2) I(n,k) = I(n,k-1) + I(n-1,k) - I(n-1,k - n) , 1 < n <= k <= n(n - 1)/4 

(1.3.14.3) I(n,k) = I(n,n(n-1)/2 - k) , n > 1 , 0 <= k <= (n-1)/2 

Flg. tabell viser I(n,k) for små verdier av n og k: 
n \ k 0  1  2 3 4 5 6 7 8 9 10 11 12 13 
2 1 1             
3 1 2 2 1           
4 1 3 5 6 5 3 1        
5 1 4 9 15 20 22 20 15 9 4 1    
6 1 5 14 29 49 71 90 101 101 90 71 49 29 14 
7 1 6 20 49 98 169 259 359 455 531 573 573 531 455 
8 1 7 27 76 174 343 602 961 1415 1940 2493 3017 3450 3736 
Figur 1.3.14 g) : En I(n,k)-tabell for noen verdier av n og k  


Oppgaver til Avsnitt 1.3.14 
1. Sjekk at at leddene i summen (*) rett foran Programkode 1.3.14 a) er riktige 
ved å studere Figur 1.3.14 a).  
2. Hvor mange inversjoner er det i følgende tre tallsekvenser: a) 3,1,2,6,4,5,10,7,9,8 
b) 5,7,3,2,8,1,10,6,4,9 og c) 7,9,2,5,1,8,10,3,6,4. Finn svarene med både å 
telle opp manuelt og å bruke en metode som teller opp. 
3. Lag en serie tilfeldige permutasjoner og vis at metodene i Programkode 1.3.14 
a) og Programkode 1.3.14 b) gir samme svar. De har begge samme navn. Da bør 
metoden i Programkode 1.3.14 a) omdøpes slik at begge kan brukes i samme program. 
4. Lag metoden public static int[] inversjonsTabell(int n). La m = n(n-1)/2. 
Metoden skal returnere en tabell med lengde m + 1 og verdien på indeks k i 
returtabellen skal være lik I(n,k). Generer (se Avsnitt 1.3.2) alle 
permutasjonene og bruk så metoden i Programkode 1.3.14 b) til å finne antall 
inversjoner i hver av dem. Bruk metoden til å sjekke at verdiene i Figur 1.3.14 
g) stemmer.  
5. Bevis differensligningen (1.3.14.1). 
6. Lag en I(n,k)-tabell ved hjelp differensligningene (1.3.14.1) - (1.3.14.3). 

1.3.15 Forskyvninger og rotasjoner
Gitt flg. heltallstabell: 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
Figur 1.3.15 a) : En heltallstabell med 20 verdier 

En forskyvning (eng: shift) på f.eks. 3 enheter mot høyre i tabellen over, vil 
føre til at de tre siste verdiene forsvinner:    
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 
Figur 1.3.15 b) : Tabellinnholdet er forskjøvet tre enheter mot høyre 

I Figur 1.3.15 b) har ikke de tre første rutene noe innhold. Men de hører til 
tabellen og må derfor ha et innhold. Vi kunne f.eks. tenke oss at verdiene er 0. 
Men det er kanskje mer naturlig å kreve at de skal inneholde den verdien som 
opprinnelig lå først. Dvs. slik: 
1 1 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 
Figur 1.3.15 c) : Det er fylt på fra venstre med verdien som opprinnelig lå 
først 

Dette svarer en bitskyvning av bitene i et heltall. Der er det to typer 
bitforskyving mot høyre: >> og >>>. Operatoren >> kalles en fortegnsbevarende 
skiftoperator. Det betyr at det fylles på fra venstre med den biten som 
opprinnnelig lå lengst til venstre. Den andre fyller alltid på 0-biter. 
Setningen int k = -1; gir k? 32 1-biter. Setningen k >>= 3; forskyver bitene i k 
tre enheter mot høyre. Men siden den første biten er 1, fylles det på med 1-biter. 
Det betyr at k fortsatt er ?1. Se Oppgave 1. 

En tabellforskyvning mot venstre skal foregå på en tilsvarende måte, men motsatt 
vei. Da bestemmer vi at her skal det fylles på fra høyre med den verdien som 
opprinnelig lå lengst til høyre. En forskyvning på f.eks. 5 enheter mot venstre 
i tabellen i Figur 1.3.15 a) vil føre til at de 5 første verdiene forsvinner og 
at vi får inn den siste verdien på de 5 siste plassene: 
6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 20 20 20 20 20 
Figur 1.3.15 d) : Tabellinnholdet er forskjøvet fem enheter mot venstre 

En forskyving av elementene i en tabell kan ikke gjøres ved hjelp operatorer. 
Men vi kan lage en metode som gjør det. Metoden kan ha flg. signatur: 

  public static void forskyv(int[] a, int enheter)

              Programkode 1.3.15 a) 

Parameteren enheter sier hvor langt det skal forskyves. Hvis den er positiv, må 
hver verdi fra posisjon 0 til posisjon a.length - enheter flyttes så langt mot 
høyre. Det får vi til ved å bruke setningen: a[i] = a[i - enheter]. Hvis den er 
negativ, går vi motsatt vei. 

Det er ikke innlysende hva som bør skje hvis antall enheter det skal forskyves 
er større enn tabellens lengde. Det er kanskje mest naturlig at det gjøres slik 
som det er for vanlige bitforskyvninger. Hvis f.eks. k er av typen int (32 biter) 
og m er et positivt heltall, vil k >> m ha samme effekt som k >> (m % 32). Se 
Oppgave 2. 

  public static void forskyv(int[] a, int enheter)
  {
    if (a.length < 2) return;

    enheter %= a.length;

    if (enheter > 0)  // forskyvning mot høyre
    {
      for (int i = a.length - 1; i >= enheter; i--)
      {
        a[i] = a[i - enheter];  // flytter mot høyre
      }

      int k = a[0];  // den første verdien
      for (int i = 1; i < enheter; i++)
      {
        a[i] = k;  // legger inn den første verdien
      }
    }
    else if (enheter < 0)
    {
      for (int i = -enheter; i < a.length; i++)
      {
        a[i + enheter] = a[i];  // flytter mot venstre
      }

      int k = a[a.length - 1];  // den siste verdien
      for (int i = a.length + enheter; i < a.length - 1; i++)
      {
        a[i] = k;  // kopierer inn den siste verdien
      }
    }
  }
              Programkode 1.3.15 b) 

Flg. eksempel viser hvordan det virker sammenlignet med en forskyvning av biter 
i et heltall: 

  int[] a = new int[32];
  for (int i = 0; i < 31; i++) a[i] = 1;   // 31 1-tall + et 0-tall i a
  int k = -2;                              // 31 1-biter + en 0-bit i k

  for (int verdi : a) System.out.print(verdi);           // utskrift av a
  System.out.println("\n" + Integer.toBinaryString(k));  // utskrift av k

  int n = k << 15;    // forskyver bitene
  forskyv(a,-15);     // forskyver tabellelementene

  for (int verdi : a) System.out.print(verdi);           // utskrift av a
  System.out.println("\n" + Integer.toBinaryString(n));  // utskrift av n

  // 11111111111111111111111111111110
  // 11111111111111111111111111111110
  // 11111111111111110000000000000000
  // 11111111111111110000000000000000

              Programkode 1.3.15 c) 

Rotasjoner Tabellen under inneholder de 16 bokstavene fra A til P. 
A B C D E F G H I J K L M N O P 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
Figur 1.3.15 e): En tabell med bokstavene fra A til P 

En rotasjon i en tabell er en forskyvning på en slik måte at de elementene som 
skyves ut kommer inn i samme rekkefølge i den andre enden av tabellen.  
Figur 1.3.15 f) 
Hvis vi tenker oss at tabellen bøyes til en sirkel slik at indeks 0 og tabellens 
siste indeks kommer ved siden av hverandre, kan vi se på dette som en rotasjon. 
Se Figur 1.3.15 f) til venstre. Vi kan tenke på dette som et «lykkehjul». 
Indeksene holdes fast, mens «hjulet» kan snurre både med og mot klokken. 

En rotasjon på f.eks. 8 enheter får vi ved å rotere hjulet med klokken slik at 
bokstaven A kommer ned til indeks 8. En rotasjon på f.eks. ?5 enheter får vi ved 
å rotere hjulet 5 enheter mot klokken slik at A kommer til indeks 11. Dette 
kunne vi også ha fått til ved å rotere 11 enheter med klokken. Det kommer av at 
en rotasjon på k enheter mot klokken er det samme som en rotasjon på 16 ? k 
enheter med klokken der 16 er tabellens lengde. 

En enkel måte å kode dette på er å bruke samme idé som i forskyv-metoden i 
Programkode 1.3.15 b), men passe på å ta vare på de elementene som skyves ut av 
tabellen. De må da kopieres inn i tabellen i den andre enden: 

  public static void roter(char[] a, int enheter)           // 1. versjon
  {
    if (a.length < 2) return;                               // 0 eller 1

    enheter %= a.length;                                    // modulus
    if (enheter < 0) enheter += a.length;                   // motsatt vei
    char[] b = new char[enheter];                           // hjelpetabell

    System.arraycopy(a, a.length - enheter, b, 0, enheter); // kopierer
    for (int i = a.length - 1; i >= enheter; i--)
    {
      a[i] = a[i - enheter];                                // forskyver
    }
    System.arraycopy(b, 0, a, 0, enheter);                  // kopierer
  }
              Programkode 1.3.15 d) 

I Figur 1.3.15 e) og i metoden over, inngår en tegntabell (char). I Oppgave 4 
ser vi på heltallstabeller (int). Flg. eksempel viser hvordan metoden virker for 
en tegntabell: 

  char[] c = "ABCDEFGHIJKLMNOP".toCharArray();
  roter(c,-5);
  System.out.println(Arrays.toString(c));

  // Utskrift: [F, G, H, I, J, K, L, M, N, O, P, A, B, C, D, E]

              Programkode 1.3.15 e) 

Programkode 1.3.15 d) er effektiv nok hvis tabellen skal roteres få enheter. Men 
hvis den skal roteres mange enheter mot høyre (med klokken) eller eventuelt få 
enheter mot venstre (mot klokken), er den mindre effektiv. Ta for eksempel 
tilfellet at tabellen skal roteres én enhet mot venstre. Men det blir det samme 
som å rotere a.length ? 1 enheter mot høyre. Da må hjelpetabellen ha samme 
lengde og dermed blir det svært mye kopiering. Det er imidlertid mulig å lage en 
løsning der hjelpetabellen maksimalt blir så lang som a.length/2. Se Oppgave 5. 
Men er det mulig å lage en rotasjonsmetode som ikke bruker en hjelpetabell? 

Ant at vi skal rotere tabellen under 10 enheter mot høyre: 
A B C D E F G H I J K L M N O P 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
Figur 1.3.15 g): En tabell med bokstavene fra A til P 

Vi starter med å snu rekkefølgen på elementene i tabellen. Det gir oss flg. 
resultat: 
P O N M L K J I H G F E D C B A 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
Figur 1.3.15 h): Rekkefølgen er snudd 

Så snur vi rekkefølgen på de 10 første og deretter på de 16 - 10 = 6 siste: 
G H I J K L M N O P A B C D E F 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
Figur 1.3.15 i): Tabellen er rotert 10 enheter mot høyre 

Hokus pokus og simsalabim. Tabellen har blitt rotert 10 enheter mot høyre. For å 
innse at dette alltid gir korrekt resultat er det enklest å tenke motsatt vei. 
Anta derfor at vi starter med resultatet, dvs. med at tabellen er blitt rotert 
10 enheter mot høyre. De 6 siste elementene er da de som opprinnelig lå først. 
Snur vi disse kommer de som de 6 siste i en snudd tabell. Snur vi de 10 første 
kommer disse som de 10 første i en snudd tabell. Hvis vi så avslutter med å snu 
tabellen, vil vi dermed få den opprinnelige tabellen. Denne argumentasjonen 
gjelder generelt, dvs. ved rotasjon på et bestemt antall enheter i en vilkårlig 
tabell. 

Vi snur en tabell eller et tabellinetvall ved hjelp av en serie ombyttinger. Da 
kan det være praktisk med en egen ombyttingsmetode. Kanskje du allerede har en 
metode (i samleklassen Tabell) som bytter om elementer i en char-tabell? Hvis 
ikke, er det enkelt å lage en: 

  public static void bytt(char[] a, int i, int j)
  {
    char temp = a[i];
    a[i] = a[j];
    a[j] = temp;
  }
              Programkode 1.3.15 f) 

Følgende rotasjonsmetode bruker idéen med først å snu hele tabellen, så å snu 
intervallet fra 0 til antall enheter og til slutt intervallet fra antall enheter 
og ut tabellen: 

  public static void roter(char[] a, int enheter)    // 2. versjon
  {
    if (a.length < 2) return;                   // lengde 0 eller 1

    enheter %= a.length;                        // modulus
    if (enheter < 0) enheter += a.length;       // motsatt vei

    int v = 0, h = a.length - 1;
    while (v < h) bytt(a,v++,h--);              // snur hele tabellen

    v = 0; h = enheter - 1;
    while (v < h) bytt(a,v++,h--);              // snur a[0:enheter>

    v = enheter; h = a.length - 1;
    while (v < h) bytt(a,v++,h--);              // snur a[enheter:a.length>
  }
              Programkode 1.3.15 g) 

Med tanke på effektivitet er det naturlig å se på en tabellaksess som den 
grunnleggede operasjonen. I metoden bytt er det fire av dem. Vi snur en tabell (eller 
et tabellintervall) ved å kalle bytt-metoden inntil vi kommer til midten. Hvis 
et intervall har lengde k, blir det dermed 4·(k/2) tabellaksesser. For en tabell 
med lengde n, blir det tilsammen tilnærmet lik 4n tabellaksesser i Programkode 1.3.15 
g). Dette er litt dårligere enn gjennomsnittet for metoden i Programkode 1.3.15 
d), men det brukes ingen hjelpetabell og det er fordelaktig.  
Figur 1.3.15 j) : «Sirkeltabell» 
Figur 1.3.15 k) : «Sirkeltabell»  

Det finnes flere måter å rotere en tabell uten bruk av hjelpetabell. Flg. idé 
gir ingen forbedring i effektiviten i forhold til de to versjonene vi allerede 
har sett på, men har interessante egenskaper. Ta utgangspunkt i tabellen til 
venstre. Den er satt opp i sirkelform. Anta at den skal roteres 3 enheter mot 
høyre (med klokken): 

Det kan gjøres ved flg. skritt: Først tar vi vare på det som ligger på indeks 0, 
dvs. A. Så flytter vi N på indeks 13 til indeks 0 (dvs. 3 enheter med klokken). 
Så K på indeks 10 til indeks 13, så H på indeks 7 til indeks 10, så E på indeks 
4 til indeks 7 og så B på indeks 1 til indeks 4. Neste skritt er å flytte det 
som ligger 3 enheter mot klokken fra 1. Vi ser på figuren at det er O på indeks 
14. Men 3 enheter mot klokken fra 1 er 1 ? 3 = ?2. Hvis en indeks på denne måten 
blir negativ, legger vi til 16, dvs. ?2 + 16 = 14. Figuren rett til venstre 
viser det som har skjedd så langt. 

Vi fortsetter med å flytte L på indeks 11 til indeks 14, osv. På denne måten får 
vi indeksene til tabellen i rekkefølgen: 0, 13, 10, 7, 4, 1, 14, 11, 8, 5, 2, 15 
12, 9, 6, 3. Til slutt med vi legge inn A som vi tok vare på, på indeks 3. 

Bruker vi i som indeks, vil oppdateringen av i bli slik: 

  i -= enheter;
  if (i < 0) i += 16; 

Det er enkelt å lage kode som gjør det som vises i Figur 1.3.15 k) og 
fortsettelsen av det: 

  char[] c = "ABCDEFGHIJKLMNOP".toCharArray();

  int enheter = 3;
  char temp = c[0];  // tar vare på verdien i indeks 0

  for (int i = -enheter, j = 0; i != 0; i -= enheter)  // stopper i 0
  {
    if (i < 0) i += 16;     // sjekker fortegnet til indeks i
    c[j] = c[i];            // kopierer
    j = i;                  // oppdaterer indeks j
  }

  c[enheter] = temp;        // legger tilbake verdien
  System.out.println(Arrays.toString(c));

  // Utskrift: [N, O, P, A, B, C, D, E, F, G, H, I, J, K, L, M]

              Programkode 1.3.15 h)  
Figur 1.3.15 l) : «Sirkeltabell» 
Figur 1.3.15 m) : «Sirkeltabell» 

Eksemplet over viser at en tabell med 16 verdier kan roteres 3 enheter med 
klokken ved å flytte én og én verdi. Men vil dette virke generelt? Vi gjentar 
dette, men nå med 4 enheter istedenfor 3. Start med Figur 1.3.15 j). Som sist 
legges verdien i indeks 0 (bokstaven A) tilside. 

Deretter flytter vi bokstaven M i indeks 0 - 4 = 12 til indeks 0. Så bokstaven I 
i indeks 12 - 4 = 8 til indeks 12 og så bokstaven E i indeks 8 - 4 = 4 til 
indeks 8. Neste skritt skulle da ha vært å flytte bokstaven M i indeks 4 - 4 = 0 
til indeks 4, men det blir galt. Bokstaven M har jo allerede blitt flyttet og 
skal ligge i indeks 0. Se Figur 1.3.15 l) til venstre. Bokstaven A skal isteden 
inn på indeks 4 for å få korrekt rotasjon. Men dette fører til at kun fire av 
tabellens 16 verdier har blitt flyttet dit de skal. 

Vi kan få fullført dette ved å starte på nytt, men denne gangen på indeks 1. Dvs. 
verdien i indeks 1 (bokstaven B) legges tilside. Så flyttes bokstaven N i indeks 
1 - 4 = 13 til indeks 1, så bokstaven J i indeks 13 - 4 = 9 til indeks 13, osv. 
til at bokstaven B som ble lagt til side, legges inn på indeks 1. Dette gir 
Figur 1.3.15 m) til venstre. 

For å få flyttet alle bokstavene dit de skal, må dette gjøres to ganger til. Det 
som står igjen er å flytte de fire som starter med indeks 2 og til slutt de fire 
som starter med indeks 3. Hver runde som er gjennomført, kalles en sykel. Det 
betyr at med tabellengde 16 og rotasjon på 3 enheter ble det kun én sykel, men 
fire sykler når det er 4 enheter. 

Det viser seg at antall sykler i en slik rotasjonsteknikk er det samme som 
største felles divisor for tabellens lengde (her 16) og rotasjonslengden (her 3 
og 4). Største felles divisor for 16 og 3 er 1, mens største felles divisor for 
16 og 4 er 4. Se Rotasjonssykler. 

  public static int gcd(int a, int b)  // Euklids algoritme
  {
    return b == 0 ? a : gcd(b, a % b);
  }

  public static void roter(char[] c, int enheter)    // 3. versjon
  {
    int n = c.length;                    // tabellens lengde
    if (n < 2) return;                   // ingen rotasjon

    enheter %= n;                        // modulus
    if (enheter < 0) enheter += n;       // går motsatt vei

    int d = gcd(n, enheter);             // største felles divisor

    for (int k = 0; k < d; k++)          // antall sykler
    {
      char temp = c[k];  // tar vare på verdien i indeks k

      for (int i = k - enheter, j = k; i != k; i -= enheter)
      {
        if (i < 0) i += n;           // sjekker fortegnet til i
        c[j] = c[i];                 // kopierer
        j = i;                       // oppdaterer indeks j
      }

      c[k + enheter] = temp;         // legger tilbake verdien
    }
  }
              Programkode 1.3.15 i) 

Effektivitet La tabellen ha lengde n og anta at vi skal rotere k, 0 ? k < n, 
enheter. Da vil 1. versjon av roter-metoden (Programkode 1.3.15 d?) ha 2(n + k) 
tabellaksesser, 2. versjon (Programkode 1.3.15 g?) ha 4n tabellaksesser og 3. 
versjon (Programkode 1.3.15 i?) 2n tabellaksesser. Hvis k er liten i forhold til 
n, vil 1. versjon være mest effektiv. Men den har ulempen at det inngår en 
hjelpetabell. 3. versjon har færrest tabellaksesser, men der er det en del mer 
arbeid knyttet til hver aksess. 


Oppgaver til Avsnitt 1.3.15 
1. Programkode 1.3.15 h) virker når tabellen skal roteres 3 enheter. Det påstas 
senere at denne koden også vil fungere hvis antall enheter og tabellens lengde 
16 er relativt primiske. Sjekk at dette stemmer ved velge antall enheter lik 1, 
5, 7, 9, 11, 13 og 15.  
2. La antallet enheter være 6 i Programkode 1.3.15 h). Største felles divisor 
for 6 og 16 er 2. Sjekk at det da bare er annenhver bokstav som har blitt rotert 
6 enheter.  
3. Lag kode som tester effektiviteten til de tre versjonene av roter-metoden. Da 
må du enten velge en svært stor tabell eller gjenta rotasjonen mange ganger på 
en mindre tabell. Bruk både små og store verdier på antall rotasjonsenheter. 

1.3.16 Anvendelser: En tallmengde
Vår class Tallmengde skal bruke en sortert tabell som intern datastruktur. 
Dermed kan vi benytte metodene fra Avsnitt 1.3.13 som hjelpemetoder når metodene 
i class Tallmengde skal implementeres. Java har allerede en klasse for 
heltallsmengder. Det er class BitSet i java.util. Den skal vi se nærmere på i 
Avsnitt 1.7.17. Der brukes en helt annen og smartere teknikk, men den kan kun 
arbeide med ikke-negative heltall. I vår Tallmengde-klasse kan både positive og 
negative heltall inngå, og teknikken kan lett utvides til mengder der elementene 
er f.eks. desimaltall, tegn eller andre typer som kan ordnes. 

Legg flg. klasse på filen Tallmengde.java: 

public class Tallmengde         // legges på filen Tallmengde.java
{
  private int[] a;                             // en heltallstabell
  private int antall;                          // antall verdier i
  private static final int DIM = 4;            // utvidelsesfaktor

  // private static int dim(int n);            // tabelldimensjon
  // private Tallmengde(int[] a, int n)        // bruker b[0:n>

  // public Tallmengde()                       // standardkonstruktør
  // public Tallmengde(Tallmengde B)           // kopieringskonstruktør
  // public Tallmengde(int[] a)                // lager en mengde av b
  // public Tallmengde(int verdi)              // mengde med ett element

  // public boolean leggInn(int element)       // legger inn et element

  // public Tallmengde union(Tallmengde B)     // returnerer unionen
  // public Tallmengde snitt(Tallmengde B)     // returnerer snittet
  // public Tallmengde differans(Tallmengde B) // differansen
  // public Tallmengde xunion(Tallmengde B)    // returnerer xunionen

  // public boolean fjern(int element)         // fjerner et element 

  // public boolean erElement(int verdi)       // er verdi et element?
  // public boolean inklusjon(Tallmengde B)    // er B delmengde?

  // public boolean tom()                      // er mengden tom?
  // public int antall()                       // antallet i mengden
  // public boolean equals(Object o)           // like mengder? 
  // public String toString()                  // for utskrift
  // public int[] tilTabell()                  // mengden som tabell
}
              Programkode 1.3.16 a) 

Klassen Tallmengde har to private instansvariabler - en heltallstabell a og en 
antall-variabel. Heltallstabellen a skal inneholde mengdens elementer og 
variabelen antall skal fortelle hvor mange elementer a inneholder. 

Programkode 1.3.16 a) viser de konstruktørene og metodene klassen skal ha. De er 
midlertidig kommentert vekk. En konstruktør (eng: constructor) har samme navn 
som klassen. Det er egentlig ikke en metode, men blir av og til omtalt som det. 
Objekter, dvs. instanser av en klasse, lages ved hjelp av konstruktører. 

Alle klasser blir automatisk utstyrt med en standardkonstruktør (eng: default 
constructor). Den kalles også den parameterløse konstruktøren. Den kan brukes 
slik: 

  Tallmengde A = new Tallmengde(); 

Dette gir oss et objekt A der alle instansvariablene er satt til 0/null. Dette 
kunne tolkes som en tom tallmengde. Men vi bestemmer imidlertid at en tallmengde 
er tom hvis antall er 0 og den interne tabellen a er tom. For å få til det må vi 
selv programmere standardkonstruktøren: 

  public Tallmengde()               // standardkonstruktør
  {
    a = new int[0];                 // en tom tabell
    antall = 0;                     // mengden er tom
  }
              Programkode 1.3.16 b) 

Det bør være mulig å legge nye elementer i en mengde. Metoden leggInn er til for 
det formålet. Da må det først sjekkes om elementet (et tall) ligger der fra før. 
Til det kan vi bruke en ferdig søkemetode, f.eks. lineærsøk eller binærsøk. Hvis 
det er få verdier (f.eks. færre enn 10) er nok lineærsøk raskest. Men generelt 
er binærsøk raskest og vi velger å bruke den her. Hvis elementet ikke ligger der, 
plasseres det på rett sortert plass i tabellen: 

  public boolean leggInn(int element)
  {
    int k = Tabell.binærsøk(a,0,antall,element);     // binærsøk
    if (k >= 0) return false;     // duplikat - ingen innlegging

    if (antall == a.length)       // utvider hvis tabellen er full
        a = Arrays.copyOf(a,a.length + DIM);  // se Programkode 1.3.10 c)

    k = -(k + 1);                 // innsettingsposisjonen
    for (int i = antall; i > k; i--) a[i] = a[i-1];  // forskyver

    a[k] = element;               // legger inn på rett plass
    antall++;                     // en mer i tabellen

    return true;                  // vellykket innlegging
  }
              Programkode 1.3.16 c) 

Det er satt opp en konstruktør som lager en tallmengde ved hjelp av verdiene i 
en tabell. Den kan vi programmere ved å la leggInn-metoden legge inn en og en 
verdi fra tabellen: 

  public Tallmengde(int[] a)      // henter tallene fra a
  {
    this();                       // standardkonstruktøren

    for (int element : a)         // foralle-løkke
      leggInn(element);
  }
              Programkode 1.3.16 d) 

Det er fordelaktig å kunne skrive ut elementene i en mengde. Vi kan for eksempel 
«gjøre om» tallmengden til en tegnstreng og så skrive ut den. Metoden toString 
som vi arver, kan overskrives på denne måten. En StringBuilder brukes til å 
bygge opp tegnstrengen: 

  public String toString()                // for utskrift
  {
    if (antall == 0) return "{}";         // mengden er tom

    StringBuilder s = new StringBuilder();

    s.append('{'); s.append(a[0]);             // {a[0],

    for (int i = 1; i < antall; i++)
    {
      s.append(','); s.append(a[i]);      // {a[0],a[1],a[2] . . .
    }
    s.append('}');                        // {a[0],a[1],a[2], . . . }

    return s.toString();
  }
              Programkode 1.3.16 e) 

Flg. eksempel viser hvodan de metodene vi har laget til nå, kan brukes: 

  int[] a = {1,3,5,7,9};           // a er sortert
  int[] b = {4,2,6,2,4};           // b er usortert og har duplikater

  Tallmengde A = new Tallmengde(a);    // A = {1,3,5,7,9}
  Tallmengde B = new Tallmengde(b);    // B = {2,4,6}
  Tallmengde C = new Tallmengde();     // en tom mengde

  System.out.println(A + " " + B + " " + C);  // toString brukes

  // Utskrift: {1,3,5,7,9} {2,4,6} {}

              Programkode 1.3.16 f) 

Legg merke til at parametertabellen kan være usortert og inneholde duplikater. 

I leggInn-metoden i Programkode 1.3.16 c) "utvides" den interne tabellen a med 
DIM enheter om gangen. Klassekonstanten DIM er satt til 4, men den kan 
selvfølgelig endres. Poenget er å la a ha plass til litt mer enn det som er 
absolutt nødvendig. Det betyr litt sløsing med plassen, men fordelen er at små 
endringer i en mengdes innhold kan gjøres på en effektiv måte. 

Flg. hjelpemetode finner den minste multiplen av DIM som er større enn eller lik 
heltallet n. Den kan brukes til å dimensjonere tabellen a. 

  private static int dim(int n)           // n ikke-negativ
  {
    int k = n % DIM;                      // er n delelig med DIM?
    return k == 0 ? n : n - k + DIM;      // en multippel av DIM
  }
              Programkode 1.3.16 g) 

Konstruktøren i Programkode 1.3.16 d) lager en tallmengde ved hjelp av 
elementene i en tabell. Hvis vi var helt sikre på at parametertabellen var 
sortert stigende og uten duplikater, kunne vi lage konstruktøren mer effektiv. 
Flg. private konstruktør forutsetter at de n første elementene i i 
parametertabellen b er sortert og er forskjellige. Disse n verdiene blir da 
elementene i den tallmengden som konstruktøren lager: 

  private Tallmengde(int[] b, int n)
  {
    antall = n;
    a = new int[dim(n)];              // dim beregner tabellstørrelsen
    System.arraycopy(b,0,a,0,n);      // kopierer fra b til a
  }
              Programkode 1.3.16 h) 

En kopieringskonstruktør (eng: copy constructor) lager en kopi av et objekt som 
allerede finnes. Hvis tallmengden B allerede eksisterer, lages A som en kopi av 
B på denne måten: 

  Tallmengde A = new Tallmengde(B);    // A blir en kopi av B

              Programkode 1.3.16 i) 

Kopieringskonstruktøren for class Tallmengde lages slik: 

  public Tallmengde(Tallmengde B)           // en kopi av mengden B
  {
    this(B.a,B.antall);         // bruker den private konstruktøren
  }
              Programkode 1.3.16 j) 

Metoden union kan lages ved hjelp av denne korte koden når vi bruker union-metoden 
fra Programkode 1.3.13 f) og den private konstruktøren fra Programkode 1.3.16 h): 

  public Tallmengde union(Tallmengde B)     // returnerer unionen
  {
    int[] c = new int[antall + B.antall];     // en stor nok tabell
    int n = Tabell.union(a,antall,B.a,B.antall,c);
    return new Tallmengde(c,n);     // den private konstruktøren
  }
              Programkode 1.3.16 k) 

Flg. eksempel viser hvordan union-metoden kan brukes: 

  int[] a = {1,3,5,7,9};           // a er sortert
  int[] b = {4,2,6,2,4};           // b er usortert og har duplikater

  Tallmengde A = new Tallmengde(a);    // A = {1,3,5,7,9}
  Tallmengde B = new Tallmengde(b);    // B = {2,4,6}

  Tallmengde C = A.union(B);           // C = {1,2,3,4,5,6,7,9}

  System.out.println(A + " " + B + " " + C);

  // Utskrift: {1,3,5,7,9} {2,4,6} {{1,2,3,4,5,6,7,9}}

              Programkode 1.3.16 l) 

Resten av metodene som er satt opp i Programkode 1.3.16 a) tas som 
øvingsoppgaver. 

Oppgaver til Avsnitt 1.3.16 

1. Lag konstruktøren Tallmengde(int verdi). Den skal lage en mengde som består 
av det ene elementet verdi. 
2. Lag metodene tom, antall og tilTabell i class Tallmengde. Metoden tom skal 
returnere true hvis mengden er tom og returnere false ellers. Metoden antall 
skal returnere antallet elementer i mengden. Metoden tilTabell skal returnere en 
int-tabell som inneholder i sortert rekkefølge nøyaktig de elementene som 
mengden inneholder. 
3. Lag metoden equals i class Tallmengde. Vi må først undersøke om mengden blir 
sammenlignet med seg selv, dvs. om parameteren o er lik this. Hvis ja, 
returneres true. Så må o konverteres. Hvis o ikke er en instans av Tallmengde, 
returneres false. Til slutt bruker vi erLik-metoden fra Oppgave 8 i Avsnitt 1.3.13. 
4. Lag metoden erElement i class Tallmengde. Den skal returnere true hvis 
parameteren verdi er element i mengden, og returnere false ellers. Bruk binærsøk. 
5. Lag metoden fjern i class Tallmengde. Finn verdien ved hjelp av binærsøk og 
bruk så en for-løkke til å tette hullet. Hvis verdien ikke er der returneres 
false, ellers true. 
6. Lag metoden snitt i class Tallmengde. Se hvordan union er laget! Husk at 
antallet i snittet alltid er mindre enn eller lik antallet i den minste av de to 
mengdene. Bruk det når du dimensjonerer hjelpetabellen. Bruk så metoden fra 
Programkode 1.3.13 i). 
7. Lag metoden differans i class Tallmengde. Se hvordan union er laget! Benytt 
differans-metoden fra Oppgave 9 i Avsnitt 1.3.13. Husk at antallet i differansen 
A ? B er mindre enn eller lik antallet i A. 
8. Lag metoden inklusjon i class Tallmengde. Se hvordan union er laget! Benytt 
inklusjon-metoden fra Oppgave 10 i Avsnitt 1.3.13. 
9. Vi kan lage inklusjon ved hjelp av equals og snitt. Mengden B vil være 
inkludert i A hvis A snitt B er lik B. Lag en versjon av inklusjon som bruker 
denne idéen. 
10. Lag metoden xunion i class Tallmengde. Se hvordan union er laget! Benytt 
xunion-metoden fra Oppgave 11 i Avsnitt 1.3.13. 
11. Metoden xunion kan lages ved hjelp av metodene union og differans. Vi har at 
A xunion B er lik (A ? B) union (B ? A). Lag en versjon av xunion som bruker 
denne idéen. 
12. Metoden xunion kan lages ved hjelp av union, snitt og differans. Vi har at A 
xunion B er lik (A union B) ? (A snitt B). Lag en versjon av xunion som bruker 
denne idéen. 
13. Lag et program der du tester alle metodene i class Tallmengde. 


1.3.17 Dronninger på et sjakkbrett
Figur 1.3.17 a) : En oppstilling 
Et gammelt «problem» er det å kunne sette 8 dronninger på en «lovlig» måte på et 
sjakkbrett, dvs. uten at noen av dem slår hverandre. Som kjent kan en dronning 
slå vertikalt, horisontalt og på skrå. Dette «problemet» ble tatt opp allerede i 
Avsnitt 1.3.3 i forbindelse med permutasjoner. Der ble det vist at enhver «lovlig» 
dronningoppstilling på et 8 × 8 brett kunne ses på som en permutasjon av tallene 
fra 0 til 7. Og omvendt at enhver slik permutasjon kunne ses på som en 
oppstilling der hver rad og hver kolonne har nøyaktig én dronning. Dette 
avsnittet er en fortsettelse av Avsnitt 1.3.3. Alternative teknikker for «dronningproblemet» 
tas opp i Avsnitt 1.5.6 (rekursjon) og i Avsnitt 1.7.16 (bit-operatorer). 

I Avsnitt 1.3.3 ble antallet «lovlige» dronningoppstillinger for et 8 × 8 brett 
funnet ved hjelp av de to metodene nestePermutasjon og lovligOppstilling: 

  int n = 8, antall = 0;
  int[] p = Tabell.heleTall(0,n);         // p = {0,1, . . , n-1}

  while (Tabell.nestePermutasjon(p))
  {
    if (lovligOppstilling(p)) antall++;
  }

  System.out.println(antall);             // Utskrift: 92

              Programkode 1.3.17 a) 

I Programkode 1.3.17 a) starter vi med 0, 1, 2, 3, 4, 5, 6, 7. Metoden 
lovligOppstilling oppdager med en gang at det ikke kan stå en dronning i rute (1,1) 
når det allerede står en i (0,0). Vi kan dermed hoppe over de 6! = 720 
permutasjonene som starter med 0, 1. Den første som starter med 0, 2 finner vi 
ved å snu rekkefølgen på tallene som kommer etter første posisjon der det ikke 
kan stå en dronning, dvs. ved å snu 2, 3, 4, 5, 6, 7. Det gir 0, 1, 7, 6, 5, 4, 
3, 2. Dette er den siste permutasjonen som starter med 0, 1. Et nytt kall på 
metoden nestePermutasjon vil gi den første som ikke starter med 0, 1, dvs. 0, 2, 
1, 3, 4, 5, 6, 7. Dette gjelder generelt. Vi lager en ny versjon av metoden 
lovligOppstilling og nå med int som returtype. Hvis permutasjonen representerer 
en «lovlig» oppstilling skal 0 returneres. Hvis ikke skal posisjonen til den 
første dronningen som står «ulovlig», returneres: 

  public static int lovligOppstilling(int[] p)  // p er en permutasjon
  {
    for (int r = 1; r < p.length; r++)  // r radindeks, p[r] kolonneindeks
    {
      int diff = r - p[r], sum  = r + p[r];  // differens og sum

      for (int i = r - 1; i >= 0; i--)   // ser på radene oppover fra r
        if (sum == i + p[i] || diff == i - p[i]) return r;    // ulovlig
    }
    return 0;     // vi har en lovlig oppstilling
  }
              Programkode 1.3.17 b) 

Metoden i Programkode 1.3.17 b) vil fortelle oss posisjonen til den første 
dronningen som er «feilplassert». Da snur vi de tallene i permutasjoen som 
følger etter denne posisjonen (se Oppgave 1.3.3.3?). Vi kommer her til å lage 
mange forskjellige metoder i tilknytning til «Dronningproblemet». Da er det 
gunstig å samle dem i en egen klasse, dvs. class Dronning. Metoden i Programkode 
1.3.17 b) hører hjemme der. I tillegg lager vi en egen antall-metode som bruker 
teknikken beskrevet over: 

public class Dronning
{
  // Legg metoden fra Programkode 1.3.17 b) inn her!

  public static int antallLovlige(int n)
  {
    int[] p = Tabell.heleTall(0,n);    // Se Oppgave 1.2.2.7
    int antall = 0;

    while (true)
    {
      int r = lovligOppstilling(p);    // Programkode 1.3.17 b)

      if (r == 0) antall++;
      else Tabell.snu(p,r + 1);        // Se Oppgave 1.3.3.3

      if (Tabell.nestePermutasjon(p) == false) return antall;
    }
  }

}  // class Dronning

              Programkode 1.3.17 c) 

Vi har nå fått en vesentlig mer effektiv måte å telle opp de «lovlige» 
oppstillingene gjennom metoden antallLovlige i dronning-klassen. Den er god nok 
til å finne antallet også for større brett enn 8 × 8. F.eks. kan vi finne 
svarene for brett opp til og med 14 × 14 brett uten at det går så mange sekunder. 
Men som tidligere nevnt kan det gjøres enda mer effektivt. Det finnes mer 
effektive måter å generere permutasjoner på enn den måten metoden 
nestePermutasjon benytter. Vi kan f.eks. benytte rekursjon (Avsnitt 1.5.6) og 
bitoperatorer (Avsnitt 1.7.16), men det tas opp i andre kapitler. 

Flg. kode finner antallet «lovlige» dronningoppstillinger for n × n brett for n 
lik 8 til 14: 

  for (int n = 2; n < 15; n++)
    System.out.print(Dronning.antallLovlige(n) + " ");

  // Utskrift: 0 0 2 10 4 40 92 352 724 2680 14200 73712 365596

              Programkode 1.3.17 d) 

Halvering Det er mulig på enkel måte å halvere antallet permutasjoner som må 
undersøkes. Gitt de to permutasjonene 0, 4, 7, 5, 2, 6, 1, 3 og 7, 3, 0, 2, 5, 1, 
6, 4. Flg. to sjakkbrett viser hvilke dronningoppstillinger som de to 
representerer:  
Figur 1.3.17 b) : En oppstilling (venstre) og dens vertikale speiling (høyre) 

Brettet til venstre i Figur 1.3.17 b) viser oppstillingen som hører til 
permutasjonen 0, 4, 7, 5, 2, 6, 1, 3 og brettet til høyre den som hører til 7, 3, 
0, 2, 5, 1, 6, 4. Begge er «lovlige» oppstillinger. Det spesielle er imidlertid 
at den til høyre er en speiling om den vertikale midtlinjen på brettet av den 
til venstre. Dette gjelder generelt: Hvis en permutasjon som starter med 0, 1, 2 
eller 3 gir en «lovlige» oppstilling, så får vi en ny og forskjelling «lovlige» 
oppstilling hvis den første speiles vertikalt. Det betyr at vi kan nøye oss med 
å se på de permutasjonene som starter med 0, 1, 2 eller 3, og så gange det 
antallet vi finner med 2. 

Med et generelt n × n - brett må vi imidlertid være litt mer nøye. 
Argumentasjonen over gjelder hvis n er et partall. Men hvis n er et oddetall, 
får brettet en kolonne på midten. En vertikal speiling av en oppstilling med 
øverste dronning på midten, vil fortsatt ha øverste dronning på midten. Men hvis 
den nest øverste dronningen på en «lovlig» oppstilling står til venstre for 
midten, vil den komme til til høyre for midten etter en slik speiling. Dermed 
kan vi nøye oss med i dette tilfellet å se på de permutasjonene der nest øverste 
dronning står til venstre for midten og så gange antallet «lovlig» oppstillinger 
vi finner med 2. 

Flg. nye versjon av metoden antallLovlige bruker idéen fra diskusjonen over: 

  public static int antallLovlige(int n)   // ny versjon
  {
    int[] p = Tabell.heleTall(0,n);        // p = {0,1,2, . . , n-1}
    int antall = 0, m = n / 2;             // m er midten på brettet
    boolean odd = n % 2 != 0;

    while (p[0] < m || (odd && p[0] == m && p[1] < m))
    {
      int r = lovligOppstilling(p);        // sjekker permutasjonen

      if (r == 0) antall++;                // lovlig - øker antall med 2
      else Tabell.snu(p,r + 1);

      Tabell.nestePermutasjon(p);          // ny permutasjon
    }

    return antall * 2;       // speiling gir dobbelt så mange
  }
              Programkode 1.3.17 e) 

Den nye versjonen av antallLovlige i Programkode 1.3.17 e) er omtrent dobbelt så 
rask som den i Programkode 1.3.17 c)?. Se Oppgave 4-5. 

Boolsk tabell Det er mulig å forbedre metoden lovligOppstilling noe. Setning 1.3.3 
a) sier når to ruter hører til samme diagonal eller bidiagonal. Et 8 × 8 - brett 
har 15 diagonaler og 15 bidiagonaler. Generelt har et n × n - brett 2?·?n ? 1 
diagonaler og like mange bidiagonaler. 

Et 8 × 8 ? brett har 15 bidiagonaler. En bidiagonal går på skrå ned mot venstre. 
Den første bidiagonalen består av rute (0,0), den andre av rutene (0,1) og (1,0), 
den tredje av av rutene (0,2), (1,1) og (2,0), osv. I hver bidiagonal er summen 
av rad- og kolonneindeks konstant. Den første har en sum på 0, den andre en sum 
på 1, den tredje en sum på 2, osv. De 15 bidiagonalene kan representeres ved 
hjelp av en boolsk tabell:                
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
Figur 1.3.17 f) : En boolsk tabell for bidiagonaler 

Hvis en dronning plasseres i en rute blir tilhørende bidiagonal «opptatt». Det 
markeres ved at det settes true i posisjonen gitt som summen av rutens rad- og 
kolonneindeks. Anta at vi har dronninger i posisjonene (0,3), (1,5) og (2,2). 
Det gir summene 0 + 3 = 3, 1 + 5 = 6 og 2 + 2 = 4. Dermed skal det settes true i 
posisjonene 3, 4 og 6 i den boolske tabellen. På figuren under er dette markert 
med bokstaven D (D for dronning):    
D D  D         
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 
Figur 1.3.17 g) : En boolsk tabell for bidiagonaler 

Det blir på en tilsvarende måte for diagonaler. Forskjellen er at for diagonaler 
brukes differensen mellom rad- og kolonneindeks. Slike differenser vil variere 
fra ?7 til +7. Tilhørende posisjon i den boolske tabellen får vi da med å legge 
7 (eller generelt n ? 1) til differensen. 

  public static int lovligOppstilling(int[] p)      // ny versjon
  {
    int n = p.length;
    boolean bidiagonal[] = new boolean[2*n - 1];    // gir 15 hvis n = 8
    boolean diagonal[]   = new boolean[2*n - 1];    // gir 15 hvis n = 8

    for (int r = 0; r < n; r++)      // r er radindeks
    {
      int sum  = r + p[r];      // summen av rad- og kolonneindeks
      int diff = r - p[r];      // differensen mellom rad- og kolonneindeks

      if (bidiagonal[sum] || diagonal[diff + n - 1]) return r;  // opptatt

      bidiagonal[sum] = true;         // bidiagonalen settes til opptatt
      diagonal[diff + n - 1] = true;  // diagonalen settes til opptatt
    }
    return 0;    // dette er en lovlig dronningoppstilling
  }
              Programkode 1.3.17 f) 

Hvis vi bruker den nye versjonen av lovligOppstilling fra Programkode 1.3.17 f) 
bør vi få en liten bedring i effektiviteten. Se Oppgave 6. 

Unike løsninger Figur 1.3.17 b) viser at hvis en «lovlig» oppstilling (permutasjonen 
0, 4, 7, 5, 2, 6, 1, 3) speiles om brettets vertikale midtlinje, får vi en ny «lovlig» 
oppstilling (7, 3, 0, 2, 5, 1, 6, 4). Men vi kan også speile horisontalt (om den 
horisontale midtlinjen), diagonalt og bidiagonalt. Videre kan vi rotere om 
brettes sentrum ? 90°, 180° eller 270°. Hvis vi starter med 0, 4, 7, 5, 2, 6, 1, 
3, får vi dermed flg. «lovlige» oppstillinger: 

    0, 4, 7, 5, 2, 6, 1, 3         Start (rotasjon 0°)
    7, 1, 3, 0, 6, 4, 2, 5         Rotasjon 90°
    4, 6, 1, 5, 2, 0, 3, 7         Rotasjon 180°
    2, 5, 3, 1, 7, 4, 6, 0         Rotasjon 270°
    7, 3, 0, 2, 5, 1, 6, 4         Vertikal speiling
    3, 1, 6, 2, 5, 7, 4, 0         Horisontal speiling
    0, 6, 4, 7, 1, 3, 5, 2         Diagonal speiling
    5, 2, 4, 6, 0, 3, 1, 7         Bidiagonal speiling

              Figur 1.3.17 h) : Rotasjoner og speilinger 

Figur 1.3.17 h) viser at én «lovlig» dronningoppstilling, kan gi opptil syv nye 
ved rotasjoner og speilinger. De åtte operasjonene i Figur 1.3.17 h) kalles 
permutasjonstransformasjoner eller bare transformasjoner. Det å rotere 0° kalles 
vanligvis for identitetstransformasjonen.  
Figur 1.3.17 i) : En oversikt over permutasjonstransformasjoner 

I Figur 1.3.2 i) betyr 0, 90, 180 og 270 rotasjoner og V, H, D og B henholdsvis 
vertikal, horisontal, diagonal og bidiagonal speiling. Tar vi raden for 90° 
rotasjon og kolonnen for vertikal speiling (V), sier tabellen at det å rotere 90° 
og så speile vertikalt, er det samme som kun å speile diagonalt (D). Tabellen 
viser resultatet av alle mulige sammensetninger av to transformasjoner. F.eks. 
vil en horisontal speiling etterfulgt av en diagonal speiling gi samme resultat 
som en 90° rotasjon. Legg merke til at tabellen ikke er symmetrisk om 
hoveddiagonalen. Det betyr at det å bytte rekkefølgen på to transformasjoner kan 
gi et annet resultat. Som nevnt over blir en horisontal og så en diagonal 
speiling, det samme som en rotasjon på 90°. Men motsatt vei, dvs. en diagonal og 
så en horisontal speiling blir det samme som en rotasjon på 270°. 

La p og q være to permutasjoner. Vi sier at p er relatert til q hvis vi kan få q 
ved å anvende en av de åtte transformasjonene på p. Dette blir en 
ekvivalensrelasjon. Den er åpenbart refleksiv siden vi kan få p ved å rotere p 
en vinkel på 0° (identitetstransformasjonen). La q være relatert til p, dvs. det 
finnes en transformasjon T slik at T(p) = q. Da finnes det også en 
transformasjon S slik at S(q) = p. Hvis T er en speiling, vil S = T fungere, og 
hvis T er en rotasjon, velger vi en rotasjon S slik at det tilsammen blir 360 
grader. Det betyr at relasjonen er symmetrisk. La så p være relatert til q og q 
relatert til r. Det betyr at det finnes transformasjoner T og S slik at T(p) = q 
og S(q) = r. Men tabellen i Figur 1.3.17 i) viser at uansett hva T og S er, så 
kan sammensetingen ST erstattes av en enkelt transformasjon. Det betyr at p og r 
er relatert. Med andre ord er relasjonen transitiv. 

Relasjonen definert ovenfor er en ekvivalensrelasjon på mengden av permutasjoner. 
Det betyr at permutasjonene kan deles opp i ekvivalensklasser. 

Definisjon 1.3.17 a) ? Ekvivalente oppstillinger To «lovlige» oppstillinger er 
ekvivalente hvis de hører til samme ekvivalensklasse, dvs. hvis vi kan få den 
ene fra den andre ved en rotasjon eller speiling. 

Vi fant at et 8 × 8 ? brett har 92 forskjellige løsninger. Spørsmålet er nå hvor 
mange forskjellige ekvivalensklasser det er for disse 92 løsningene? 

Definisjon 1.3.17 b) ? Unike oppstillinger To «lovlige» oppstillinger er 
innbyrdes unike hvis de ikke er ekvivalente. 

Vi har sett ovenfor at ekvivalensklassen til 0, 4, 7, 5, 2, 6, 1, 3 inneholder 8 
forskjellige permutasjoner. Da kunne man lett tro at vi finner antallet 
ekvivalensklasser, dvs. antallet unike løsninger, ved å dele 92 med 8. Men det 
regnestykket går ikke opp. Det viser seg at det er 12 unike løsninger. Det er 11 
ekvivalensklasser som alle inneholder 8 permutasjoner og en som inneholder 4. 
Det gir 11?·?8 + 4 = 92. Permutasjonen 2, 4, 1, 7, 0, 6, 3, 5 representerer en «lovlig» 
oppstilling. Men dens ekvivalensklasse inneholder bare 4 permutasjoner. Vi får 
samme permutasjon enten vi speiler permutasjonen 2, 4, 1, 7, 0, 6, 3, 5 
vertikalt eller horisontalt. Se Oppgave 8. 

Det er enkelt å lage kode for noen av transformasjonene. Vertikal speiling er 
kanskje den enkleste. Hvis vi er på et 8 × 8 ? brett og har en dronning i en 
rute med r og k som rad- og kolonneindeks, vil den ved en vertikal speiling 
havne på samme rad, men med kolonneindeks lik 7 ? k. F.eks. vil en dronning i 
rute (0,2) speiles til (0,5) der 5 = 7 ? 2. Hvis vi har et n × n ? brett vil 
rute (r?,?k) speiles til rute (r?, n ? 1 ? k). De andre speilingene og 
rotasjonene er litt mer kompliserte å lage, men med litt prøving og feiling 
finner en fort hvordan de må lages. Flg. metoder legges i klassen Dronning: 

  public static int[] rotasjon90(int[] p)     // rotasjon 90 grader
  {
    int n = p.length; int[] q = new int[n];
    for (int i = 0; i < n; i++) q[p[i]] = n - 1 - i;
    return q;
  }

  public static int[] rotasjon180(int[] p)    // rotasjon 180 grader
  {
    int n = p.length; int[] q = new int[n];
    for (int i = 0; i < n; i++) q[n - 1 - i] = n - 1 - p[i];
    return q;
  } 

  public static int[] rotasjon270(int[] p)    // rotasjon 270 grader
  {
    int n = p.length; int[] q = new int[n];
    for (int i = 0; i < n; i++) q[n - 1 - p[i]] = i;
    return q;
  }

  public static int[] vertikal(int[] p)       // vertikal speiling
  {
    int n = p.length; int[] q = new int[n];
    for (int i = 0; i < n; i++) q[i] = n - 1 - p[i];
    return q;
  }

  public static int[] horisontal(int[] p)     // horisontal speiling
  {
    int n = p.length; int[] q = new int[n];
    for (int i = 0, j = n - 1; i < n;) q[i++] = p[j--];
    return q;
  }

  public static int[] diagonal(int[] p)       // diagonal speiling
  {
    int n = p.length; int[] q = new int[n];
    for (int i = 0; i < n; i++) q[p[i]] = i;
    return q;
  }

  public static int[] bidiagonal(int[] p)     // bidiagonal speiling
  {
    int n = p.length; int[] q = new int[n];
    for (int i = 0; i < n; i++) q[n - 1 - p[i]] = n - 1 - i;
    return q;
  }
              Programkode 1.3.17 g) 

Flg. eksempel viser hvordan rotasjons- og speilingsmetodene kan brukes: 

  int[] p = {0,4,7,5,2,6,1,3};

  String p90 = Arrays.toString(Dronning.rotasjon90(p));
  String pD = Arrays.toString(Dronning.diagonal(p));

  System.out.println(p90 + "  " + pD);

  // Utskrift: [7, 1, 3, 0, 6, 4, 2, 5]  [0, 6, 4, 7, 1, 3, 5, 2]

              Programkode 1.3.17 h) 

I metoden antallLovlige teller vi opp alle «lovlige» oppstillinger på et n × n ? 
brett. Målet nå er å telle kun de unike. Permutasjonene genereres i 
leksikografisk rekkefølge. Av de som er ekvivalente kommer derfor den 
leksikografisk «minste» først. Dermed kan vi for hver permutasjon avgjøre om det 
er den første av de som er ekvivalente eller ikke. For hver permutasjon p 
utfører vi de syv transformasjonene og hvis en av dem gir en som kommer før p 
leksikografisk, må vi ha fått den tidligere. Dermed kan vi la være å telle opp p 
siden en som er ekvivalent allerede er registert. 

Vi trenger en metode som avgjør om en permutasjon p er lik eller kommer foran en 
permutasjon q leksikografisk. Flg. metode returnerer true hvis det er tilfellet 
og false ellers. Metoden skal ligge i klassen Dronning: 

  public static boolean foran(int[] p, int[] q)
  {
    for (int i = 0; i < p.length; i++)
    {
      if (p[i] < q[i]) return true;           // p kommer foran q
      else if (p[i] > q[i]) return false;     // q kommer foran p
    }

    return true;                              // p og q er like
  }
              Programkode 1.3.17 i) 

Vi trenger i tillegg en metode som avgjør om en permutasjon p er først av de 
permutasjonene som den er ekvivalent med: 

  public static boolean førstLeksikografisk(int[] p)
  {
    return
    foran(p,rotasjon90(p))          // roterer 90 grader
    && foran(p,rotasjon180(p))      // roterer 180 grader
    && foran(p,rotasjon270(p))      // roterer 270 grader
    && foran(p,vertikal(p))         // speiler vertikalt
    && foran(p,horisontal(p))       // speiler horisontalt
    && foran(p,diagonal(p))         // speiler diagonalt
    && foran(p,bidiagonal(p));      // speiler bidiagonalt
  }
              Programkode 1.3.17 j) 

En metode som finner antallet unike «lovlige» oppstillinger på et n × n ? brett 
kan lages ved hjelp av en liten endring i metoden antallLovlige?: 

  public static int antallUnike(int n)
  {
    int[] p = Tabell.heleTall(0,n);        // p = {0,1,2, . . , n-1}
    int antall = 0, m = n / 2;             // m er midten på brettet
    boolean odd = n % 2 != 0;

    while (p[0] < m || (odd && p[0] == m && p[1] < m))
    {
      int r = lovligOppstilling(p);        // sjekker permutasjonen

      if (r == 0) { if (førstLeksikografisk(p)) antall++; }
      else Tabell.snu(p,r + 1);

      Tabell.nestePermutasjon(p);          // ny permutasjon
    }

    return antall;
  }
              Programkode 1.3.17 j) 

Flg. eksempel viser hvordan metoden antallUnike kan brukes: 

  for (int n = 8; n < 15; n++)
    System.out.print(Dronning.antallUnike(n) + " ");

  // Utskrift: 12 46 92 341 1787 9233 45752

              Programkode 1.3.17 k) 

Oppsummering Som nevnt over finnes det andre og vesentlig mer effektive måter å 
løse dronningproblemet på. I Avsnitt 1.5.6 vil vi bruke rekursive teknikker. I 
Avsnitt 1.7.16 bruker vi i tillegg bitoperatorer og der kommer den «ultimate» 
løsningen av dronningproblemet. 

Oppgaver til Avsnitt 1.3.17 
1. Søk på internett etter informasjon om dronningproblemet. Bruk f.eks. eight 
queens som søkeord. Antallet lovlige dronningoppstillinger er kjent for brett 
opp til størrelse 25 × 25. Les på internett om hvordan man løste dette for et 25 
× 25 ? brett.  
2. Hvilke av flg. permutasjoner utgjør lovlige dronningoppstillinger på et 6 × 6 
? brett:
i) 1, 3, 0, 2, 4, 5 ii) 1, 3, 5, 0, 2, 4 iii) 3, 0, 4, 1, 5, 2  
3. Hvilke av flg. permutasjoner utgjør lovlige dronningoppstillinger på et 8 × 8 
? brett:
i) 1, 3, 0, 6, 4, 2, 5, 7 ii) 2, 0, 6, 4, 7, 1, 3, 5 iii) 3, 0, 2, 5, 1, 6, 4, 7 
iv) 5, 7, 1, 3, 0, 6, 4, 2  
4. Opprett klassen Dronning fra Programkode 1.3.17 c). Legg inn Programkode 1.3.17 
b). Lag så et program som kjører Programkode 1.3.17 d). Hvor lang tid bruker 
programmet?  
5. Bytt ut (se Oppgave 4) metoden antallLovlige i class Dronning med den nye 
versjonen i Programkode 1.3.17 e). Gjenta tidsmålingene fra Oppgave 4. Går det 
dobbelt så fort?  
6. Lag en metoden public static int[] førsteLovlige(int n) i klassen Dronning. 
Den skal returere den første (i leksikografisk rekkefølge) permutasjonen som 
representerer en «lovlig» dronningoppstilling på et n × n ? brett. Finn så disse 
permutasjonene for n fra 8 til 14.  
7. Erstatt den gamle versjonen av lovligOppstilling i klassen Dronning med den 
nye i Programkode 1.3.17 f). Gir det noen tidsbesparelser?  
8. Permutasjonen p = 0, 2, 4, 1, 3 utgjør en lovlig dronningoppstilling på et 5 
× 5 ? brett. Finn f.eks. ved hjelp av tegninger hvilke permutasjoner vi får når 
p roteres på de tre måtene og speiles på de fire måtene. Hva blir det hvis p 
isteden er lik 1, 4, 2, 0, 3?  
9. La p = 2, 4, 1, 7, 0, 6, 3, 5 dvs. et 8 × 8 ? brett. Gjør som i Oppgave 8.  
10. Tabellen i Figur 1.3.17 i) viser resultatet av å sette sammen to og to 
transformasjoner. Det påstås f.eks. at en horisontal speiling etterfulgt av en 
diagonal speiling er det samme som en rotasjon på 90 grader og at hvis 
rekkefølgen byttes blir det lik en rotasjon på 270 grader. Tegn et brett med en 
oppstilling og sjekk så på tegningen at disse påstandene stemmer.  
11. Bevis for deg selv at koden for transformasjonene i Programkode 1.3.17 h) er 
korrekt.  
12. Utvid Programkode 1.3.17 h) med de øvrige transformasjonene (rotasjonene og 
speilingene). Sjekk at resultatet blir som i Figur 1.3.17 h).  
13. Lag kode som skriver ut de 12 unike løsningene for et 8 × 8 ? brett  

1.3.18 Algoritmeanalyse

?1.?Partisjonering - antall ombyttinger er i pdf-format. 

?2.?Binærsøk - antall sammenligninger er i pdf-format. 

?3.?Rotasjonssykler er i pdf-format. 


Copyright © Ulf Uttersrud, 2013. All rights reserved. 